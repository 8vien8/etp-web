var j2 = Object.defineProperty; var S2 = (e, t, n) => t in e ? j2(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var E = (e, t, n) => (S2(e, typeof t != "symbol" ? t + "" : t, n), n); function k2(e, t) { for (var n = 0; n < t.length; n++) { const i = t[n]; if (typeof i != "string" && !Array.isArray(i)) { for (const r in i) if (r !== "default" && !(r in e)) { const s = Object.getOwnPropertyDescriptor(i, r); s && Object.defineProperty(e, r, s.get ? s : { enumerable: !0, get: () => i[r] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = n(r); fetch(r.href, s) } })(); function za(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var _g = { exports: {} }, La = {}, wg = { exports: {} }, Y = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Is = Symbol.for("react.element"), C2 = Symbol.for("react.portal"), O2 = Symbol.for("react.fragment"), P2 = Symbol.for("react.strict_mode"), E2 = Symbol.for("react.profiler"), M2 = Symbol.for("react.provider"), D2 = Symbol.for("react.context"), T2 = Symbol.for("react.forward_ref"), N2 = Symbol.for("react.suspense"), R2 = Symbol.for("react.memo"), z2 = Symbol.for("react.lazy"), mf = Symbol.iterator; function L2(e) { return e === null || typeof e != "object" ? null : (e = mf && e[mf] || e["@@iterator"], typeof e == "function" ? e : null) } var jg = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Sg = Object.assign, kg = {}; function cr(e, t, n) { this.props = e, this.context = t, this.refs = kg, this.updater = n || jg } cr.prototype.isReactComponent = {}; cr.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; cr.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Cg() { } Cg.prototype = cr.prototype; function Yu(e, t, n) { this.props = e, this.context = t, this.refs = kg, this.updater = n || jg } var Xu = Yu.prototype = new Cg; Xu.constructor = Yu; Sg(Xu, cr.prototype); Xu.isPureReactComponent = !0; var yf = Array.isArray, Og = Object.prototype.hasOwnProperty, Ku = { current: null }, Pg = { key: !0, ref: !0, __self: !0, __source: !0 }; function Eg(e, t, n) { var i, r = {}, s = null, o = null; if (t != null) for (i in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = "" + t.key), t) Og.call(t, i) && !Pg.hasOwnProperty(i) && (r[i] = t[i]); var a = arguments.length - 2; if (a === 1) r.children = n; else if (1 < a) { for (var l = Array(a), c = 0; c < a; c++)l[c] = arguments[c + 2]; r.children = l } if (e && e.defaultProps) for (i in a = e.defaultProps, a) r[i] === void 0 && (r[i] = a[i]); return { $$typeof: Is, type: e, key: s, ref: o, props: r, _owner: Ku.current } } function A2(e, t) { return { $$typeof: Is, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function Gu(e) { return typeof e == "object" && e !== null && e.$$typeof === Is } function I2(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var vf = /\/+/g; function ul(e, t) { return typeof e == "object" && e !== null && e.key != null ? I2("" + e.key) : t.toString(36) } function Co(e, t, n, i, r) { var s = typeof e; (s === "undefined" || s === "boolean") && (e = null); var o = !1; if (e === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (e.$$typeof) { case Is: case C2: o = !0 } }if (o) return o = e, r = r(o), e = i === "" ? "." + ul(o, 0) : i, yf(r) ? (n = "", e != null && (n = e.replace(vf, "$&/") + "/"), Co(r, t, n, "", function (c) { return c })) : r != null && (Gu(r) && (r = A2(r, n + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(vf, "$&/") + "/") + e)), t.push(r)), 1; if (o = 0, i = i === "" ? "." : i + ":", yf(e)) for (var a = 0; a < e.length; a++) { s = e[a]; var l = i + ul(s, a); o += Co(s, t, n, l, r) } else if (l = L2(e), typeof l == "function") for (e = l.call(e), a = 0; !(s = e.next()).done;)s = s.value, l = i + ul(s, a++), o += Co(s, t, n, l, r); else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return o } function Ks(e, t, n) { if (e == null) return e; var i = [], r = 0; return Co(e, i, "", "", function (s) { return t.call(n, s, r++) }), i } function F2(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Ye = { current: null }, Oo = { transition: null }, $2 = { ReactCurrentDispatcher: Ye, ReactCurrentBatchConfig: Oo, ReactCurrentOwner: Ku }; Y.Children = { map: Ks, forEach: function (e, t, n) { Ks(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Ks(e, function () { t++ }), t }, toArray: function (e) { return Ks(e, function (t) { return t }) || [] }, only: function (e) { if (!Gu(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; Y.Component = cr; Y.Fragment = O2; Y.Profiler = E2; Y.PureComponent = Yu; Y.StrictMode = P2; Y.Suspense = N2; Y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $2; Y.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var i = Sg({}, e.props), r = e.key, s = e.ref, o = e._owner; if (t != null) { if (t.ref !== void 0 && (s = t.ref, o = Ku.current), t.key !== void 0 && (r = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) Og.call(t, l) && !Pg.hasOwnProperty(l) && (i[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) i.children = n; else if (1 < l) { a = Array(l); for (var c = 0; c < l; c++)a[c] = arguments[c + 2]; i.children = a } return { $$typeof: Is, type: e.type, key: r, ref: s, props: i, _owner: o } }; Y.createContext = function (e) { return e = { $$typeof: D2, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: M2, _context: e }, e.Consumer = e }; Y.createElement = Eg; Y.createFactory = function (e) { var t = Eg.bind(null, e); return t.type = e, t }; Y.createRef = function () { return { current: null } }; Y.forwardRef = function (e) { return { $$typeof: T2, render: e } }; Y.isValidElement = Gu; Y.lazy = function (e) { return { $$typeof: z2, _payload: { _status: -1, _result: e }, _init: F2 } }; Y.memo = function (e, t) { return { $$typeof: R2, type: e, compare: t === void 0 ? null : t } }; Y.startTransition = function (e) { var t = Oo.transition; Oo.transition = {}; try { e() } finally { Oo.transition = t } }; Y.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; Y.useCallback = function (e, t) { return Ye.current.useCallback(e, t) }; Y.useContext = function (e) { return Ye.current.useContext(e) }; Y.useDebugValue = function () { }; Y.useDeferredValue = function (e) { return Ye.current.useDeferredValue(e) }; Y.useEffect = function (e, t) { return Ye.current.useEffect(e, t) }; Y.useId = function () { return Ye.current.useId() }; Y.useImperativeHandle = function (e, t, n) { return Ye.current.useImperativeHandle(e, t, n) }; Y.useInsertionEffect = function (e, t) { return Ye.current.useInsertionEffect(e, t) }; Y.useLayoutEffect = function (e, t) { return Ye.current.useLayoutEffect(e, t) }; Y.useMemo = function (e, t) { return Ye.current.useMemo(e, t) }; Y.useReducer = function (e, t, n) { return Ye.current.useReducer(e, t, n) }; Y.useRef = function (e) { return Ye.current.useRef(e) }; Y.useState = function (e) { return Ye.current.useState(e) }; Y.useSyncExternalStore = function (e, t, n) { return Ye.current.useSyncExternalStore(e, t, n) }; Y.useTransition = function () { return Ye.current.useTransition() }; Y.version = "18.2.0"; wg.exports = Y; var S = wg.exports; const I = za(S), B2 = k2({ __proto__: null, default: I }, [S]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var W2 = S, V2 = Symbol.for("react.element"), U2 = Symbol.for("react.fragment"), H2 = Object.prototype.hasOwnProperty, Y2 = W2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, X2 = { key: !0, ref: !0, __self: !0, __source: !0 }; function Mg(e, t, n) { var i, r = {}, s = null, o = null; n !== void 0 && (s = "" + n), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (o = t.ref); for (i in t) H2.call(t, i) && !X2.hasOwnProperty(i) && (r[i] = t[i]); if (e && e.defaultProps) for (i in t = e.defaultProps, t) r[i] === void 0 && (r[i] = t[i]); return { $$typeof: V2, type: e, key: s, ref: o, props: r, _owner: Y2.current } } La.Fragment = U2; La.jsx = Mg; La.jsxs = Mg; _g.exports = La; var u = _g.exports, Zl = {}, Dg = { exports: {} }, ft = {}, Tg = { exports: {} }, Ng = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(M, z) { var F = M.length; M.push(z); e: for (; 0 < F;) { var ie = F - 1 >>> 1, re = M[ie]; if (0 < r(re, z)) M[ie] = z, M[F] = re, F = ie; else break e } } function n(M) { return M.length === 0 ? null : M[0] } function i(M) { if (M.length === 0) return null; var z = M[0], F = M.pop(); if (F !== z) { M[0] = F; e: for (var ie = 0, re = M.length, pt = re >>> 1; ie < pt;) { var Ne = 2 * (ie + 1) - 1, gt = M[Ne], ke = Ne + 1, Yn = M[ke]; if (0 > r(gt, F)) ke < re && 0 > r(Yn, gt) ? (M[ie] = Yn, M[ke] = F, ie = ke) : (M[ie] = gt, M[Ne] = F, ie = Ne); else if (ke < re && 0 > r(Yn, F)) M[ie] = Yn, M[ke] = F, ie = ke; else break e } } return z } function r(M, z) { var F = M.sortIndex - z.sortIndex; return F !== 0 ? F : M.id - z.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; e.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); e.unstable_now = function () { return o.now() - a } } var l = [], c = [], d = 1, f = null, h = 3, p = !1, g = !1, v = !1, x = typeof setTimeout == "function" ? setTimeout : null, y = typeof clearTimeout == "function" ? clearTimeout : null, m = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function b(M) { for (var z = n(c); z !== null;) { if (z.callback === null) i(c); else if (z.startTime <= M) i(c), z.sortIndex = z.expirationTime, t(l, z); else break; z = n(c) } } function j(M) { if (v = !1, b(M), !g) if (n(l) !== null) g = !0, J(w); else { var z = n(c); z !== null && q(j, z.startTime - M) } } function w(M, z) { g = !1, v && (v = !1, y(O), O = -1), p = !0; var F = h; try { for (b(z), f = n(l); f !== null && (!(f.expirationTime > z) || M && !A());) { var ie = f.callback; if (typeof ie == "function") { f.callback = null, h = f.priorityLevel; var re = ie(f.expirationTime <= z); z = e.unstable_now(), typeof re == "function" ? f.callback = re : f === n(l) && i(l), b(z) } else i(l); f = n(l) } if (f !== null) var pt = !0; else { var Ne = n(c); Ne !== null && q(j, Ne.startTime - z), pt = !1 } return pt } finally { f = null, h = F, p = !1 } } var k = !1, C = null, O = -1, D = 5, T = -1; function A() { return !(e.unstable_now() - T < D) } function $() { if (C !== null) { var M = e.unstable_now(); T = M; var z = !0; try { z = C(!0, M) } finally { z ? se() : (k = !1, C = null) } } else k = !1 } var se; if (typeof m == "function") se = function () { m($) }; else if (typeof MessageChannel < "u") { var Ee = new MessageChannel, X = Ee.port2; Ee.port1.onmessage = $, se = function () { X.postMessage(null) } } else se = function () { x($, 0) }; function J(M) { C = M, k || (k = !0, se()) } function q(M, z) { O = x(function () { M(e.unstable_now()) }, z) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (M) { M.callback = null }, e.unstable_continueExecution = function () { g || p || (g = !0, J(w)) }, e.unstable_forceFrameRate = function (M) { 0 > M || 125 < M ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < M ? Math.floor(1e3 / M) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return h }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (M) { switch (h) { case 1: case 2: case 3: var z = 3; break; default: z = h }var F = h; h = z; try { return M() } finally { h = F } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (M, z) { switch (M) { case 1: case 2: case 3: case 4: case 5: break; default: M = 3 }var F = h; h = M; try { return z() } finally { h = F } }, e.unstable_scheduleCallback = function (M, z, F) { var ie = e.unstable_now(); switch (typeof F == "object" && F !== null ? (F = F.delay, F = typeof F == "number" && 0 < F ? ie + F : ie) : F = ie, M) { case 1: var re = -1; break; case 2: re = 250; break; case 5: re = 1073741823; break; case 4: re = 1e4; break; default: re = 5e3 }return re = F + re, M = { id: d++, callback: z, priorityLevel: M, startTime: F, expirationTime: re, sortIndex: -1 }, F > ie ? (M.sortIndex = F, t(c, M), n(l) === null && M === n(c) && (v ? (y(O), O = -1) : v = !0, q(j, F - ie))) : (M.sortIndex = re, t(l, M), g || p || (g = !0, J(w))), M }, e.unstable_shouldYield = A, e.unstable_wrapCallback = function (M) { var z = h; return function () { var F = h; h = z; try { return M.apply(this, arguments) } finally { h = F } } } })(Ng); Tg.exports = Ng; var K2 = Tg.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rg = S, dt = K2; function P(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var zg = new Set, cs = {}; function xi(e, t) { Zi(e, t), Zi(e + "Capture", t) } function Zi(e, t) { for (cs[e] = t, e = 0; e < t.length; e++)zg.add(t[e]) } var cn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ec = Object.prototype.hasOwnProperty, G2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, xf = {}, bf = {}; function Q2(e) { return ec.call(bf, e) ? !0 : ec.call(xf, e) ? !1 : G2.test(e) ? bf[e] = !0 : (xf[e] = !0, !1) } function q2(e, t, n, i) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return i ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function J2(e, t, n, i) { if (t === null || typeof t > "u" || q2(e, t, n, i)) return !0; if (i) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function Xe(e, t, n, i, r, s, o) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o } var Le = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Le[e] = new Xe(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Le[t] = new Xe(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Le[e] = new Xe(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Le[e] = new Xe(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Le[e] = new Xe(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Le[e] = new Xe(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Le[e] = new Xe(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Le[e] = new Xe(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Le[e] = new Xe(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Qu = /[\-:]([a-z])/g; function qu(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Qu, qu); Le[t] = new Xe(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Qu, qu); Le[t] = new Xe(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Qu, qu); Le[t] = new Xe(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Le[e] = new Xe(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Le.xlinkHref = new Xe("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Le[e] = new Xe(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Ju(e, t, n, i) { var r = Le.hasOwnProperty(t) ? Le[t] : null; (r !== null ? r.type !== 0 : i || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (J2(t, n, r, i) && (n = null), i || r === null ? Q2(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : r.mustUseProperty ? e[r.propertyName] = n === null ? r.type === 3 ? !1 : "" : n : (t = r.attributeName, i = r.attributeNamespace, n === null ? e.removeAttribute(t) : (r = r.type, n = r === 3 || r === 4 && n === !0 ? "" : "" + n, i ? e.setAttributeNS(i, t, n) : e.setAttribute(t, n)))) } var hn = Rg.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Gs = Symbol.for("react.element"), Ti = Symbol.for("react.portal"), Ni = Symbol.for("react.fragment"), Zu = Symbol.for("react.strict_mode"), tc = Symbol.for("react.profiler"), Lg = Symbol.for("react.provider"), Ag = Symbol.for("react.context"), ed = Symbol.for("react.forward_ref"), nc = Symbol.for("react.suspense"), ic = Symbol.for("react.suspense_list"), td = Symbol.for("react.memo"), mn = Symbol.for("react.lazy"), Ig = Symbol.for("react.offscreen"), _f = Symbol.iterator; function br(e) { return e === null || typeof e != "object" ? null : (e = _f && e[_f] || e["@@iterator"], typeof e == "function" ? e : null) } var ye = Object.assign, dl; function zr(e) {
    if (dl === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); dl = t && t[1] || "" } return `
`+ dl + e
} var fl = !1; function hl(e, t) {
    if (!e || fl) return ""; fl = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (c) { var i = c } Reflect.construct(e, [], t) } else { try { t.call() } catch (c) { i = c } e.call(t.prototype) } else { try { throw Error() } catch (c) { i = c } e() } } catch (c) {
        if (c && i && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (r[o] !== s[a]) {
                if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || r[o] !== s[a]) {
                    var l = `
`+ r[o].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
                } while (1 <= o && 0 <= a); break
            }
        }
    } finally { fl = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? zr(e) : ""
} function Z2(e) { switch (e.tag) { case 5: return zr(e.type); case 16: return zr("Lazy"); case 13: return zr("Suspense"); case 19: return zr("SuspenseList"); case 0: case 2: case 15: return e = hl(e.type, !1), e; case 11: return e = hl(e.type.render, !1), e; case 1: return e = hl(e.type, !0), e; default: return "" } } function rc(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Ni: return "Fragment"; case Ti: return "Portal"; case tc: return "Profiler"; case Zu: return "StrictMode"; case nc: return "Suspense"; case ic: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Ag: return (e.displayName || "Context") + ".Consumer"; case Lg: return (e._context.displayName || "Context") + ".Provider"; case ed: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case td: return t = e.displayName || null, t !== null ? t : rc(e.type) || "Memo"; case mn: t = e._payload, e = e._init; try { return rc(e(t)) } catch { } }return null } function ey(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return rc(t); case 8: return t === Zu ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function An(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Fg(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function ty(e) { var t = Fg(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), i = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var r = n.get, s = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return r.call(this) }, set: function (o) { i = "" + o, s.call(this, o) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return i }, setValue: function (o) { i = "" + o }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Qs(e) { e._valueTracker || (e._valueTracker = ty(e)) } function $g(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), i = ""; return e && (i = Fg(e) ? e.checked ? "true" : "false" : e.value), e = i, e !== n ? (t.setValue(e), !0) : !1 } function Ho(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function sc(e, t) { var n = t.checked; return ye({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function wf(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, i = t.checked != null ? t.checked : t.defaultChecked; n = An(t.value != null ? t.value : n), e._wrapperState = { initialChecked: i, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function Bg(e, t) { t = t.checked, t != null && Ju(e, "checked", t, !1) } function oc(e, t) { Bg(e, t); var n = An(t.value), i = t.type; if (n != null) i === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (i === "submit" || i === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? ac(e, t.type, n) : t.hasOwnProperty("defaultValue") && ac(e, t.type, An(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function jf(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var i = t.type; if (!(i !== "submit" && i !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function ac(e, t, n) { (t !== "number" || Ho(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Lr = Array.isArray; function Ui(e, t, n, i) { if (e = e.options, t) { t = {}; for (var r = 0; r < n.length; r++)t["$" + n[r]] = !0; for (n = 0; n < e.length; n++)r = t.hasOwnProperty("$" + e[n].value), e[n].selected !== r && (e[n].selected = r), r && i && (e[n].defaultSelected = !0) } else { for (n = "" + An(n), t = null, r = 0; r < e.length; r++) { if (e[r].value === n) { e[r].selected = !0, i && (e[r].defaultSelected = !0); return } t !== null || e[r].disabled || (t = e[r]) } t !== null && (t.selected = !0) } } function lc(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(P(91)); return ye({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Sf(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(P(92)); if (Lr(n)) { if (1 < n.length) throw Error(P(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: An(n) } } function Wg(e, t) { var n = An(t.value), i = An(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), i != null && (e.defaultValue = "" + i) } function kf(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Vg(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function cc(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Vg(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var qs, Ug = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, i, r) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, i, r) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (qs = qs || document.createElement("div"), qs.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = qs.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function us(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Xr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, ny = ["Webkit", "ms", "Moz", "O"]; Object.keys(Xr).forEach(function (e) { ny.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Xr[t] = Xr[e] }) }); function Hg(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Xr.hasOwnProperty(e) && Xr[e] ? ("" + t).trim() : t + "px" } function Yg(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var i = n.indexOf("--") === 0, r = Hg(n, t[n], i); n === "float" && (n = "cssFloat"), i ? e.setProperty(n, r) : e[n] = r } } var iy = ye({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function uc(e, t) { if (t) { if (iy[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(P(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(P(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(P(61)) } if (t.style != null && typeof t.style != "object") throw Error(P(62)) } } function dc(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var fc = null; function nd(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var hc = null, Hi = null, Yi = null; function Cf(e) { if (e = Bs(e)) { if (typeof hc != "function") throw Error(P(280)); var t = e.stateNode; t && (t = Ba(t), hc(e.stateNode, e.type, t)) } } function Xg(e) { Hi ? Yi ? Yi.push(e) : Yi = [e] : Hi = e } function Kg() { if (Hi) { var e = Hi, t = Yi; if (Yi = Hi = null, Cf(e), t) for (e = 0; e < t.length; e++)Cf(t[e]) } } function Gg(e, t) { return e(t) } function Qg() { } var pl = !1; function qg(e, t, n) { if (pl) return e(t, n); pl = !0; try { return Gg(e, t, n) } finally { pl = !1, (Hi !== null || Yi !== null) && (Qg(), Kg()) } } function ds(e, t) { var n = e.stateNode; if (n === null) return null; var i = Ba(n); if (i === null) return null; n = i[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (i = !i.disabled) || (e = e.type, i = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !i; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(P(231, t, typeof n)); return n } var pc = !1; if (cn) try { var _r = {}; Object.defineProperty(_r, "passive", { get: function () { pc = !0 } }), window.addEventListener("test", _r, _r), window.removeEventListener("test", _r, _r) } catch { pc = !1 } function ry(e, t, n, i, r, s, o, a, l) { var c = Array.prototype.slice.call(arguments, 3); try { t.apply(n, c) } catch (d) { this.onError(d) } } var Kr = !1, Yo = null, Xo = !1, gc = null, sy = { onError: function (e) { Kr = !0, Yo = e } }; function oy(e, t, n, i, r, s, o, a, l) { Kr = !1, Yo = null, ry.apply(sy, arguments) } function ay(e, t, n, i, r, s, o, a, l) { if (oy.apply(this, arguments), Kr) { if (Kr) { var c = Yo; Kr = !1, Yo = null } else throw Error(P(198)); Xo || (Xo = !0, gc = c) } } function bi(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Jg(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Of(e) { if (bi(e) !== e) throw Error(P(188)) } function ly(e) { var t = e.alternate; if (!t) { if (t = bi(e), t === null) throw Error(P(188)); return t !== e ? null : e } for (var n = e, i = t; ;) { var r = n.return; if (r === null) break; var s = r.alternate; if (s === null) { if (i = r.return, i !== null) { n = i; continue } break } if (r.child === s.child) { for (s = r.child; s;) { if (s === n) return Of(r), e; if (s === i) return Of(r), t; s = s.sibling } throw Error(P(188)) } if (n.return !== i.return) n = r, i = s; else { for (var o = !1, a = r.child; a;) { if (a === n) { o = !0, n = r, i = s; break } if (a === i) { o = !0, i = r, n = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === n) { o = !0, n = s, i = r; break } if (a === i) { o = !0, i = s, n = r; break } a = a.sibling } if (!o) throw Error(P(189)) } } if (n.alternate !== i) throw Error(P(190)) } if (n.tag !== 3) throw Error(P(188)); return n.stateNode.current === n ? e : t } function Zg(e) { return e = ly(e), e !== null ? e1(e) : null } function e1(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = e1(e); if (t !== null) return t; e = e.sibling } return null } var t1 = dt.unstable_scheduleCallback, Pf = dt.unstable_cancelCallback, cy = dt.unstable_shouldYield, uy = dt.unstable_requestPaint, _e = dt.unstable_now, dy = dt.unstable_getCurrentPriorityLevel, id = dt.unstable_ImmediatePriority, n1 = dt.unstable_UserBlockingPriority, Ko = dt.unstable_NormalPriority, fy = dt.unstable_LowPriority, i1 = dt.unstable_IdlePriority, Aa = null, Ut = null; function hy(e) { if (Ut && typeof Ut.onCommitFiberRoot == "function") try { Ut.onCommitFiberRoot(Aa, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Dt = Math.clz32 ? Math.clz32 : my, py = Math.log, gy = Math.LN2; function my(e) { return e >>>= 0, e === 0 ? 32 : 31 - (py(e) / gy | 0) | 0 } var Js = 64, Zs = 4194304; function Ar(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Go(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var i = 0, r = e.suspendedLanes, s = e.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~r; a !== 0 ? i = Ar(a) : (s &= o, s !== 0 && (i = Ar(s))) } else o = n & ~r, o !== 0 ? i = Ar(o) : s !== 0 && (i = Ar(s)); if (i === 0) return 0; if (t !== 0 && t !== i && !(t & r) && (r = i & -i, s = t & -t, r >= s || r === 16 && (s & 4194240) !== 0)) return t; if (i & 4 && (i |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= i; 0 < t;)n = 31 - Dt(t), r = 1 << n, i |= e[n], t &= ~r; return i } function yy(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function vy(e, t) { for (var n = e.suspendedLanes, i = e.pingedLanes, r = e.expirationTimes, s = e.pendingLanes; 0 < s;) { var o = 31 - Dt(s), a = 1 << o, l = r[o]; l === -1 ? (!(a & n) || a & i) && (r[o] = yy(a, t)) : l <= t && (e.expiredLanes |= a), s &= ~a } } function mc(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function r1() { var e = Js; return Js <<= 1, !(Js & 4194240) && (Js = 64), e } function gl(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Fs(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Dt(t), e[t] = n } function xy(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var i = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var r = 31 - Dt(n), s = 1 << r; t[r] = 0, i[r] = -1, e[r] = -1, n &= ~s } } function rd(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var i = 31 - Dt(n), r = 1 << i; r & t | e[i] & t && (e[i] |= t), n &= ~r } } var ne = 0; function s1(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var o1, sd, a1, l1, c1, yc = !1, eo = [], On = null, Pn = null, En = null, fs = new Map, hs = new Map, vn = [], by = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Ef(e, t) { switch (e) { case "focusin": case "focusout": On = null; break; case "dragenter": case "dragleave": Pn = null; break; case "mouseover": case "mouseout": En = null; break; case "pointerover": case "pointerout": fs.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": hs.delete(t.pointerId) } } function wr(e, t, n, i, r, s) { return e === null || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, t !== null && (t = Bs(t), t !== null && sd(t)), e) : (e.eventSystemFlags |= i, t = e.targetContainers, r !== null && t.indexOf(r) === -1 && t.push(r), e) } function _y(e, t, n, i, r) { switch (t) { case "focusin": return On = wr(On, e, t, n, i, r), !0; case "dragenter": return Pn = wr(Pn, e, t, n, i, r), !0; case "mouseover": return En = wr(En, e, t, n, i, r), !0; case "pointerover": var s = r.pointerId; return fs.set(s, wr(fs.get(s) || null, e, t, n, i, r)), !0; case "gotpointercapture": return s = r.pointerId, hs.set(s, wr(hs.get(s) || null, e, t, n, i, r)), !0 }return !1 } function u1(e) { var t = ii(e.target); if (t !== null) { var n = bi(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Jg(n), t !== null) { e.blockedOn = t, c1(e.priority, function () { a1(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Po(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = vc(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var i = new n.constructor(n.type, n); fc = i, n.target.dispatchEvent(i), fc = null } else return t = Bs(n), t !== null && sd(t), e.blockedOn = n, !1; t.shift() } return !0 } function Mf(e, t, n) { Po(e) && n.delete(t) } function wy() { yc = !1, On !== null && Po(On) && (On = null), Pn !== null && Po(Pn) && (Pn = null), En !== null && Po(En) && (En = null), fs.forEach(Mf), hs.forEach(Mf) } function jr(e, t) { e.blockedOn === t && (e.blockedOn = null, yc || (yc = !0, dt.unstable_scheduleCallback(dt.unstable_NormalPriority, wy))) } function ps(e) { function t(r) { return jr(r, e) } if (0 < eo.length) { jr(eo[0], e); for (var n = 1; n < eo.length; n++) { var i = eo[n]; i.blockedOn === e && (i.blockedOn = null) } } for (On !== null && jr(On, e), Pn !== null && jr(Pn, e), En !== null && jr(En, e), fs.forEach(t), hs.forEach(t), n = 0; n < vn.length; n++)i = vn[n], i.blockedOn === e && (i.blockedOn = null); for (; 0 < vn.length && (n = vn[0], n.blockedOn === null);)u1(n), n.blockedOn === null && vn.shift() } var Xi = hn.ReactCurrentBatchConfig, Qo = !0; function jy(e, t, n, i) { var r = ne, s = Xi.transition; Xi.transition = null; try { ne = 1, od(e, t, n, i) } finally { ne = r, Xi.transition = s } } function Sy(e, t, n, i) { var r = ne, s = Xi.transition; Xi.transition = null; try { ne = 4, od(e, t, n, i) } finally { ne = r, Xi.transition = s } } function od(e, t, n, i) { if (Qo) { var r = vc(e, t, n, i); if (r === null) kl(e, t, i, qo, n), Ef(e, i); else if (_y(r, e, t, n, i)) i.stopPropagation(); else if (Ef(e, i), t & 4 && -1 < by.indexOf(e)) { for (; r !== null;) { var s = Bs(r); if (s !== null && o1(s), s = vc(e, t, n, i), s === null && kl(e, t, i, qo, n), s === r) break; r = s } r !== null && i.stopPropagation() } else kl(e, t, i, null, n) } } var qo = null; function vc(e, t, n, i) { if (qo = null, e = nd(i), e = ii(e), e !== null) if (t = bi(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Jg(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return qo = e, null } function d1(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (dy()) { case id: return 1; case n1: return 4; case Ko: case fy: return 16; case i1: return 536870912; default: return 16 }default: return 16 } } var bn = null, ad = null, Eo = null; function f1() { if (Eo) return Eo; var e, t = ad, n = t.length, i, r = "value" in bn ? bn.value : bn.textContent, s = r.length; for (e = 0; e < n && t[e] === r[e]; e++); var o = n - e; for (i = 1; i <= o && t[n - i] === r[s - i]; i++); return Eo = r.slice(e, 1 < i ? 1 - i : void 0) } function Mo(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function to() { return !0 } function Df() { return !1 } function ht(e) { function t(n, i, r, s, o) { this._reactName = n, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? to : Df, this.isPropagationStopped = Df, this } return ye(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = to) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = to) }, persist: function () { }, isPersistent: to }), t } var ur = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, ld = ht(ur), $s = ye({}, ur, { view: 0, detail: 0 }), ky = ht($s), ml, yl, Sr, Ia = ye({}, $s, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: cd, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Sr && (Sr && e.type === "mousemove" ? (ml = e.screenX - Sr.screenX, yl = e.screenY - Sr.screenY) : yl = ml = 0, Sr = e), ml) }, movementY: function (e) { return "movementY" in e ? e.movementY : yl } }), Tf = ht(Ia), Cy = ye({}, Ia, { dataTransfer: 0 }), Oy = ht(Cy), Py = ye({}, $s, { relatedTarget: 0 }), vl = ht(Py), Ey = ye({}, ur, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), My = ht(Ey), Dy = ye({}, ur, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Ty = ht(Dy), Ny = ye({}, ur, { data: 0 }), Nf = ht(Ny), Ry = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, zy = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Ly = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Ay(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Ly[e]) ? !!t[e] : !1 } function cd() { return Ay } var Iy = ye({}, $s, { key: function (e) { if (e.key) { var t = Ry[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Mo(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? zy[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: cd, charCode: function (e) { return e.type === "keypress" ? Mo(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Mo(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Fy = ht(Iy), $y = ye({}, Ia, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Rf = ht($y), By = ye({}, $s, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: cd }), Wy = ht(By), Vy = ye({}, ur, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Uy = ht(Vy), Hy = ye({}, Ia, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Yy = ht(Hy), Xy = [9, 13, 27, 32], ud = cn && "CompositionEvent" in window, Gr = null; cn && "documentMode" in document && (Gr = document.documentMode); var Ky = cn && "TextEvent" in window && !Gr, h1 = cn && (!ud || Gr && 8 < Gr && 11 >= Gr), zf = " ", Lf = !1; function p1(e, t) { switch (e) { case "keyup": return Xy.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function g1(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Ri = !1; function Gy(e, t) { switch (e) { case "compositionend": return g1(t); case "keypress": return t.which !== 32 ? null : (Lf = !0, zf); case "textInput": return e = t.data, e === zf && Lf ? null : e; default: return null } } function Qy(e, t) { if (Ri) return e === "compositionend" || !ud && p1(e, t) ? (e = f1(), Eo = ad = bn = null, Ri = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return h1 && t.locale !== "ko" ? null : t.data; default: return null } } var qy = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Af(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!qy[e.type] : t === "textarea" } function m1(e, t, n, i) { Xg(i), t = Jo(t, "onChange"), 0 < t.length && (n = new ld("onChange", "change", null, n, i), e.push({ event: n, listeners: t })) } var Qr = null, gs = null; function Jy(e) { O1(e, 0) } function Fa(e) { var t = Ai(e); if ($g(t)) return e } function Zy(e, t) { if (e === "change") return t } var y1 = !1; if (cn) { var xl; if (cn) { var bl = "oninput" in document; if (!bl) { var If = document.createElement("div"); If.setAttribute("oninput", "return;"), bl = typeof If.oninput == "function" } xl = bl } else xl = !1; y1 = xl && (!document.documentMode || 9 < document.documentMode) } function Ff() { Qr && (Qr.detachEvent("onpropertychange", v1), gs = Qr = null) } function v1(e) { if (e.propertyName === "value" && Fa(gs)) { var t = []; m1(t, gs, e, nd(e)), qg(Jy, t) } } function ev(e, t, n) { e === "focusin" ? (Ff(), Qr = t, gs = n, Qr.attachEvent("onpropertychange", v1)) : e === "focusout" && Ff() } function tv(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Fa(gs) } function nv(e, t) { if (e === "click") return Fa(t) } function iv(e, t) { if (e === "input" || e === "change") return Fa(t) } function rv(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Rt = typeof Object.is == "function" ? Object.is : rv; function ms(e, t) { if (Rt(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), i = Object.keys(t); if (n.length !== i.length) return !1; for (i = 0; i < n.length; i++) { var r = n[i]; if (!ec.call(t, r) || !Rt(e[r], t[r])) return !1 } return !0 } function $f(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Bf(e, t) { var n = $f(e); e = 0; for (var i; n;) { if (n.nodeType === 3) { if (i = e + n.textContent.length, e <= t && i >= t) return { node: n, offset: t - e }; e = i } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = $f(n) } } function x1(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? x1(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function b1() { for (var e = window, t = Ho(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = Ho(e.document) } return t } function dd(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function sv(e) { var t = b1(), n = e.focusedElem, i = e.selectionRange; if (t !== n && n && n.ownerDocument && x1(n.ownerDocument.documentElement, n)) { if (i !== null && dd(n)) { if (t = i.start, e = i.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var r = n.textContent.length, s = Math.min(i.start, r); i = i.end === void 0 ? s : Math.min(i.end, r), !e.extend && s > i && (r = i, i = s, s = r), r = Bf(n, s); var o = Bf(n, i); r && o && (e.rangeCount !== 1 || e.anchorNode !== r.node || e.anchorOffset !== r.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(r.node, r.offset), e.removeAllRanges(), s > i ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var ov = cn && "documentMode" in document && 11 >= document.documentMode, zi = null, xc = null, qr = null, bc = !1; function Wf(e, t, n) { var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; bc || zi == null || zi !== Ho(i) || (i = zi, "selectionStart" in i && dd(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), qr && ms(qr, i) || (qr = i, i = Jo(xc, "onSelect"), 0 < i.length && (t = new ld("onSelect", "select", null, t, n), e.push({ event: t, listeners: i }), t.target = zi))) } function no(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Li = { animationend: no("Animation", "AnimationEnd"), animationiteration: no("Animation", "AnimationIteration"), animationstart: no("Animation", "AnimationStart"), transitionend: no("Transition", "TransitionEnd") }, _l = {}, _1 = {}; cn && (_1 = document.createElement("div").style, "AnimationEvent" in window || (delete Li.animationend.animation, delete Li.animationiteration.animation, delete Li.animationstart.animation), "TransitionEvent" in window || delete Li.transitionend.transition); function $a(e) { if (_l[e]) return _l[e]; if (!Li[e]) return e; var t = Li[e], n; for (n in t) if (t.hasOwnProperty(n) && n in _1) return _l[e] = t[n]; return e } var w1 = $a("animationend"), j1 = $a("animationiteration"), S1 = $a("animationstart"), k1 = $a("transitionend"), C1 = new Map, Vf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Bn(e, t) { C1.set(e, t), xi(t, [e]) } for (var wl = 0; wl < Vf.length; wl++) { var jl = Vf[wl], av = jl.toLowerCase(), lv = jl[0].toUpperCase() + jl.slice(1); Bn(av, "on" + lv) } Bn(w1, "onAnimationEnd"); Bn(j1, "onAnimationIteration"); Bn(S1, "onAnimationStart"); Bn("dblclick", "onDoubleClick"); Bn("focusin", "onFocus"); Bn("focusout", "onBlur"); Bn(k1, "onTransitionEnd"); Zi("onMouseEnter", ["mouseout", "mouseover"]); Zi("onMouseLeave", ["mouseout", "mouseover"]); Zi("onPointerEnter", ["pointerout", "pointerover"]); Zi("onPointerLeave", ["pointerout", "pointerover"]); xi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); xi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); xi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); xi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); xi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); xi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Ir = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), cv = new Set("cancel close invalid load scroll toggle".split(" ").concat(Ir)); function Uf(e, t, n) { var i = e.type || "unknown-event"; e.currentTarget = n, ay(i, t, void 0, e), e.currentTarget = null } function O1(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var i = e[n], r = i.event; i = i.listeners; e: { var s = void 0; if (t) for (var o = i.length - 1; 0 <= o; o--) { var a = i[o], l = a.instance, c = a.currentTarget; if (a = a.listener, l !== s && r.isPropagationStopped()) break e; Uf(r, a, c), s = l } else for (o = 0; o < i.length; o++) { if (a = i[o], l = a.instance, c = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e; Uf(r, a, c), s = l } } } if (Xo) throw e = gc, Xo = !1, gc = null, e } function le(e, t) { var n = t[kc]; n === void 0 && (n = t[kc] = new Set); var i = e + "__bubble"; n.has(i) || (P1(t, e, 2, !1), n.add(i)) } function Sl(e, t, n) { var i = 0; t && (i |= 4), P1(n, e, i, t) } var io = "_reactListening" + Math.random().toString(36).slice(2); function ys(e) { if (!e[io]) { e[io] = !0, zg.forEach(function (n) { n !== "selectionchange" && (cv.has(n) || Sl(n, !1, e), Sl(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[io] || (t[io] = !0, Sl("selectionchange", !1, t)) } } function P1(e, t, n, i) { switch (d1(t)) { case 1: var r = jy; break; case 4: r = Sy; break; default: r = od }n = r.bind(null, t, n, e), r = void 0, !pc || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (r = !0), i ? r !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: r }) : e.addEventListener(t, n, !0) : r !== void 0 ? e.addEventListener(t, n, { passive: r }) : e.addEventListener(t, n, !1) } function kl(e, t, n, i, r) { var s = i; if (!(t & 1) && !(t & 2) && i !== null) e: for (; ;) { if (i === null) return; var o = i.tag; if (o === 3 || o === 4) { var a = i.stateNode.containerInfo; if (a === r || a.nodeType === 8 && a.parentNode === r) break; if (o === 4) for (o = i.return; o !== null;) { var l = o.tag; if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return; o = o.return } for (; a !== null;) { if (o = ii(a), o === null) return; if (l = o.tag, l === 5 || l === 6) { i = s = o; continue e } a = a.parentNode } } i = i.return } qg(function () { var c = s, d = nd(n), f = []; e: { var h = C1.get(e); if (h !== void 0) { var p = ld, g = e; switch (e) { case "keypress": if (Mo(n) === 0) break e; case "keydown": case "keyup": p = Fy; break; case "focusin": g = "focus", p = vl; break; case "focusout": g = "blur", p = vl; break; case "beforeblur": case "afterblur": p = vl; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": p = Tf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": p = Oy; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": p = Wy; break; case w1: case j1: case S1: p = My; break; case k1: p = Uy; break; case "scroll": p = ky; break; case "wheel": p = Yy; break; case "copy": case "cut": case "paste": p = Ty; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": p = Rf }var v = (t & 4) !== 0, x = !v && e === "scroll", y = v ? h !== null ? h + "Capture" : null : h; v = []; for (var m = c, b; m !== null;) { b = m; var j = b.stateNode; if (b.tag === 5 && j !== null && (b = j, y !== null && (j = ds(m, y), j != null && v.push(vs(m, j, b)))), x) break; m = m.return } 0 < v.length && (h = new p(h, g, null, n, d), f.push({ event: h, listeners: v })) } } if (!(t & 7)) { e: { if (h = e === "mouseover" || e === "pointerover", p = e === "mouseout" || e === "pointerout", h && n !== fc && (g = n.relatedTarget || n.fromElement) && (ii(g) || g[un])) break e; if ((p || h) && (h = d.window === d ? d : (h = d.ownerDocument) ? h.defaultView || h.parentWindow : window, p ? (g = n.relatedTarget || n.toElement, p = c, g = g ? ii(g) : null, g !== null && (x = bi(g), g !== x || g.tag !== 5 && g.tag !== 6) && (g = null)) : (p = null, g = c), p !== g)) { if (v = Tf, j = "onMouseLeave", y = "onMouseEnter", m = "mouse", (e === "pointerout" || e === "pointerover") && (v = Rf, j = "onPointerLeave", y = "onPointerEnter", m = "pointer"), x = p == null ? h : Ai(p), b = g == null ? h : Ai(g), h = new v(j, m + "leave", p, n, d), h.target = x, h.relatedTarget = b, j = null, ii(d) === c && (v = new v(y, m + "enter", g, n, d), v.target = b, v.relatedTarget = x, j = v), x = j, p && g) t: { for (v = p, y = g, m = 0, b = v; b; b = wi(b))m++; for (b = 0, j = y; j; j = wi(j))b++; for (; 0 < m - b;)v = wi(v), m--; for (; 0 < b - m;)y = wi(y), b--; for (; m--;) { if (v === y || y !== null && v === y.alternate) break t; v = wi(v), y = wi(y) } v = null } else v = null; p !== null && Hf(f, h, p, v, !1), g !== null && x !== null && Hf(f, x, g, v, !0) } } e: { if (h = c ? Ai(c) : window, p = h.nodeName && h.nodeName.toLowerCase(), p === "select" || p === "input" && h.type === "file") var w = Zy; else if (Af(h)) if (y1) w = iv; else { w = tv; var k = ev } else (p = h.nodeName) && p.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (w = nv); if (w && (w = w(e, c))) { m1(f, w, n, d); break e } k && k(e, h, c), e === "focusout" && (k = h._wrapperState) && k.controlled && h.type === "number" && ac(h, "number", h.value) } switch (k = c ? Ai(c) : window, e) { case "focusin": (Af(k) || k.contentEditable === "true") && (zi = k, xc = c, qr = null); break; case "focusout": qr = xc = zi = null; break; case "mousedown": bc = !0; break; case "contextmenu": case "mouseup": case "dragend": bc = !1, Wf(f, n, d); break; case "selectionchange": if (ov) break; case "keydown": case "keyup": Wf(f, n, d) }var C; if (ud) e: { switch (e) { case "compositionstart": var O = "onCompositionStart"; break e; case "compositionend": O = "onCompositionEnd"; break e; case "compositionupdate": O = "onCompositionUpdate"; break e }O = void 0 } else Ri ? p1(e, n) && (O = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (O = "onCompositionStart"); O && (h1 && n.locale !== "ko" && (Ri || O !== "onCompositionStart" ? O === "onCompositionEnd" && Ri && (C = f1()) : (bn = d, ad = "value" in bn ? bn.value : bn.textContent, Ri = !0)), k = Jo(c, O), 0 < k.length && (O = new Nf(O, e, null, n, d), f.push({ event: O, listeners: k }), C ? O.data = C : (C = g1(n), C !== null && (O.data = C)))), (C = Ky ? Gy(e, n) : Qy(e, n)) && (c = Jo(c, "onBeforeInput"), 0 < c.length && (d = new Nf("onBeforeInput", "beforeinput", null, n, d), f.push({ event: d, listeners: c }), d.data = C)) } O1(f, t) }) } function vs(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Jo(e, t) { for (var n = t + "Capture", i = []; e !== null;) { var r = e, s = r.stateNode; r.tag === 5 && s !== null && (r = s, s = ds(e, n), s != null && i.unshift(vs(e, s, r)), s = ds(e, t), s != null && i.push(vs(e, s, r))), e = e.return } return i } function wi(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Hf(e, t, n, i, r) { for (var s = t._reactName, o = []; n !== null && n !== i;) { var a = n, l = a.alternate, c = a.stateNode; if (l !== null && l === i) break; a.tag === 5 && c !== null && (a = c, r ? (l = ds(n, s), l != null && o.unshift(vs(n, l, a))) : r || (l = ds(n, s), l != null && o.push(vs(n, l, a)))), n = n.return } o.length !== 0 && e.push({ event: t, listeners: o }) } var uv = /\r\n?/g, dv = /\u0000|\uFFFD/g; function Yf(e) {
    return (typeof e == "string" ? e : "" + e).replace(uv, `
`).replace(dv, "")
} function ro(e, t, n) { if (t = Yf(t), Yf(e) !== t && n) throw Error(P(425)) } function Zo() { } var _c = null, wc = null; function jc(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Sc = typeof setTimeout == "function" ? setTimeout : void 0, fv = typeof clearTimeout == "function" ? clearTimeout : void 0, Xf = typeof Promise == "function" ? Promise : void 0, hv = typeof queueMicrotask == "function" ? queueMicrotask : typeof Xf < "u" ? function (e) { return Xf.resolve(null).then(e).catch(pv) } : Sc; function pv(e) { setTimeout(function () { throw e }) } function Cl(e, t) { var n = t, i = 0; do { var r = n.nextSibling; if (e.removeChild(n), r && r.nodeType === 8) if (n = r.data, n === "/$") { if (i === 0) { e.removeChild(r), ps(t); return } i-- } else n !== "$" && n !== "$?" && n !== "$!" || i++; n = r } while (n); ps(t) } function Mn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Kf(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var dr = Math.random().toString(36).slice(2), Wt = "__reactFiber$" + dr, xs = "__reactProps$" + dr, un = "__reactContainer$" + dr, kc = "__reactEvents$" + dr, gv = "__reactListeners$" + dr, mv = "__reactHandles$" + dr; function ii(e) { var t = e[Wt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[un] || n[Wt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Kf(e); e !== null;) { if (n = e[Wt]) return n; e = Kf(e) } return t } e = n, n = e.parentNode } return null } function Bs(e) { return e = e[Wt] || e[un], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Ai(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(P(33)) } function Ba(e) { return e[xs] || null } var Cc = [], Ii = -1; function Wn(e) { return { current: e } } function ue(e) { 0 > Ii || (e.current = Cc[Ii], Cc[Ii] = null, Ii--) } function ae(e, t) { Ii++, Cc[Ii] = e.current, e.current = t } var In = {}, We = Wn(In), Je = Wn(!1), fi = In; function er(e, t) { var n = e.type.contextTypes; if (!n) return In; var i = e.stateNode; if (i && i.__reactInternalMemoizedUnmaskedChildContext === t) return i.__reactInternalMemoizedMaskedChildContext; var r = {}, s; for (s in n) r[s] = t[s]; return i && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = r), r } function Ze(e) { return e = e.childContextTypes, e != null } function ea() { ue(Je), ue(We) } function Gf(e, t, n) { if (We.current !== In) throw Error(P(168)); ae(We, t), ae(Je, n) } function E1(e, t, n) { var i = e.stateNode; if (t = t.childContextTypes, typeof i.getChildContext != "function") return n; i = i.getChildContext(); for (var r in i) if (!(r in t)) throw Error(P(108, ey(e) || "Unknown", r)); return ye({}, n, i) } function ta(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || In, fi = We.current, ae(We, e), ae(Je, Je.current), !0 } function Qf(e, t, n) { var i = e.stateNode; if (!i) throw Error(P(169)); n ? (e = E1(e, t, fi), i.__reactInternalMemoizedMergedChildContext = e, ue(Je), ue(We), ae(We, e)) : ue(Je), ae(Je, n) } var Zt = null, Wa = !1, Ol = !1; function M1(e) { Zt === null ? Zt = [e] : Zt.push(e) } function yv(e) { Wa = !0, M1(e) } function Vn() { if (!Ol && Zt !== null) { Ol = !0; var e = 0, t = ne; try { var n = Zt; for (ne = 1; e < n.length; e++) { var i = n[e]; do i = i(!0); while (i !== null) } Zt = null, Wa = !1 } catch (r) { throw Zt !== null && (Zt = Zt.slice(e + 1)), t1(id, Vn), r } finally { ne = t, Ol = !1 } } return null } var Fi = [], $i = 0, na = null, ia = 0, vt = [], xt = 0, hi = null, tn = 1, nn = ""; function qn(e, t) { Fi[$i++] = ia, Fi[$i++] = na, na = e, ia = t } function D1(e, t, n) { vt[xt++] = tn, vt[xt++] = nn, vt[xt++] = hi, hi = e; var i = tn; e = nn; var r = 32 - Dt(i) - 1; i &= ~(1 << r), n += 1; var s = 32 - Dt(t) + r; if (30 < s) { var o = r - r % 5; s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, tn = 1 << 32 - Dt(t) + r | n << r | i, nn = s + e } else tn = 1 << s | n << r | i, nn = e } function fd(e) { e.return !== null && (qn(e, 1), D1(e, 1, 0)) } function hd(e) { for (; e === na;)na = Fi[--$i], Fi[$i] = null, ia = Fi[--$i], Fi[$i] = null; for (; e === hi;)hi = vt[--xt], vt[xt] = null, nn = vt[--xt], vt[xt] = null, tn = vt[--xt], vt[xt] = null } var ut = null, ot = null, he = !1, Et = null; function T1(e, t) { var n = _t(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function qf(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, ut = e, ot = Mn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, ut = e, ot = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = hi !== null ? { id: tn, overflow: nn } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = _t(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, ut = e, ot = null, !0) : !1; default: return !1 } } function Oc(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Pc(e) { if (he) { var t = ot; if (t) { var n = t; if (!qf(e, t)) { if (Oc(e)) throw Error(P(418)); t = Mn(n.nextSibling); var i = ut; t && qf(e, t) ? T1(i, n) : (e.flags = e.flags & -4097 | 2, he = !1, ut = e) } } else { if (Oc(e)) throw Error(P(418)); e.flags = e.flags & -4097 | 2, he = !1, ut = e } } } function Jf(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; ut = e } function so(e) { if (e !== ut) return !1; if (!he) return Jf(e), he = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !jc(e.type, e.memoizedProps)), t && (t = ot)) { if (Oc(e)) throw N1(), Error(P(418)); for (; t;)T1(e, t), t = Mn(t.nextSibling) } if (Jf(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(P(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { ot = Mn(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } ot = null } } else ot = ut ? Mn(e.stateNode.nextSibling) : null; return !0 } function N1() { for (var e = ot; e;)e = Mn(e.nextSibling) } function tr() { ot = ut = null, he = !1 } function pd(e) { Et === null ? Et = [e] : Et.push(e) } var vv = hn.ReactCurrentBatchConfig; function Ot(e, t) { if (e && e.defaultProps) { t = ye({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } var ra = Wn(null), sa = null, Bi = null, gd = null; function md() { gd = Bi = sa = null } function yd(e) { var t = ra.current; ue(ra), e._currentValue = t } function Ec(e, t, n) { for (; e !== null;) { var i = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, i !== null && (i.childLanes |= t)) : i !== null && (i.childLanes & t) !== t && (i.childLanes |= t), e === n) break; e = e.return } } function Ki(e, t) { sa = e, gd = Bi = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (qe = !0), e.firstContext = null) } function St(e) { var t = e._currentValue; if (gd !== e) if (e = { context: e, memoizedValue: t, next: null }, Bi === null) { if (sa === null) throw Error(P(308)); Bi = e, sa.dependencies = { lanes: 0, firstContext: e } } else Bi = Bi.next = e; return t } var ri = null; function vd(e) { ri === null ? ri = [e] : ri.push(e) } function R1(e, t, n, i) { var r = t.interleaved; return r === null ? (n.next = n, vd(t)) : (n.next = r.next, r.next = n), t.interleaved = n, dn(e, i) } function dn(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var yn = !1; function xd(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function z1(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function ln(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Dn(e, t, n) { var i = e.updateQueue; if (i === null) return null; if (i = i.shared, K & 2) { var r = i.pending; return r === null ? t.next = t : (t.next = r.next, r.next = t), i.pending = t, dn(e, n) } return r = i.interleaved, r === null ? (t.next = t, vd(i)) : (t.next = r.next, r.next = t), i.interleaved = t, dn(e, n) } function Do(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var i = t.lanes; i &= e.pendingLanes, n |= i, t.lanes = n, rd(e, n) } } function Zf(e, t) { var n = e.updateQueue, i = e.alternate; if (i !== null && (i = i.updateQueue, n === i)) { var r = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? r = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? r = s = t : s = s.next = t } else r = s = t; n = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function oa(e, t, n, i) { var r = e.updateQueue; yn = !1; var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending; if (a !== null) { r.shared.pending = null; var l = a, c = l.next; l.next = null, o === null ? s = c : o.next = c, o = l; var d = e.alternate; d !== null && (d = d.updateQueue, a = d.lastBaseUpdate, a !== o && (a === null ? d.firstBaseUpdate = c : a.next = c, d.lastBaseUpdate = l)) } if (s !== null) { var f = r.baseState; o = 0, d = c = l = null, a = s; do { var h = a.lane, p = a.eventTime; if ((i & h) === h) { d !== null && (d = d.next = { eventTime: p, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var g = e, v = a; switch (h = t, p = n, v.tag) { case 1: if (g = v.payload, typeof g == "function") { f = g.call(p, f, h); break e } f = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = v.payload, h = typeof g == "function" ? g.call(p, f, h) : g, h == null) break e; f = ye({}, f, h); break e; case 2: yn = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, h = r.effects, h === null ? r.effects = [a] : h.push(a)) } else p = { eventTime: p, lane: h, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, d === null ? (c = d = p, l = f) : d = d.next = p, o |= h; if (a = a.next, a === null) { if (a = r.shared.pending, a === null) break; h = a, a = h.next, h.next = null, r.lastBaseUpdate = h, r.shared.pending = null } } while (!0); if (d === null && (l = f), r.baseState = l, r.firstBaseUpdate = c, r.lastBaseUpdate = d, t = r.shared.interleaved, t !== null) { r = t; do o |= r.lane, r = r.next; while (r !== t) } else s === null && (r.shared.lanes = 0); gi |= o, e.lanes = o, e.memoizedState = f } } function eh(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var i = e[t], r = i.callback; if (r !== null) { if (i.callback = null, i = n, typeof r != "function") throw Error(P(191, r)); r.call(i) } } } var L1 = new Rg.Component().refs; function Mc(e, t, n, i) { t = e.memoizedState, n = n(i, t), n = n == null ? t : ye({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var Va = { isMounted: function (e) { return (e = e._reactInternals) ? bi(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var i = He(), r = Nn(e), s = ln(i, r); s.payload = t, n != null && (s.callback = n), t = Dn(e, s, r), t !== null && (Tt(t, e, r, i), Do(t, e, r)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var i = He(), r = Nn(e), s = ln(i, r); s.tag = 1, s.payload = t, n != null && (s.callback = n), t = Dn(e, s, r), t !== null && (Tt(t, e, r, i), Do(t, e, r)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = He(), i = Nn(e), r = ln(n, i); r.tag = 2, t != null && (r.callback = t), t = Dn(e, r, i), t !== null && (Tt(t, e, i, n), Do(t, e, i)) } }; function th(e, t, n, i, r, s, o) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(i, s, o) : t.prototype && t.prototype.isPureReactComponent ? !ms(n, i) || !ms(r, s) : !0 } function A1(e, t, n) { var i = !1, r = In, s = t.contextType; return typeof s == "object" && s !== null ? s = St(s) : (r = Ze(t) ? fi : We.current, i = t.contextTypes, s = (i = i != null) ? er(e, r) : In), t = new t(n, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Va, e.stateNode = t, t._reactInternals = e, i && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = r, e.__reactInternalMemoizedMaskedChildContext = s), t } function nh(e, t, n, i) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, i), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, i), t.state !== e && Va.enqueueReplaceState(t, t.state, null) } function Dc(e, t, n, i) { var r = e.stateNode; r.props = n, r.state = e.memoizedState, r.refs = L1, xd(e); var s = t.contextType; typeof s == "object" && s !== null ? r.context = St(s) : (s = Ze(t) ? fi : We.current, r.context = er(e, s)), r.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (Mc(e, t, s, n), r.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (t = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), t !== r.state && Va.enqueueReplaceState(r, r.state, null), oa(e, n, r, i), r.state = e.memoizedState), typeof r.componentDidMount == "function" && (e.flags |= 4194308) } function kr(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(P(309)); var i = n.stateNode } if (!i) throw Error(P(147, e)); var r = i, s = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function (o) { var a = r.refs; a === L1 && (a = r.refs = {}), o === null ? delete a[s] : a[s] = o }, t._stringRef = s, t) } if (typeof e != "string") throw Error(P(284)); if (!n._owner) throw Error(P(290, e)) } return e } function oo(e, t) { throw e = Object.prototype.toString.call(t), Error(P(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function ih(e) { var t = e._init; return t(e._payload) } function I1(e) { function t(y, m) { if (e) { var b = y.deletions; b === null ? (y.deletions = [m], y.flags |= 16) : b.push(m) } } function n(y, m) { if (!e) return null; for (; m !== null;)t(y, m), m = m.sibling; return null } function i(y, m) { for (y = new Map; m !== null;)m.key !== null ? y.set(m.key, m) : y.set(m.index, m), m = m.sibling; return y } function r(y, m) { return y = Rn(y, m), y.index = 0, y.sibling = null, y } function s(y, m, b) { return y.index = b, e ? (b = y.alternate, b !== null ? (b = b.index, b < m ? (y.flags |= 2, m) : b) : (y.flags |= 2, m)) : (y.flags |= 1048576, m) } function o(y) { return e && y.alternate === null && (y.flags |= 2), y } function a(y, m, b, j) { return m === null || m.tag !== 6 ? (m = Rl(b, y.mode, j), m.return = y, m) : (m = r(m, b), m.return = y, m) } function l(y, m, b, j) { var w = b.type; return w === Ni ? d(y, m, b.props.children, j, b.key) : m !== null && (m.elementType === w || typeof w == "object" && w !== null && w.$$typeof === mn && ih(w) === m.type) ? (j = r(m, b.props), j.ref = kr(y, m, b), j.return = y, j) : (j = Ao(b.type, b.key, b.props, null, y.mode, j), j.ref = kr(y, m, b), j.return = y, j) } function c(y, m, b, j) { return m === null || m.tag !== 4 || m.stateNode.containerInfo !== b.containerInfo || m.stateNode.implementation !== b.implementation ? (m = zl(b, y.mode, j), m.return = y, m) : (m = r(m, b.children || []), m.return = y, m) } function d(y, m, b, j, w) { return m === null || m.tag !== 7 ? (m = ci(b, y.mode, j, w), m.return = y, m) : (m = r(m, b), m.return = y, m) } function f(y, m, b) { if (typeof m == "string" && m !== "" || typeof m == "number") return m = Rl("" + m, y.mode, b), m.return = y, m; if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case Gs: return b = Ao(m.type, m.key, m.props, null, y.mode, b), b.ref = kr(y, null, m), b.return = y, b; case Ti: return m = zl(m, y.mode, b), m.return = y, m; case mn: var j = m._init; return f(y, j(m._payload), b) }if (Lr(m) || br(m)) return m = ci(m, y.mode, b, null), m.return = y, m; oo(y, m) } return null } function h(y, m, b, j) { var w = m !== null ? m.key : null; if (typeof b == "string" && b !== "" || typeof b == "number") return w !== null ? null : a(y, m, "" + b, j); if (typeof b == "object" && b !== null) { switch (b.$$typeof) { case Gs: return b.key === w ? l(y, m, b, j) : null; case Ti: return b.key === w ? c(y, m, b, j) : null; case mn: return w = b._init, h(y, m, w(b._payload), j) }if (Lr(b) || br(b)) return w !== null ? null : d(y, m, b, j, null); oo(y, b) } return null } function p(y, m, b, j, w) { if (typeof j == "string" && j !== "" || typeof j == "number") return y = y.get(b) || null, a(m, y, "" + j, w); if (typeof j == "object" && j !== null) { switch (j.$$typeof) { case Gs: return y = y.get(j.key === null ? b : j.key) || null, l(m, y, j, w); case Ti: return y = y.get(j.key === null ? b : j.key) || null, c(m, y, j, w); case mn: var k = j._init; return p(y, m, b, k(j._payload), w) }if (Lr(j) || br(j)) return y = y.get(b) || null, d(m, y, j, w, null); oo(m, j) } return null } function g(y, m, b, j) { for (var w = null, k = null, C = m, O = m = 0, D = null; C !== null && O < b.length; O++) { C.index > O ? (D = C, C = null) : D = C.sibling; var T = h(y, C, b[O], j); if (T === null) { C === null && (C = D); break } e && C && T.alternate === null && t(y, C), m = s(T, m, O), k === null ? w = T : k.sibling = T, k = T, C = D } if (O === b.length) return n(y, C), he && qn(y, O), w; if (C === null) { for (; O < b.length; O++)C = f(y, b[O], j), C !== null && (m = s(C, m, O), k === null ? w = C : k.sibling = C, k = C); return he && qn(y, O), w } for (C = i(y, C); O < b.length; O++)D = p(C, y, O, b[O], j), D !== null && (e && D.alternate !== null && C.delete(D.key === null ? O : D.key), m = s(D, m, O), k === null ? w = D : k.sibling = D, k = D); return e && C.forEach(function (A) { return t(y, A) }), he && qn(y, O), w } function v(y, m, b, j) { var w = br(b); if (typeof w != "function") throw Error(P(150)); if (b = w.call(b), b == null) throw Error(P(151)); for (var k = w = null, C = m, O = m = 0, D = null, T = b.next(); C !== null && !T.done; O++, T = b.next()) { C.index > O ? (D = C, C = null) : D = C.sibling; var A = h(y, C, T.value, j); if (A === null) { C === null && (C = D); break } e && C && A.alternate === null && t(y, C), m = s(A, m, O), k === null ? w = A : k.sibling = A, k = A, C = D } if (T.done) return n(y, C), he && qn(y, O), w; if (C === null) { for (; !T.done; O++, T = b.next())T = f(y, T.value, j), T !== null && (m = s(T, m, O), k === null ? w = T : k.sibling = T, k = T); return he && qn(y, O), w } for (C = i(y, C); !T.done; O++, T = b.next())T = p(C, y, O, T.value, j), T !== null && (e && T.alternate !== null && C.delete(T.key === null ? O : T.key), m = s(T, m, O), k === null ? w = T : k.sibling = T, k = T); return e && C.forEach(function ($) { return t(y, $) }), he && qn(y, O), w } function x(y, m, b, j) { if (typeof b == "object" && b !== null && b.type === Ni && b.key === null && (b = b.props.children), typeof b == "object" && b !== null) { switch (b.$$typeof) { case Gs: e: { for (var w = b.key, k = m; k !== null;) { if (k.key === w) { if (w = b.type, w === Ni) { if (k.tag === 7) { n(y, k.sibling), m = r(k, b.props.children), m.return = y, y = m; break e } } else if (k.elementType === w || typeof w == "object" && w !== null && w.$$typeof === mn && ih(w) === k.type) { n(y, k.sibling), m = r(k, b.props), m.ref = kr(y, k, b), m.return = y, y = m; break e } n(y, k); break } else t(y, k); k = k.sibling } b.type === Ni ? (m = ci(b.props.children, y.mode, j, b.key), m.return = y, y = m) : (j = Ao(b.type, b.key, b.props, null, y.mode, j), j.ref = kr(y, m, b), j.return = y, y = j) } return o(y); case Ti: e: { for (k = b.key; m !== null;) { if (m.key === k) if (m.tag === 4 && m.stateNode.containerInfo === b.containerInfo && m.stateNode.implementation === b.implementation) { n(y, m.sibling), m = r(m, b.children || []), m.return = y, y = m; break e } else { n(y, m); break } else t(y, m); m = m.sibling } m = zl(b, y.mode, j), m.return = y, y = m } return o(y); case mn: return k = b._init, x(y, m, k(b._payload), j) }if (Lr(b)) return g(y, m, b, j); if (br(b)) return v(y, m, b, j); oo(y, b) } return typeof b == "string" && b !== "" || typeof b == "number" ? (b = "" + b, m !== null && m.tag === 6 ? (n(y, m.sibling), m = r(m, b), m.return = y, y = m) : (n(y, m), m = Rl(b, y.mode, j), m.return = y, y = m), o(y)) : n(y, m) } return x } var nr = I1(!0), F1 = I1(!1), Ws = {}, Ht = Wn(Ws), bs = Wn(Ws), _s = Wn(Ws); function si(e) { if (e === Ws) throw Error(P(174)); return e } function bd(e, t) { switch (ae(_s, t), ae(bs, e), ae(Ht, Ws), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : cc(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = cc(t, e) }ue(Ht), ae(Ht, t) } function ir() { ue(Ht), ue(bs), ue(_s) } function $1(e) { si(_s.current); var t = si(Ht.current), n = cc(t, e.type); t !== n && (ae(bs, e), ae(Ht, n)) } function _d(e) { bs.current === e && (ue(Ht), ue(bs)) } var ge = Wn(0); function aa(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Pl = []; function wd() { for (var e = 0; e < Pl.length; e++)Pl[e]._workInProgressVersionPrimary = null; Pl.length = 0 } var To = hn.ReactCurrentDispatcher, El = hn.ReactCurrentBatchConfig, pi = 0, me = null, Ce = null, Me = null, la = !1, Jr = !1, ws = 0, xv = 0; function Ae() { throw Error(P(321)) } function jd(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!Rt(e[n], t[n])) return !1; return !0 } function Sd(e, t, n, i, r, s) { if (pi = s, me = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, To.current = e === null || e.memoizedState === null ? jv : Sv, e = n(i, r), Jr) { s = 0; do { if (Jr = !1, ws = 0, 25 <= s) throw Error(P(301)); s += 1, Me = Ce = null, t.updateQueue = null, To.current = kv, e = n(i, r) } while (Jr) } if (To.current = ca, t = Ce !== null && Ce.next !== null, pi = 0, Me = Ce = me = null, la = !1, t) throw Error(P(300)); return e } function kd() { var e = ws !== 0; return ws = 0, e } function Ft() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Me === null ? me.memoizedState = Me = e : Me = Me.next = e, Me } function kt() { if (Ce === null) { var e = me.alternate; e = e !== null ? e.memoizedState : null } else e = Ce.next; var t = Me === null ? me.memoizedState : Me.next; if (t !== null) Me = t, Ce = e; else { if (e === null) throw Error(P(310)); Ce = e, e = { memoizedState: Ce.memoizedState, baseState: Ce.baseState, baseQueue: Ce.baseQueue, queue: Ce.queue, next: null }, Me === null ? me.memoizedState = Me = e : Me = Me.next = e } return Me } function js(e, t) { return typeof t == "function" ? t(e) : t } function Ml(e) { var t = kt(), n = t.queue; if (n === null) throw Error(P(311)); n.lastRenderedReducer = e; var i = Ce, r = i.baseQueue, s = n.pending; if (s !== null) { if (r !== null) { var o = r.next; r.next = s.next, s.next = o } i.baseQueue = r = s, n.pending = null } if (r !== null) { s = r.next, i = i.baseState; var a = o = null, l = null, c = s; do { var d = c.lane; if ((pi & d) === d) l !== null && (l = l.next = { lane: 0, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }), i = c.hasEagerState ? c.eagerState : e(i, c.action); else { var f = { lane: d, action: c.action, hasEagerState: c.hasEagerState, eagerState: c.eagerState, next: null }; l === null ? (a = l = f, o = i) : l = l.next = f, me.lanes |= d, gi |= d } c = c.next } while (c !== null && c !== s); l === null ? o = i : l.next = a, Rt(i, t.memoizedState) || (qe = !0), t.memoizedState = i, t.baseState = o, t.baseQueue = l, n.lastRenderedState = i } if (e = n.interleaved, e !== null) { r = e; do s = r.lane, me.lanes |= s, gi |= s, r = r.next; while (r !== e) } else r === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Dl(e) { var t = kt(), n = t.queue; if (n === null) throw Error(P(311)); n.lastRenderedReducer = e; var i = n.dispatch, r = n.pending, s = t.memoizedState; if (r !== null) { n.pending = null; var o = r = r.next; do s = e(s, o.action), o = o.next; while (o !== r); Rt(s, t.memoizedState) || (qe = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), n.lastRenderedState = s } return [s, i] } function B1() { } function W1(e, t) { var n = me, i = kt(), r = t(), s = !Rt(i.memoizedState, r); if (s && (i.memoizedState = r, qe = !0), i = i.queue, Cd(H1.bind(null, n, i, e), [e]), i.getSnapshot !== t || s || Me !== null && Me.memoizedState.tag & 1) { if (n.flags |= 2048, Ss(9, U1.bind(null, n, i, r, t), void 0, null), Te === null) throw Error(P(349)); pi & 30 || V1(n, t, r) } return r } function V1(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = me.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, me.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function U1(e, t, n, i) { t.value = n, t.getSnapshot = i, Y1(t) && X1(e) } function H1(e, t, n) { return n(function () { Y1(t) && X1(e) }) } function Y1(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Rt(e, n) } catch { return !0 } } function X1(e) { var t = dn(e, 1); t !== null && Tt(t, e, 1, -1) } function rh(e) { var t = Ft(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: js, lastRenderedState: e }, t.queue = e, e = e.dispatch = wv.bind(null, me, e), [t.memoizedState, e] } function Ss(e, t, n, i) { return e = { tag: e, create: t, destroy: n, deps: i, next: null }, t = me.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, me.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (i = n.next, n.next = e, e.next = i, t.lastEffect = e)), e } function K1() { return kt().memoizedState } function No(e, t, n, i) { var r = Ft(); me.flags |= e, r.memoizedState = Ss(1 | t, n, void 0, i === void 0 ? null : i) } function Ua(e, t, n, i) { var r = kt(); i = i === void 0 ? null : i; var s = void 0; if (Ce !== null) { var o = Ce.memoizedState; if (s = o.destroy, i !== null && jd(i, o.deps)) { r.memoizedState = Ss(t, n, s, i); return } } me.flags |= e, r.memoizedState = Ss(1 | t, n, s, i) } function sh(e, t) { return No(8390656, 8, e, t) } function Cd(e, t) { return Ua(2048, 8, e, t) } function G1(e, t) { return Ua(4, 2, e, t) } function Q1(e, t) { return Ua(4, 4, e, t) } function q1(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function J1(e, t, n) { return n = n != null ? n.concat([e]) : null, Ua(4, 4, q1.bind(null, t, e), n) } function Od() { } function Z1(e, t) { var n = kt(); t = t === void 0 ? null : t; var i = n.memoizedState; return i !== null && t !== null && jd(t, i[1]) ? i[0] : (n.memoizedState = [e, t], e) } function em(e, t) { var n = kt(); t = t === void 0 ? null : t; var i = n.memoizedState; return i !== null && t !== null && jd(t, i[1]) ? i[0] : (e = e(), n.memoizedState = [e, t], e) } function tm(e, t, n) { return pi & 21 ? (Rt(n, t) || (n = r1(), me.lanes |= n, gi |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, qe = !0), e.memoizedState = n) } function bv(e, t) { var n = ne; ne = n !== 0 && 4 > n ? n : 4, e(!0); var i = El.transition; El.transition = {}; try { e(!1), t() } finally { ne = n, El.transition = i } } function nm() { return kt().memoizedState } function _v(e, t, n) { var i = Nn(e); if (n = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }, im(e)) rm(t, n); else if (n = R1(e, t, n, i), n !== null) { var r = He(); Tt(n, e, i, r), sm(n, t, i) } } function wv(e, t, n) { var i = Nn(e), r = { lane: i, action: n, hasEagerState: !1, eagerState: null, next: null }; if (im(e)) rm(t, r); else { var s = e.alternate; if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try { var o = t.lastRenderedState, a = s(o, n); if (r.hasEagerState = !0, r.eagerState = a, Rt(a, o)) { var l = t.interleaved; l === null ? (r.next = r, vd(t)) : (r.next = l.next, l.next = r), t.interleaved = r; return } } catch { } finally { } n = R1(e, t, r, i), n !== null && (r = He(), Tt(n, e, i, r), sm(n, t, i)) } } function im(e) { var t = e.alternate; return e === me || t !== null && t === me } function rm(e, t) { Jr = la = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function sm(e, t, n) { if (n & 4194240) { var i = t.lanes; i &= e.pendingLanes, n |= i, t.lanes = n, rd(e, n) } } var ca = { readContext: St, useCallback: Ae, useContext: Ae, useEffect: Ae, useImperativeHandle: Ae, useInsertionEffect: Ae, useLayoutEffect: Ae, useMemo: Ae, useReducer: Ae, useRef: Ae, useState: Ae, useDebugValue: Ae, useDeferredValue: Ae, useTransition: Ae, useMutableSource: Ae, useSyncExternalStore: Ae, useId: Ae, unstable_isNewReconciler: !1 }, jv = { readContext: St, useCallback: function (e, t) { return Ft().memoizedState = [e, t === void 0 ? null : t], e }, useContext: St, useEffect: sh, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, No(4194308, 4, q1.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return No(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return No(4, 2, e, t) }, useMemo: function (e, t) { var n = Ft(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var i = Ft(); return t = n !== void 0 ? n(t) : t, i.memoizedState = i.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, i.queue = e, e = e.dispatch = _v.bind(null, me, e), [i.memoizedState, e] }, useRef: function (e) { var t = Ft(); return e = { current: e }, t.memoizedState = e }, useState: rh, useDebugValue: Od, useDeferredValue: function (e) { return Ft().memoizedState = e }, useTransition: function () { var e = rh(!1), t = e[0]; return e = bv.bind(null, e[1]), Ft().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var i = me, r = Ft(); if (he) { if (n === void 0) throw Error(P(407)); n = n() } else { if (n = t(), Te === null) throw Error(P(349)); pi & 30 || V1(i, t, n) } r.memoizedState = n; var s = { value: n, getSnapshot: t }; return r.queue = s, sh(H1.bind(null, i, s, e), [e]), i.flags |= 2048, Ss(9, U1.bind(null, i, s, n, t), void 0, null), n }, useId: function () { var e = Ft(), t = Te.identifierPrefix; if (he) { var n = nn, i = tn; n = (i & ~(1 << 32 - Dt(i) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = ws++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = xv++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Sv = { readContext: St, useCallback: Z1, useContext: St, useEffect: Cd, useImperativeHandle: J1, useInsertionEffect: G1, useLayoutEffect: Q1, useMemo: em, useReducer: Ml, useRef: K1, useState: function () { return Ml(js) }, useDebugValue: Od, useDeferredValue: function (e) { var t = kt(); return tm(t, Ce.memoizedState, e) }, useTransition: function () { var e = Ml(js)[0], t = kt().memoizedState; return [e, t] }, useMutableSource: B1, useSyncExternalStore: W1, useId: nm, unstable_isNewReconciler: !1 }, kv = { readContext: St, useCallback: Z1, useContext: St, useEffect: Cd, useImperativeHandle: J1, useInsertionEffect: G1, useLayoutEffect: Q1, useMemo: em, useReducer: Dl, useRef: K1, useState: function () { return Dl(js) }, useDebugValue: Od, useDeferredValue: function (e) { var t = kt(); return Ce === null ? t.memoizedState = e : tm(t, Ce.memoizedState, e) }, useTransition: function () { var e = Dl(js)[0], t = kt().memoizedState; return [e, t] }, useMutableSource: B1, useSyncExternalStore: W1, useId: nm, unstable_isNewReconciler: !1 }; function rr(e, t) {
    try { var n = "", i = t; do n += Z2(i), i = i.return; while (i); var r = n } catch (s) {
        r = `
Error generating stack: `+ s.message + `
`+ s.stack
    } return { value: e, source: t, stack: r, digest: null }
} function Tl(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function Tc(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var Cv = typeof WeakMap == "function" ? WeakMap : Map; function om(e, t, n) { n = ln(-1, n), n.tag = 3, n.payload = { element: null }; var i = t.value; return n.callback = function () { da || (da = !0, Wc = i), Tc(e, t) }, n } function am(e, t, n) { n = ln(-1, n), n.tag = 3; var i = e.type.getDerivedStateFromError; if (typeof i == "function") { var r = t.value; n.payload = function () { return i(r) }, n.callback = function () { Tc(e, t) } } var s = e.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { Tc(e, t), typeof i != "function" && (Tn === null ? Tn = new Set([this]) : Tn.add(this)); var o = t.stack; this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" }) }), n } function oh(e, t, n) { var i = e.pingCache; if (i === null) { i = e.pingCache = new Cv; var r = new Set; i.set(t, r) } else r = i.get(t), r === void 0 && (r = new Set, i.set(t, r)); r.has(n) || (r.add(n), e = $v.bind(null, e, t, n), t.then(e, e)) } function ah(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function lh(e, t, n, i, r) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = r, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = ln(-1, 1), t.tag = 2, Dn(n, t, 1))), n.lanes |= 1), e) } var Ov = hn.ReactCurrentOwner, qe = !1; function Ue(e, t, n, i) { t.child = e === null ? F1(t, null, n, i) : nr(t, e.child, n, i) } function ch(e, t, n, i, r) { n = n.render; var s = t.ref; return Ki(t, r), i = Sd(e, t, n, i, s, r), n = kd(), e !== null && !qe ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~r, fn(e, t, r)) : (he && n && fd(t), t.flags |= 1, Ue(e, t, i, r), t.child) } function uh(e, t, n, i, r) { if (e === null) { var s = n.type; return typeof s == "function" && !zd(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = s, lm(e, t, s, i, r)) : (e = Ao(n.type, null, i, t, t.mode, r), e.ref = t.ref, e.return = t, t.child = e) } if (s = e.child, !(e.lanes & r)) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : ms, n(o, i) && e.ref === t.ref) return fn(e, t, r) } return t.flags |= 1, e = Rn(s, i), e.ref = t.ref, e.return = t, t.child = e } function lm(e, t, n, i, r) { if (e !== null) { var s = e.memoizedProps; if (ms(s, i) && e.ref === t.ref) if (qe = !1, t.pendingProps = i = s, (e.lanes & r) !== 0) e.flags & 131072 && (qe = !0); else return t.lanes = e.lanes, fn(e, t, r) } return Nc(e, t, n, i, r) } function cm(e, t, n) { var i = t.pendingProps, r = i.children, s = e !== null ? e.memoizedState : null; if (i.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, ae(Vi, it), it |= n; else { if (!(n & 1073741824)) return e = s !== null ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, ae(Vi, it), it |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : n, ae(Vi, it), it |= i } else s !== null ? (i = s.baseLanes | n, t.memoizedState = null) : i = n, ae(Vi, it), it |= i; return Ue(e, t, r, n), t.child } function um(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Nc(e, t, n, i, r) { var s = Ze(n) ? fi : We.current; return s = er(t, s), Ki(t, r), n = Sd(e, t, n, i, s, r), i = kd(), e !== null && !qe ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~r, fn(e, t, r)) : (he && i && fd(t), t.flags |= 1, Ue(e, t, n, r), t.child) } function dh(e, t, n, i, r) { if (Ze(n)) { var s = !0; ta(t) } else s = !1; if (Ki(t, r), t.stateNode === null) Ro(e, t), A1(t, n, i), Dc(t, n, i, r), i = !0; else if (e === null) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var l = o.context, c = n.contextType; typeof c == "object" && c !== null ? c = St(c) : (c = Ze(n) ? fi : We.current, c = er(t, c)); var d = n.getDerivedStateFromProps, f = typeof d == "function" || typeof o.getSnapshotBeforeUpdate == "function"; f || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== c) && nh(t, o, i, c), yn = !1; var h = t.memoizedState; o.state = h, oa(t, i, o, r), l = t.memoizedState, a !== i || h !== l || Je.current || yn ? (typeof d == "function" && (Mc(t, n, d, i), l = t.memoizedState), (a = yn || th(t, n, a, i, h, l, c)) ? (f || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = i, t.memoizedState = l), o.props = i, o.state = l, o.context = c, i = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), i = !1) } else { o = t.stateNode, z1(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : Ot(t.type, a), o.props = c, f = t.pendingProps, h = o.context, l = n.contextType, typeof l == "object" && l !== null ? l = St(l) : (l = Ze(n) ? fi : We.current, l = er(t, l)); var p = n.getDerivedStateFromProps; (d = typeof p == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== f || h !== l) && nh(t, o, i, l), yn = !1, h = t.memoizedState, o.state = h, oa(t, i, o, r); var g = t.memoizedState; a !== f || h !== g || Je.current || yn ? (typeof p == "function" && (Mc(t, n, p, i), g = t.memoizedState), (c = yn || th(t, n, c, i, h, g, l) || !1) ? (d || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, g, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, g, l)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = i, t.memoizedState = g), o.props = i, o.state = g, o.context = l, i = c) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), i = !1) } return Rc(e, t, n, i, s, r) } function Rc(e, t, n, i, r, s) { um(e, t); var o = (t.flags & 128) !== 0; if (!i && !o) return r && Qf(t, n, !1), fn(e, t, s); i = t.stateNode, Ov.current = t; var a = o && typeof n.getDerivedStateFromError != "function" ? null : i.render(); return t.flags |= 1, e !== null && o ? (t.child = nr(t, e.child, null, s), t.child = nr(t, null, a, s)) : Ue(e, t, a, s), t.memoizedState = i.state, r && Qf(t, n, !0), t.child } function dm(e) { var t = e.stateNode; t.pendingContext ? Gf(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Gf(e, t.context, !1), bd(e, t.containerInfo) } function fh(e, t, n, i, r) { return tr(), pd(r), t.flags |= 256, Ue(e, t, n, i), t.child } var zc = { dehydrated: null, treeContext: null, retryLane: 0 }; function Lc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function fm(e, t, n) { var i = t.pendingProps, r = ge.current, s = !1, o = (t.flags & 128) !== 0, a; if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (r & 2) !== 0), a ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (r |= 1), ae(ge, r & 1), e === null) return Pc(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Xa(o, i, 0, null), e = ci(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Lc(n), t.memoizedState = zc, e) : Pd(t, o)); if (r = e.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return Pv(e, t, o, i, a, r, n); if (s) { s = i.fallback, o = t.mode, r = e.child, a = r.sibling; var l = { mode: "hidden", children: i.children }; return !(o & 1) && t.child !== r ? (i = t.child, i.childLanes = 0, i.pendingProps = l, t.deletions = null) : (i = Rn(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = Rn(a, s) : (s = ci(s, o, n, null), s.flags |= 2), s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, o = e.child.memoizedState, o = o === null ? Lc(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = e.childLanes & ~n, t.memoizedState = zc, i } return s = e.child, e = s.sibling, i = Rn(s, { mode: "visible", children: i.children }), !(t.mode & 1) && (i.lanes = n), i.return = t, i.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i } function Pd(e, t) { return t = Xa({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function ao(e, t, n, i) { return i !== null && pd(i), nr(t, e.child, null, n), e = Pd(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function Pv(e, t, n, i, r, s, o) { if (n) return t.flags & 256 ? (t.flags &= -257, i = Tl(Error(P(422))), ao(e, t, o, i)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = i.fallback, r = t.mode, i = Xa({ mode: "visible", children: i.children }, r, 0, null), s = ci(s, r, o, null), s.flags |= 2, i.return = t, s.return = t, i.sibling = s, t.child = i, t.mode & 1 && nr(t, e.child, null, o), t.child.memoizedState = Lc(o), t.memoizedState = zc, s); if (!(t.mode & 1)) return ao(e, t, o, null); if (r.data === "$!") { if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst; return i = a, s = Error(P(419)), i = Tl(s, i, void 0), ao(e, t, o, i) } if (a = (o & e.childLanes) !== 0, qe || a) { if (i = Te, i !== null) { switch (o & -o) { case 4: r = 2; break; case 16: r = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: r = 32; break; case 536870912: r = 268435456; break; default: r = 0 }r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, dn(e, r), Tt(i, e, r, -1)) } return Rd(), i = Tl(Error(P(421))), ao(e, t, o, i) } return r.data === "$?" ? (t.flags |= 128, t.child = e.child, t = Bv.bind(null, e), r._reactRetry = t, null) : (e = s.treeContext, ot = Mn(r.nextSibling), ut = t, he = !0, Et = null, e !== null && (vt[xt++] = tn, vt[xt++] = nn, vt[xt++] = hi, tn = e.id, nn = e.overflow, hi = t), t = Pd(t, i.children), t.flags |= 4096, t) } function hh(e, t, n) { e.lanes |= t; var i = e.alternate; i !== null && (i.lanes |= t), Ec(e.return, t, n) } function Nl(e, t, n, i, r) { var s = e.memoizedState; s === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: i, tail: n, tailMode: r } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = n, s.tailMode = r) } function hm(e, t, n) { var i = t.pendingProps, r = i.revealOrder, s = i.tail; if (Ue(e, t, i.children, n), i = ge.current, i & 2) i = i & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && hh(e, n, t); else if (e.tag === 19) hh(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } i &= 1 } if (ae(ge, i), !(t.mode & 1)) t.memoizedState = null; else switch (r) { case "forwards": for (n = t.child, r = null; n !== null;)e = n.alternate, e !== null && aa(e) === null && (r = n), n = n.sibling; n = r, n === null ? (r = t.child, t.child = null) : (r = n.sibling, n.sibling = null), Nl(t, !1, r, n, s); break; case "backwards": for (n = null, r = t.child, t.child = null; r !== null;) { if (e = r.alternate, e !== null && aa(e) === null) { t.child = r; break } e = r.sibling, r.sibling = n, n = r, r = e } Nl(t, !0, n, null, s); break; case "together": Nl(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Ro(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function fn(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), gi |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(P(153)); if (t.child !== null) { for (e = t.child, n = Rn(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Rn(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function Ev(e, t, n) { switch (t.tag) { case 3: dm(t), tr(); break; case 5: $1(t); break; case 1: Ze(t.type) && ta(t); break; case 4: bd(t, t.stateNode.containerInfo); break; case 10: var i = t.type._context, r = t.memoizedProps.value; ae(ra, i._currentValue), i._currentValue = r; break; case 13: if (i = t.memoizedState, i !== null) return i.dehydrated !== null ? (ae(ge, ge.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? fm(e, t, n) : (ae(ge, ge.current & 1), e = fn(e, t, n), e !== null ? e.sibling : null); ae(ge, ge.current & 1); break; case 19: if (i = (n & t.childLanes) !== 0, e.flags & 128) { if (i) return hm(e, t, n); t.flags |= 128 } if (r = t.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), ae(ge, ge.current), i) break; return null; case 22: case 23: return t.lanes = 0, cm(e, t, n) }return fn(e, t, n) } var pm, Ac, gm, mm; pm = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Ac = function () { }; gm = function (e, t, n, i) { var r = e.memoizedProps; if (r !== i) { e = t.stateNode, si(Ht.current); var s = null; switch (n) { case "input": r = sc(e, r), i = sc(e, i), s = []; break; case "select": r = ye({}, r, { value: void 0 }), i = ye({}, i, { value: void 0 }), s = []; break; case "textarea": r = lc(e, r), i = lc(e, i), s = []; break; default: typeof r.onClick != "function" && typeof i.onClick == "function" && (e.onclick = Zo) }uc(n, i); var o; n = null; for (c in r) if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null) if (c === "style") { var a = r[c]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (cs.hasOwnProperty(c) ? s || (s = []) : (s = s || []).push(c, null)); for (c in i) { var l = i[c]; if (a = r != null ? r[c] : void 0, i.hasOwnProperty(c) && l !== a && (l != null || a != null)) if (c === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (n || (n = {}), n[o] = l[o]) } else n || (s || (s = []), s.push(c, n)), n = l; else c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (cs.hasOwnProperty(c) ? (l != null && c === "onScroll" && le("scroll", e), s || a === l || (s = [])) : (s = s || []).push(c, l)) } n && (s = s || []).push("style", n); var c = s; (t.updateQueue = c) && (t.flags |= 4) } }; mm = function (e, t, n, i) { n !== i && (t.flags |= 4) }; function Cr(e, t) { if (!he) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : i.sibling = null } } function Ie(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, i = 0; if (t) for (var r = e.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = e, r = r.sibling; else for (r = e.child; r !== null;)n |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = e, r = r.sibling; return e.subtreeFlags |= i, e.childLanes = n, t } function Mv(e, t, n) { var i = t.pendingProps; switch (hd(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return Ie(t), null; case 1: return Ze(t.type) && ea(), Ie(t), null; case 3: return i = t.stateNode, ir(), ue(Je), ue(We), wd(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (e === null || e.child === null) && (so(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Et !== null && (Hc(Et), Et = null))), Ac(e, t), Ie(t), null; case 5: _d(t); var r = si(_s.current); if (n = t.type, e !== null && t.stateNode != null) gm(e, t, n, i, r), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!i) { if (t.stateNode === null) throw Error(P(166)); return Ie(t), null } if (e = si(Ht.current), so(t)) { i = t.stateNode, n = t.type; var s = t.memoizedProps; switch (i[Wt] = t, i[xs] = s, e = (t.mode & 1) !== 0, n) { case "dialog": le("cancel", i), le("close", i); break; case "iframe": case "object": case "embed": le("load", i); break; case "video": case "audio": for (r = 0; r < Ir.length; r++)le(Ir[r], i); break; case "source": le("error", i); break; case "img": case "image": case "link": le("error", i), le("load", i); break; case "details": le("toggle", i); break; case "input": wf(i, s), le("invalid", i); break; case "select": i._wrapperState = { wasMultiple: !!s.multiple }, le("invalid", i); break; case "textarea": Sf(i, s), le("invalid", i) }uc(n, s), r = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== !0 && ro(i.textContent, a, e), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && ro(i.textContent, a, e), r = ["children", "" + a]) : cs.hasOwnProperty(o) && a != null && o === "onScroll" && le("scroll", i) } switch (n) { case "input": Qs(i), jf(i, s, !0); break; case "textarea": Qs(i), kf(i); break; case "select": case "option": break; default: typeof s.onClick == "function" && (i.onclick = Zo) }i = r, t.updateQueue = i, i !== null && (t.flags |= 4) } else { o = r.nodeType === 9 ? r : r.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Vg(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof i.is == "string" ? e = o.createElement(n, { is: i.is }) : (e = o.createElement(n), n === "select" && (o = e, i.multiple ? o.multiple = !0 : i.size && (o.size = i.size))) : e = o.createElementNS(e, n), e[Wt] = t, e[xs] = i, pm(e, t, !1, !1), t.stateNode = e; e: { switch (o = dc(n, i), n) { case "dialog": le("cancel", e), le("close", e), r = i; break; case "iframe": case "object": case "embed": le("load", e), r = i; break; case "video": case "audio": for (r = 0; r < Ir.length; r++)le(Ir[r], e); r = i; break; case "source": le("error", e), r = i; break; case "img": case "image": case "link": le("error", e), le("load", e), r = i; break; case "details": le("toggle", e), r = i; break; case "input": wf(e, i), r = sc(e, i), le("invalid", e); break; case "option": r = i; break; case "select": e._wrapperState = { wasMultiple: !!i.multiple }, r = ye({}, i, { value: void 0 }), le("invalid", e); break; case "textarea": Sf(e, i), r = lc(e, i), le("invalid", e); break; default: r = i }uc(n, r), a = r; for (s in a) if (a.hasOwnProperty(s)) { var l = a[s]; s === "style" ? Yg(e, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && Ug(e, l)) : s === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && us(e, l) : typeof l == "number" && us(e, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (cs.hasOwnProperty(s) ? l != null && s === "onScroll" && le("scroll", e) : l != null && Ju(e, s, l, o)) } switch (n) { case "input": Qs(e), jf(e, i, !1); break; case "textarea": Qs(e), kf(e); break; case "option": i.value != null && e.setAttribute("value", "" + An(i.value)); break; case "select": e.multiple = !!i.multiple, s = i.value, s != null ? Ui(e, !!i.multiple, s, !1) : i.defaultValue != null && Ui(e, !!i.multiple, i.defaultValue, !0); break; default: typeof r.onClick == "function" && (e.onclick = Zo) }switch (n) { case "button": case "input": case "select": case "textarea": i = !!i.autoFocus; break e; case "img": i = !0; break e; default: i = !1 } } i && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return Ie(t), null; case 6: if (e && t.stateNode != null) mm(e, t, e.memoizedProps, i); else { if (typeof i != "string" && t.stateNode === null) throw Error(P(166)); if (n = si(_s.current), si(Ht.current), so(t)) { if (i = t.stateNode, n = t.memoizedProps, i[Wt] = t, (s = i.nodeValue !== n) && (e = ut, e !== null)) switch (e.tag) { case 3: ro(i.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && ro(i.nodeValue, n, (e.mode & 1) !== 0) }s && (t.flags |= 4) } else i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i), i[Wt] = t, t.stateNode = i } return Ie(t), null; case 13: if (ue(ge), i = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (he && ot !== null && t.mode & 1 && !(t.flags & 128)) N1(), tr(), t.flags |= 98560, s = !1; else if (s = so(t), i !== null && i.dehydrated !== null) { if (e === null) { if (!s) throw Error(P(318)); if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(P(317)); s[Wt] = t } else tr(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; Ie(t), s = !1 } else Et !== null && (Hc(Et), Et = null), s = !0; if (!s) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (i = i !== null, i !== (e !== null && e.memoizedState !== null) && i && (t.child.flags |= 8192, t.mode & 1 && (e === null || ge.current & 1 ? Oe === 0 && (Oe = 3) : Rd())), t.updateQueue !== null && (t.flags |= 4), Ie(t), null); case 4: return ir(), Ac(e, t), e === null && ys(t.stateNode.containerInfo), Ie(t), null; case 10: return yd(t.type._context), Ie(t), null; case 17: return Ze(t.type) && ea(), Ie(t), null; case 19: if (ue(ge), s = t.memoizedState, s === null) return Ie(t), null; if (i = (t.flags & 128) !== 0, o = s.rendering, o === null) if (i) Cr(s, !1); else { if (Oe !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (o = aa(e), o !== null) { for (t.flags |= 128, Cr(s, !1), i = o.updateQueue, i !== null && (t.updateQueue = i, t.flags |= 4), t.subtreeFlags = 0, i = n, n = t.child; n !== null;)s = n, e = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, e = o.dependencies, s.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return ae(ge, ge.current & 1 | 2), t.child } e = e.sibling } s.tail !== null && _e() > sr && (t.flags |= 128, i = !0, Cr(s, !1), t.lanes = 4194304) } else { if (!i) if (e = aa(o), e !== null) { if (t.flags |= 128, i = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Cr(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !he) return Ie(t), null } else 2 * _e() - s.renderingStartTime > sr && n !== 1073741824 && (t.flags |= 128, i = !0, Cr(s, !1), t.lanes = 4194304); s.isBackwards ? (o.sibling = t.child, t.child = o) : (n = s.last, n !== null ? n.sibling = o : t.child = o, s.last = o) } return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = _e(), t.sibling = null, n = ge.current, ae(ge, i ? n & 1 | 2 : n & 1), t) : (Ie(t), null); case 22: case 23: return Nd(), i = t.memoizedState !== null, e !== null && e.memoizedState !== null !== i && (t.flags |= 8192), i && t.mode & 1 ? it & 1073741824 && (Ie(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : Ie(t), null; case 24: return null; case 25: return null }throw Error(P(156, t.tag)) } function Dv(e, t) { switch (hd(t), t.tag) { case 1: return Ze(t.type) && ea(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return ir(), ue(Je), ue(We), wd(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return _d(t), null; case 13: if (ue(ge), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(P(340)); tr() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return ue(ge), null; case 4: return ir(), null; case 10: return yd(t.type._context), null; case 22: case 23: return Nd(), null; case 24: return null; default: return null } } var lo = !1, $e = !1, Tv = typeof WeakSet == "function" ? WeakSet : Set, R = null; function Wi(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (i) { ve(e, t, i) } else n.current = null } function Ic(e, t, n) { try { n() } catch (i) { ve(e, t, i) } } var ph = !1; function Nv(e, t) { if (_c = Qo, e = b1(), dd(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var i = n.getSelection && n.getSelection(); if (i && i.rangeCount !== 0) { n = i.anchorNode; var r = i.anchorOffset, s = i.focusNode; i = i.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var o = 0, a = -1, l = -1, c = 0, d = 0, f = e, h = null; t: for (; ;) { for (var p; f !== n || r !== 0 && f.nodeType !== 3 || (a = o + r), f !== s || i !== 0 && f.nodeType !== 3 || (l = o + i), f.nodeType === 3 && (o += f.nodeValue.length), (p = f.firstChild) !== null;)h = f, f = p; for (; ;) { if (f === e) break t; if (h === n && ++c === r && (a = o), h === s && ++d === i && (l = o), (p = f.nextSibling) !== null) break; f = h, h = f.parentNode } f = p } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (wc = { focusedElem: e, selectionRange: n }, Qo = !1, R = t; R !== null;)if (t = R, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, R = e; else for (; R !== null;) { t = R; try { var g = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var v = g.memoizedProps, x = g.memoizedState, y = t.stateNode, m = y.getSnapshotBeforeUpdate(t.elementType === t.type ? v : Ot(t.type, v), x); y.__reactInternalSnapshotBeforeUpdate = m } break; case 3: var b = t.stateNode.containerInfo; b.nodeType === 1 ? b.textContent = "" : b.nodeType === 9 && b.documentElement && b.removeChild(b.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(P(163)) } } catch (j) { ve(t, t.return, j) } if (e = t.sibling, e !== null) { e.return = t.return, R = e; break } R = t.return } return g = ph, ph = !1, g } function Zr(e, t, n) { var i = t.updateQueue; if (i = i !== null ? i.lastEffect : null, i !== null) { var r = i = i.next; do { if ((r.tag & e) === e) { var s = r.destroy; r.destroy = void 0, s !== void 0 && Ic(t, n, s) } r = r.next } while (r !== i) } } function Ha(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var i = n.create; n.destroy = i() } n = n.next } while (n !== t) } } function Fc(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function ym(e) { var t = e.alternate; t !== null && (e.alternate = null, ym(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Wt], delete t[xs], delete t[kc], delete t[gv], delete t[mv])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function vm(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function gh(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || vm(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function $c(e, t, n) { var i = e.tag; if (i === 5 || i === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Zo)); else if (i !== 4 && (e = e.child, e !== null)) for ($c(e, t, n), e = e.sibling; e !== null;)$c(e, t, n), e = e.sibling } function Bc(e, t, n) { var i = e.tag; if (i === 5 || i === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (i !== 4 && (e = e.child, e !== null)) for (Bc(e, t, n), e = e.sibling; e !== null;)Bc(e, t, n), e = e.sibling } var Re = null, Pt = !1; function pn(e, t, n) { for (n = n.child; n !== null;)xm(e, t, n), n = n.sibling } function xm(e, t, n) { if (Ut && typeof Ut.onCommitFiberUnmount == "function") try { Ut.onCommitFiberUnmount(Aa, n) } catch { } switch (n.tag) { case 5: $e || Wi(n, t); case 6: var i = Re, r = Pt; Re = null, pn(e, t, n), Re = i, Pt = r, Re !== null && (Pt ? (e = Re, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : Re.removeChild(n.stateNode)); break; case 18: Re !== null && (Pt ? (e = Re, n = n.stateNode, e.nodeType === 8 ? Cl(e.parentNode, n) : e.nodeType === 1 && Cl(e, n), ps(e)) : Cl(Re, n.stateNode)); break; case 4: i = Re, r = Pt, Re = n.stateNode.containerInfo, Pt = !0, pn(e, t, n), Re = i, Pt = r; break; case 0: case 11: case 14: case 15: if (!$e && (i = n.updateQueue, i !== null && (i = i.lastEffect, i !== null))) { r = i = i.next; do { var s = r, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && Ic(n, t, o), r = r.next } while (r !== i) } pn(e, t, n); break; case 1: if (!$e && (Wi(n, t), i = n.stateNode, typeof i.componentWillUnmount == "function")) try { i.props = n.memoizedProps, i.state = n.memoizedState, i.componentWillUnmount() } catch (a) { ve(n, t, a) } pn(e, t, n); break; case 21: pn(e, t, n); break; case 22: n.mode & 1 ? ($e = (i = $e) || n.memoizedState !== null, pn(e, t, n), $e = i) : pn(e, t, n); break; default: pn(e, t, n) } } function mh(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new Tv), t.forEach(function (i) { var r = Wv.bind(null, e, i); n.has(i) || (n.add(i), i.then(r, r)) }) } } function Ct(e, t) { var n = t.deletions; if (n !== null) for (var i = 0; i < n.length; i++) { var r = n[i]; try { var s = e, o = t, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: Re = a.stateNode, Pt = !1; break e; case 3: Re = a.stateNode.containerInfo, Pt = !0; break e; case 4: Re = a.stateNode.containerInfo, Pt = !0; break e }a = a.return } if (Re === null) throw Error(P(160)); xm(s, o, r), Re = null, Pt = !1; var l = r.alternate; l !== null && (l.return = null), r.return = null } catch (c) { ve(r, t, c) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)bm(t, e), t = t.sibling } function bm(e, t) { var n = e.alternate, i = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Ct(t, e), At(e), i & 4) { try { Zr(3, e, e.return), Ha(3, e) } catch (v) { ve(e, e.return, v) } try { Zr(5, e, e.return) } catch (v) { ve(e, e.return, v) } } break; case 1: Ct(t, e), At(e), i & 512 && n !== null && Wi(n, n.return); break; case 5: if (Ct(t, e), At(e), i & 512 && n !== null && Wi(n, n.return), e.flags & 32) { var r = e.stateNode; try { us(r, "") } catch (v) { ve(e, e.return, v) } } if (i & 4 && (r = e.stateNode, r != null)) { var s = e.memoizedProps, o = n !== null ? n.memoizedProps : s, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && s.type === "radio" && s.name != null && Bg(r, s), dc(a, o); var c = dc(a, s); for (o = 0; o < l.length; o += 2) { var d = l[o], f = l[o + 1]; d === "style" ? Yg(r, f) : d === "dangerouslySetInnerHTML" ? Ug(r, f) : d === "children" ? us(r, f) : Ju(r, d, f, c) } switch (a) { case "input": oc(r, s); break; case "textarea": Wg(r, s); break; case "select": var h = r._wrapperState.wasMultiple; r._wrapperState.wasMultiple = !!s.multiple; var p = s.value; p != null ? Ui(r, !!s.multiple, p, !1) : h !== !!s.multiple && (s.defaultValue != null ? Ui(r, !!s.multiple, s.defaultValue, !0) : Ui(r, !!s.multiple, s.multiple ? [] : "", !1)) }r[xs] = s } catch (v) { ve(e, e.return, v) } } break; case 6: if (Ct(t, e), At(e), i & 4) { if (e.stateNode === null) throw Error(P(162)); r = e.stateNode, s = e.memoizedProps; try { r.nodeValue = s } catch (v) { ve(e, e.return, v) } } break; case 3: if (Ct(t, e), At(e), i & 4 && n !== null && n.memoizedState.isDehydrated) try { ps(t.containerInfo) } catch (v) { ve(e, e.return, v) } break; case 4: Ct(t, e), At(e); break; case 13: Ct(t, e), At(e), r = e.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (Dd = _e())), i & 4 && mh(e); break; case 22: if (d = n !== null && n.memoizedState !== null, e.mode & 1 ? ($e = (c = $e) || d, Ct(t, e), $e = c) : Ct(t, e), At(e), i & 8192) { if (c = e.memoizedState !== null, (e.stateNode.isHidden = c) && !d && e.mode & 1) for (R = e, d = e.child; d !== null;) { for (f = R = d; R !== null;) { switch (h = R, p = h.child, h.tag) { case 0: case 11: case 14: case 15: Zr(4, h, h.return); break; case 1: Wi(h, h.return); var g = h.stateNode; if (typeof g.componentWillUnmount == "function") { i = h, n = h.return; try { t = i, g.props = t.memoizedProps, g.state = t.memoizedState, g.componentWillUnmount() } catch (v) { ve(i, n, v) } } break; case 5: Wi(h, h.return); break; case 22: if (h.memoizedState !== null) { vh(f); continue } }p !== null ? (p.return = h, R = p) : vh(f) } d = d.sibling } e: for (d = null, f = e; ;) { if (f.tag === 5) { if (d === null) { d = f; try { r = f.stateNode, c ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = Hg("display", o)) } catch (v) { ve(e, e.return, v) } } } else if (f.tag === 6) { if (d === null) try { f.stateNode.nodeValue = c ? "" : f.memoizedProps } catch (v) { ve(e, e.return, v) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; d === f && (d = null), f = f.return } d === f && (d = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: Ct(t, e), At(e), i & 4 && mh(e); break; case 21: break; default: Ct(t, e), At(e) } } function At(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (vm(n)) { var i = n; break e } n = n.return } throw Error(P(160)) } switch (i.tag) { case 5: var r = i.stateNode; i.flags & 32 && (us(r, ""), i.flags &= -33); var s = gh(e); Bc(e, s, r); break; case 3: case 4: var o = i.stateNode.containerInfo, a = gh(e); $c(e, a, o); break; default: throw Error(P(161)) } } catch (l) { ve(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function Rv(e, t, n) { R = e, _m(e) } function _m(e, t, n) { for (var i = (e.mode & 1) !== 0; R !== null;) { var r = R, s = r.child; if (r.tag === 22 && i) { var o = r.memoizedState !== null || lo; if (!o) { var a = r.alternate, l = a !== null && a.memoizedState !== null || $e; a = lo; var c = $e; if (lo = o, ($e = l) && !c) for (R = r; R !== null;)o = R, l = o.child, o.tag === 22 && o.memoizedState !== null ? xh(r) : l !== null ? (l.return = o, R = l) : xh(r); for (; s !== null;)R = s, _m(s), s = s.sibling; R = r, lo = a, $e = c } yh(e) } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, R = s) : yh(e) } } function yh(e) { for (; R !== null;) { var t = R; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: $e || Ha(5, t); break; case 1: var i = t.stateNode; if (t.flags & 4 && !$e) if (n === null) i.componentDidMount(); else { var r = t.elementType === t.type ? n.memoizedProps : Ot(t.type, n.memoizedProps); i.componentDidUpdate(r, n.memoizedState, i.__reactInternalSnapshotBeforeUpdate) } var s = t.updateQueue; s !== null && eh(t, s, i); break; case 3: var o = t.updateQueue; if (o !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }eh(t, o, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var c = t.alternate; if (c !== null) { var d = c.memoizedState; if (d !== null) { var f = d.dehydrated; f !== null && ps(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(P(163)) }$e || t.flags & 512 && Fc(t) } catch (h) { ve(t, t.return, h) } } if (t === e) { R = null; break } if (n = t.sibling, n !== null) { n.return = t.return, R = n; break } R = t.return } } function vh(e) { for (; R !== null;) { var t = R; if (t === e) { R = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, R = n; break } R = t.return } } function xh(e) { for (; R !== null;) { var t = R; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Ha(4, t) } catch (l) { ve(t, n, l) } break; case 1: var i = t.stateNode; if (typeof i.componentDidMount == "function") { var r = t.return; try { i.componentDidMount() } catch (l) { ve(t, r, l) } } var s = t.return; try { Fc(t) } catch (l) { ve(t, s, l) } break; case 5: var o = t.return; try { Fc(t) } catch (l) { ve(t, o, l) } } } catch (l) { ve(t, t.return, l) } if (t === e) { R = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, R = a; break } R = t.return } } var zv = Math.ceil, ua = hn.ReactCurrentDispatcher, Ed = hn.ReactCurrentOwner, jt = hn.ReactCurrentBatchConfig, K = 0, Te = null, Se = null, ze = 0, it = 0, Vi = Wn(0), Oe = 0, ks = null, gi = 0, Ya = 0, Md = 0, es = null, Ge = null, Dd = 0, sr = 1 / 0, Jt = null, da = !1, Wc = null, Tn = null, co = !1, _n = null, fa = 0, ts = 0, Vc = null, zo = -1, Lo = 0; function He() { return K & 6 ? _e() : zo !== -1 ? zo : zo = _e() } function Nn(e) { return e.mode & 1 ? K & 2 && ze !== 0 ? ze & -ze : vv.transition !== null ? (Lo === 0 && (Lo = r1()), Lo) : (e = ne, e !== 0 || (e = window.event, e = e === void 0 ? 16 : d1(e.type)), e) : 1 } function Tt(e, t, n, i) { if (50 < ts) throw ts = 0, Vc = null, Error(P(185)); Fs(e, n, i), (!(K & 2) || e !== Te) && (e === Te && (!(K & 2) && (Ya |= n), Oe === 4 && xn(e, ze)), et(e, i), n === 1 && K === 0 && !(t.mode & 1) && (sr = _e() + 500, Wa && Vn())) } function et(e, t) { var n = e.callbackNode; vy(e, t); var i = Go(e, e === Te ? ze : 0); if (i === 0) n !== null && Pf(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = i & -i, e.callbackPriority !== t) { if (n != null && Pf(n), t === 1) e.tag === 0 ? yv(bh.bind(null, e)) : M1(bh.bind(null, e)), hv(function () { !(K & 6) && Vn() }), n = null; else { switch (s1(i)) { case 1: n = id; break; case 4: n = n1; break; case 16: n = Ko; break; case 536870912: n = i1; break; default: n = Ko }n = Em(n, wm.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function wm(e, t) { if (zo = -1, Lo = 0, K & 6) throw Error(P(327)); var n = e.callbackNode; if (Gi() && e.callbackNode !== n) return null; var i = Go(e, e === Te ? ze : 0); if (i === 0) return null; if (i & 30 || i & e.expiredLanes || t) t = ha(e, i); else { t = i; var r = K; K |= 2; var s = Sm(); (Te !== e || ze !== t) && (Jt = null, sr = _e() + 500, li(e, t)); do try { Iv(); break } catch (a) { jm(e, a) } while (!0); md(), ua.current = s, K = r, Se !== null ? t = 0 : (Te = null, ze = 0, t = Oe) } if (t !== 0) { if (t === 2 && (r = mc(e), r !== 0 && (i = r, t = Uc(e, r))), t === 1) throw n = ks, li(e, 0), xn(e, i), et(e, _e()), n; if (t === 6) xn(e, i); else { if (r = e.current.alternate, !(i & 30) && !Lv(r) && (t = ha(e, i), t === 2 && (s = mc(e), s !== 0 && (i = s, t = Uc(e, s))), t === 1)) throw n = ks, li(e, 0), xn(e, i), et(e, _e()), n; switch (e.finishedWork = r, e.finishedLanes = i, t) { case 0: case 1: throw Error(P(345)); case 2: Jn(e, Ge, Jt); break; case 3: if (xn(e, i), (i & 130023424) === i && (t = Dd + 500 - _e(), 10 < t)) { if (Go(e, 0) !== 0) break; if (r = e.suspendedLanes, (r & i) !== i) { He(), e.pingedLanes |= e.suspendedLanes & r; break } e.timeoutHandle = Sc(Jn.bind(null, e, Ge, Jt), t); break } Jn(e, Ge, Jt); break; case 4: if (xn(e, i), (i & 4194240) === i) break; for (t = e.eventTimes, r = -1; 0 < i;) { var o = 31 - Dt(i); s = 1 << o, o = t[o], o > r && (r = o), i &= ~s } if (i = r, i = _e() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * zv(i / 1960)) - i, 10 < i) { e.timeoutHandle = Sc(Jn.bind(null, e, Ge, Jt), i); break } Jn(e, Ge, Jt); break; case 5: Jn(e, Ge, Jt); break; default: throw Error(P(329)) } } } return et(e, _e()), e.callbackNode === n ? wm.bind(null, e) : null } function Uc(e, t) { var n = es; return e.current.memoizedState.isDehydrated && (li(e, t).flags |= 256), e = ha(e, t), e !== 2 && (t = Ge, Ge = n, t !== null && Hc(t)), e } function Hc(e) { Ge === null ? Ge = e : Ge.push.apply(Ge, e) } function Lv(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var i = 0; i < n.length; i++) { var r = n[i], s = r.getSnapshot; r = r.value; try { if (!Rt(s(), r)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function xn(e, t) { for (t &= ~Md, t &= ~Ya, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - Dt(t), i = 1 << n; e[n] = -1, t &= ~i } } function bh(e) { if (K & 6) throw Error(P(327)); Gi(); var t = Go(e, 0); if (!(t & 1)) return et(e, _e()), null; var n = ha(e, t); if (e.tag !== 0 && n === 2) { var i = mc(e); i !== 0 && (t = i, n = Uc(e, i)) } if (n === 1) throw n = ks, li(e, 0), xn(e, t), et(e, _e()), n; if (n === 6) throw Error(P(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, Jn(e, Ge, Jt), et(e, _e()), null } function Td(e, t) { var n = K; K |= 1; try { return e(t) } finally { K = n, K === 0 && (sr = _e() + 500, Wa && Vn()) } } function mi(e) { _n !== null && _n.tag === 0 && !(K & 6) && Gi(); var t = K; K |= 1; var n = jt.transition, i = ne; try { if (jt.transition = null, ne = 1, e) return e() } finally { ne = i, jt.transition = n, K = t, !(K & 6) && Vn() } } function Nd() { it = Vi.current, ue(Vi) } function li(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, fv(n)), Se !== null) for (n = Se.return; n !== null;) { var i = n; switch (hd(i), i.tag) { case 1: i = i.type.childContextTypes, i != null && ea(); break; case 3: ir(), ue(Je), ue(We), wd(); break; case 5: _d(i); break; case 4: ir(); break; case 13: ue(ge); break; case 19: ue(ge); break; case 10: yd(i.type._context); break; case 22: case 23: Nd() }n = n.return } if (Te = e, Se = e = Rn(e.current, null), ze = it = t, Oe = 0, ks = null, Md = Ya = gi = 0, Ge = es = null, ri !== null) { for (t = 0; t < ri.length; t++)if (n = ri[t], i = n.interleaved, i !== null) { n.interleaved = null; var r = i.next, s = n.pending; if (s !== null) { var o = s.next; s.next = r, i.next = o } n.pending = i } ri = null } return e } function jm(e, t) { do { var n = Se; try { if (md(), To.current = ca, la) { for (var i = me.memoizedState; i !== null;) { var r = i.queue; r !== null && (r.pending = null), i = i.next } la = !1 } if (pi = 0, Me = Ce = me = null, Jr = !1, ws = 0, Ed.current = null, n === null || n.return === null) { Oe = 1, ks = t, Se = null; break } e: { var s = e, o = n.return, a = n, l = t; if (t = ze, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var c = l, d = a, f = d.tag; if (!(d.mode & 1) && (f === 0 || f === 11 || f === 15)) { var h = d.alternate; h ? (d.updateQueue = h.updateQueue, d.memoizedState = h.memoizedState, d.lanes = h.lanes) : (d.updateQueue = null, d.memoizedState = null) } var p = ah(o); if (p !== null) { p.flags &= -257, lh(p, o, a, s, t), p.mode & 1 && oh(s, c, t), t = p, l = c; var g = t.updateQueue; if (g === null) { var v = new Set; v.add(l), t.updateQueue = v } else g.add(l); break e } else { if (!(t & 1)) { oh(s, c, t), Rd(); break e } l = Error(P(426)) } } else if (he && a.mode & 1) { var x = ah(o); if (x !== null) { !(x.flags & 65536) && (x.flags |= 256), lh(x, o, a, s, t), pd(rr(l, a)); break e } } s = l = rr(l, a), Oe !== 4 && (Oe = 2), es === null ? es = [s] : es.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, t &= -t, s.lanes |= t; var y = om(s, l, t); Zf(s, y); break e; case 1: a = l; var m = s.type, b = s.stateNode; if (!(s.flags & 128) && (typeof m.getDerivedStateFromError == "function" || b !== null && typeof b.componentDidCatch == "function" && (Tn === null || !Tn.has(b)))) { s.flags |= 65536, t &= -t, s.lanes |= t; var j = am(s, a, t); Zf(s, j); break e } }s = s.return } while (s !== null) } Cm(n) } catch (w) { t = w, Se === n && n !== null && (Se = n = n.return); continue } break } while (!0) } function Sm() { var e = ua.current; return ua.current = ca, e === null ? ca : e } function Rd() { (Oe === 0 || Oe === 3 || Oe === 2) && (Oe = 4), Te === null || !(gi & 268435455) && !(Ya & 268435455) || xn(Te, ze) } function ha(e, t) { var n = K; K |= 2; var i = Sm(); (Te !== e || ze !== t) && (Jt = null, li(e, t)); do try { Av(); break } catch (r) { jm(e, r) } while (!0); if (md(), K = n, ua.current = i, Se !== null) throw Error(P(261)); return Te = null, ze = 0, Oe } function Av() { for (; Se !== null;)km(Se) } function Iv() { for (; Se !== null && !cy();)km(Se) } function km(e) { var t = Pm(e.alternate, e, it); e.memoizedProps = e.pendingProps, t === null ? Cm(e) : Se = t, Ed.current = null } function Cm(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = Dv(n, t), n !== null) { n.flags &= 32767, Se = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Oe = 6, Se = null; return } } else if (n = Mv(n, t, it), n !== null) { Se = n; return } if (t = t.sibling, t !== null) { Se = t; return } Se = t = e } while (t !== null); Oe === 0 && (Oe = 5) } function Jn(e, t, n) { var i = ne, r = jt.transition; try { jt.transition = null, ne = 1, Fv(e, t, n, i) } finally { jt.transition = r, ne = i } return null } function Fv(e, t, n, i) { do Gi(); while (_n !== null); if (K & 6) throw Error(P(327)); n = e.finishedWork; var r = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(P(177)); e.callbackNode = null, e.callbackPriority = 0; var s = n.lanes | n.childLanes; if (xy(e, s), e === Te && (Se = Te = null, ze = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || co || (co = !0, Em(Ko, function () { return Gi(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = jt.transition, jt.transition = null; var o = ne; ne = 1; var a = K; K |= 4, Ed.current = null, Nv(e, n), bm(n, e), sv(wc), Qo = !!_c, wc = _c = null, e.current = n, Rv(n), uy(), K = a, ne = o, jt.transition = s } else e.current = n; if (co && (co = !1, _n = e, fa = r), s = e.pendingLanes, s === 0 && (Tn = null), hy(n.stateNode), et(e, _e()), t !== null) for (i = e.onRecoverableError, n = 0; n < t.length; n++)r = t[n], i(r.value, { componentStack: r.stack, digest: r.digest }); if (da) throw da = !1, e = Wc, Wc = null, e; return fa & 1 && e.tag !== 0 && Gi(), s = e.pendingLanes, s & 1 ? e === Vc ? ts++ : (ts = 0, Vc = e) : ts = 0, Vn(), null } function Gi() { if (_n !== null) { var e = s1(fa), t = jt.transition, n = ne; try { if (jt.transition = null, ne = 16 > e ? 16 : e, _n === null) var i = !1; else { if (e = _n, _n = null, fa = 0, K & 6) throw Error(P(331)); var r = K; for (K |= 4, R = e.current; R !== null;) { var s = R, o = s.child; if (R.flags & 16) { var a = s.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var c = a[l]; for (R = c; R !== null;) { var d = R; switch (d.tag) { case 0: case 11: case 15: Zr(8, d, s) }var f = d.child; if (f !== null) f.return = d, R = f; else for (; R !== null;) { d = R; var h = d.sibling, p = d.return; if (ym(d), d === c) { R = null; break } if (h !== null) { h.return = p, R = h; break } R = p } } } var g = s.alternate; if (g !== null) { var v = g.child; if (v !== null) { g.child = null; do { var x = v.sibling; v.sibling = null, v = x } while (v !== null) } } R = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, R = o; else e: for (; R !== null;) { if (s = R, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: Zr(9, s, s.return) }var y = s.sibling; if (y !== null) { y.return = s.return, R = y; break e } R = s.return } } var m = e.current; for (R = m; R !== null;) { o = R; var b = o.child; if (o.subtreeFlags & 2064 && b !== null) b.return = o, R = b; else e: for (o = m; R !== null;) { if (a = R, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Ha(9, a) } } catch (w) { ve(a, a.return, w) } if (a === o) { R = null; break e } var j = a.sibling; if (j !== null) { j.return = a.return, R = j; break e } R = a.return } } if (K = r, Vn(), Ut && typeof Ut.onPostCommitFiberRoot == "function") try { Ut.onPostCommitFiberRoot(Aa, e) } catch { } i = !0 } return i } finally { ne = n, jt.transition = t } } return !1 } function _h(e, t, n) { t = rr(n, t), t = om(e, t, 1), e = Dn(e, t, 1), t = He(), e !== null && (Fs(e, 1, t), et(e, t)) } function ve(e, t, n) { if (e.tag === 3) _h(e, e, n); else for (; t !== null;) { if (t.tag === 3) { _h(t, e, n); break } else if (t.tag === 1) { var i = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Tn === null || !Tn.has(i))) { e = rr(n, e), e = am(t, e, 1), t = Dn(t, e, 1), e = He(), t !== null && (Fs(t, 1, e), et(t, e)); break } } t = t.return } } function $v(e, t, n) { var i = e.pingCache; i !== null && i.delete(t), t = He(), e.pingedLanes |= e.suspendedLanes & n, Te === e && (ze & n) === n && (Oe === 4 || Oe === 3 && (ze & 130023424) === ze && 500 > _e() - Dd ? li(e, 0) : Md |= n), et(e, t) } function Om(e, t) { t === 0 && (e.mode & 1 ? (t = Zs, Zs <<= 1, !(Zs & 130023424) && (Zs = 4194304)) : t = 1); var n = He(); e = dn(e, t), e !== null && (Fs(e, t, n), et(e, n)) } function Bv(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), Om(e, n) } function Wv(e, t) { var n = 0; switch (e.tag) { case 13: var i = e.stateNode, r = e.memoizedState; r !== null && (n = r.retryLane); break; case 19: i = e.stateNode; break; default: throw Error(P(314)) }i !== null && i.delete(t), Om(e, n) } var Pm; Pm = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Je.current) qe = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return qe = !1, Ev(e, t, n); qe = !!(e.flags & 131072) } else qe = !1, he && t.flags & 1048576 && D1(t, ia, t.index); switch (t.lanes = 0, t.tag) { case 2: var i = t.type; Ro(e, t), e = t.pendingProps; var r = er(t, We.current); Ki(t, n), r = Sd(null, t, i, e, r, n); var s = kd(); return t.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ze(i) ? (s = !0, ta(t)) : s = !1, t.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, xd(t), r.updater = Va, t.stateNode = r, r._reactInternals = t, Dc(t, i, e, n), t = Rc(null, t, i, !0, s, n)) : (t.tag = 0, he && s && fd(t), Ue(null, t, r, n), t = t.child), t; case 16: i = t.elementType; e: { switch (Ro(e, t), e = t.pendingProps, r = i._init, i = r(i._payload), t.type = i, r = t.tag = Uv(i), e = Ot(i, e), r) { case 0: t = Nc(null, t, i, e, n); break e; case 1: t = dh(null, t, i, e, n); break e; case 11: t = ch(null, t, i, e, n); break e; case 14: t = uh(null, t, i, Ot(i.type, e), n); break e }throw Error(P(306, i, "")) } return t; case 0: return i = t.type, r = t.pendingProps, r = t.elementType === i ? r : Ot(i, r), Nc(e, t, i, r, n); case 1: return i = t.type, r = t.pendingProps, r = t.elementType === i ? r : Ot(i, r), dh(e, t, i, r, n); case 3: e: { if (dm(t), e === null) throw Error(P(387)); i = t.pendingProps, s = t.memoizedState, r = s.element, z1(e, t), oa(t, i, null, n); var o = t.memoizedState; if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) { r = rr(Error(P(423)), t), t = fh(e, t, i, n, r); break e } else if (i !== r) { r = rr(Error(P(424)), t), t = fh(e, t, i, n, r); break e } else for (ot = Mn(t.stateNode.containerInfo.firstChild), ut = t, he = !0, Et = null, n = F1(t, null, i, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (tr(), i === r) { t = fn(e, t, n); break e } Ue(e, t, i, n) } t = t.child } return t; case 5: return $1(t), e === null && Pc(t), i = t.type, r = t.pendingProps, s = e !== null ? e.memoizedProps : null, o = r.children, jc(i, r) ? o = null : s !== null && jc(i, s) && (t.flags |= 32), um(e, t), Ue(e, t, o, n), t.child; case 6: return e === null && Pc(t), null; case 13: return fm(e, t, n); case 4: return bd(t, t.stateNode.containerInfo), i = t.pendingProps, e === null ? t.child = nr(t, null, i, n) : Ue(e, t, i, n), t.child; case 11: return i = t.type, r = t.pendingProps, r = t.elementType === i ? r : Ot(i, r), ch(e, t, i, r, n); case 7: return Ue(e, t, t.pendingProps, n), t.child; case 8: return Ue(e, t, t.pendingProps.children, n), t.child; case 12: return Ue(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (i = t.type._context, r = t.pendingProps, s = t.memoizedProps, o = r.value, ae(ra, i._currentValue), i._currentValue = o, s !== null) if (Rt(s.value, o)) { if (s.children === r.children && !Je.current) { t = fn(e, t, n); break e } } else for (s = t.child, s !== null && (s.return = t); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var l = a.firstContext; l !== null;) { if (l.context === i) { if (s.tag === 1) { l = ln(-1, n & -n), l.tag = 2; var c = s.updateQueue; if (c !== null) { c = c.shared; var d = c.pending; d === null ? l.next = l : (l.next = d.next, d.next = l), c.pending = l } } s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Ec(s.return, n, t), a.lanes |= n; break } l = l.next } } else if (s.tag === 10) o = s.type === t.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(P(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), Ec(o, n, t), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === t) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } Ue(e, t, r.children, n), t = t.child } return t; case 9: return r = t.type, i = t.pendingProps.children, Ki(t, n), r = St(r), i = i(r), t.flags |= 1, Ue(e, t, i, n), t.child; case 14: return i = t.type, r = Ot(i, t.pendingProps), r = Ot(i.type, r), uh(e, t, i, r, n); case 15: return lm(e, t, t.type, t.pendingProps, n); case 17: return i = t.type, r = t.pendingProps, r = t.elementType === i ? r : Ot(i, r), Ro(e, t), t.tag = 1, Ze(i) ? (e = !0, ta(t)) : e = !1, Ki(t, n), A1(t, i, r), Dc(t, i, r, n), Rc(null, t, i, !0, e, n); case 19: return hm(e, t, n); case 22: return cm(e, t, n) }throw Error(P(156, t.tag)) }; function Em(e, t) { return t1(e, t) } function Vv(e, t, n, i) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function _t(e, t, n, i) { return new Vv(e, t, n, i) } function zd(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Uv(e) { if (typeof e == "function") return zd(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === ed) return 11; if (e === td) return 14 } return 2 } function Rn(e, t) { var n = e.alternate; return n === null ? (n = _t(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Ao(e, t, n, i, r, s) { var o = 2; if (i = e, typeof e == "function") zd(e) && (o = 1); else if (typeof e == "string") o = 5; else e: switch (e) { case Ni: return ci(n.children, r, s, t); case Zu: o = 8, r |= 8; break; case tc: return e = _t(12, n, t, r | 2), e.elementType = tc, e.lanes = s, e; case nc: return e = _t(13, n, t, r), e.elementType = nc, e.lanes = s, e; case ic: return e = _t(19, n, t, r), e.elementType = ic, e.lanes = s, e; case Ig: return Xa(n, r, s, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Lg: o = 10; break e; case Ag: o = 9; break e; case ed: o = 11; break e; case td: o = 14; break e; case mn: o = 16, i = null; break e }throw Error(P(130, e == null ? e : typeof e, "")) }return t = _t(o, n, t, r), t.elementType = e, t.type = i, t.lanes = s, t } function ci(e, t, n, i) { return e = _t(7, e, i, t), e.lanes = n, e } function Xa(e, t, n, i) { return e = _t(22, e, i, t), e.elementType = Ig, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Rl(e, t, n) { return e = _t(6, e, null, t), e.lanes = n, e } function zl(e, t, n) { return t = _t(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Hv(e, t, n, i, r) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gl(0), this.expirationTimes = gl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gl(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null } function Ld(e, t, n, i, r, s, o, a, l) { return e = new Hv(e, t, n, a, l), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = _t(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: i, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, xd(s), e } function Yv(e, t, n) { var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Ti, key: i == null ? null : "" + i, children: e, containerInfo: t, implementation: n } } function Mm(e) { if (!e) return In; e = e._reactInternals; e: { if (bi(e) !== e || e.tag !== 1) throw Error(P(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ze(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(P(171)) } if (e.tag === 1) { var n = e.type; if (Ze(n)) return E1(e, n, t) } return t } function Dm(e, t, n, i, r, s, o, a, l) { return e = Ld(n, i, !0, e, r, s, o, a, l), e.context = Mm(null), n = e.current, i = He(), r = Nn(n), s = ln(i, r), s.callback = t ?? null, Dn(n, s, r), e.current.lanes = r, Fs(e, r, i), et(e, i), e } function Ka(e, t, n, i) { var r = t.current, s = He(), o = Nn(r); return n = Mm(n), t.context === null ? t.context = n : t.pendingContext = n, t = ln(s, o), t.payload = { element: e }, i = i === void 0 ? null : i, i !== null && (t.callback = i), e = Dn(r, t, o), e !== null && (Tt(e, r, o, s), Do(e, r, o)), o } function pa(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function wh(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function Ad(e, t) { wh(e, t), (e = e.alternate) && wh(e, t) } function Xv() { return null } var Tm = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Id(e) { this._internalRoot = e } Ga.prototype.render = Id.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(P(409)); Ka(e, t, null, null) }; Ga.prototype.unmount = Id.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; mi(function () { Ka(null, e, null, null) }), t[un] = null } }; function Ga(e) { this._internalRoot = e } Ga.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = l1(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < vn.length && t !== 0 && t < vn[n].priority; n++); vn.splice(n, 0, e), n === 0 && u1(e) } }; function Fd(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Qa(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function jh() { } function Kv(e, t, n, i, r) { if (r) { if (typeof i == "function") { var s = i; i = function () { var c = pa(o); s.call(c) } } var o = Dm(t, i, e, 0, null, !1, !1, "", jh); return e._reactRootContainer = o, e[un] = o.current, ys(e.nodeType === 8 ? e.parentNode : e), mi(), o } for (; r = e.lastChild;)e.removeChild(r); if (typeof i == "function") { var a = i; i = function () { var c = pa(l); a.call(c) } } var l = Ld(e, 0, !1, null, null, !1, !1, "", jh); return e._reactRootContainer = l, e[un] = l.current, ys(e.nodeType === 8 ? e.parentNode : e), mi(function () { Ka(t, l, n, i) }), l } function qa(e, t, n, i, r) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof r == "function") { var a = r; r = function () { var l = pa(o); a.call(l) } } Ka(t, o, e, r) } else o = Kv(n, t, e, r, i); return pa(o) } o1 = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Ar(t.pendingLanes); n !== 0 && (rd(t, n | 1), et(t, _e()), !(K & 6) && (sr = _e() + 500, Vn())) } break; case 13: mi(function () { var i = dn(e, 1); if (i !== null) { var r = He(); Tt(i, e, 1, r) } }), Ad(e, 1) } }; sd = function (e) { if (e.tag === 13) { var t = dn(e, 134217728); if (t !== null) { var n = He(); Tt(t, e, 134217728, n) } Ad(e, 134217728) } }; a1 = function (e) { if (e.tag === 13) { var t = Nn(e), n = dn(e, t); if (n !== null) { var i = He(); Tt(n, e, t, i) } Ad(e, t) } }; l1 = function () { return ne }; c1 = function (e, t) { var n = ne; try { return ne = e, t() } finally { ne = n } }; hc = function (e, t, n) { switch (t) { case "input": if (oc(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var i = n[t]; if (i !== e && i.form === e.form) { var r = Ba(i); if (!r) throw Error(P(90)); $g(i), oc(i, r) } } } break; case "textarea": Wg(e, n); break; case "select": t = n.value, t != null && Ui(e, !!n.multiple, t, !1) } }; Gg = Td; Qg = mi; var Gv = { usingClientEntryPoint: !1, Events: [Bs, Ai, Ba, Xg, Kg, Td] }, Or = { findFiberByHostInstance: ii, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Qv = { bundleType: Or.bundleType, version: Or.version, rendererPackageName: Or.rendererPackageName, rendererConfig: Or.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: hn.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Zg(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Or.findFiberByHostInstance || Xv, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var uo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!uo.isDisabled && uo.supportsFiber) try { Aa = uo.inject(Qv), Ut = uo } catch { } } ft.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Gv; ft.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Fd(t)) throw Error(P(200)); return Yv(e, t, null, n) }; ft.createRoot = function (e, t) { if (!Fd(e)) throw Error(P(299)); var n = !1, i = "", r = Tm; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (i = t.identifierPrefix), t.onRecoverableError !== void 0 && (r = t.onRecoverableError)), t = Ld(e, 1, !1, null, null, n, !1, i, r), e[un] = t.current, ys(e.nodeType === 8 ? e.parentNode : e), new Id(t) }; ft.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(P(188)) : (e = Object.keys(e).join(","), Error(P(268, e))); return e = Zg(t), e = e === null ? null : e.stateNode, e }; ft.flushSync = function (e) { return mi(e) }; ft.hydrate = function (e, t, n) { if (!Qa(t)) throw Error(P(200)); return qa(null, e, t, !0, n) }; ft.hydrateRoot = function (e, t, n) { if (!Fd(e)) throw Error(P(405)); var i = n != null && n.hydratedSources || null, r = !1, s = "", o = Tm; if (n != null && (n.unstable_strictMode === !0 && (r = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = Dm(t, null, e, 1, n ?? null, r, !1, s, o), e[un] = t.current, ys(e), i) for (e = 0; e < i.length; e++)n = i[e], r = n._getVersion, r = r(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, r] : t.mutableSourceEagerHydrationData.push(n, r); return new Ga(t) }; ft.render = function (e, t, n) { if (!Qa(t)) throw Error(P(200)); return qa(null, e, t, !1, n) }; ft.unmountComponentAtNode = function (e) { if (!Qa(e)) throw Error(P(40)); return e._reactRootContainer ? (mi(function () { qa(null, null, e, !1, function () { e._reactRootContainer = null, e[un] = null }) }), !0) : !1 }; ft.unstable_batchedUpdates = Td; ft.unstable_renderSubtreeIntoContainer = function (e, t, n, i) { if (!Qa(n)) throw Error(P(200)); if (e == null || e._reactInternals === void 0) throw Error(P(38)); return qa(e, t, n, !1, i) }; ft.version = "18.2.0-next-9e3b772b8-20220608"; function Nm() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Nm) } catch (e) { console.error(e) } } Nm(), Dg.exports = ft; var Rm = Dg.exports; const Fr = za(Rm); var Sh = Rm; Zl.createRoot = Sh.createRoot, Zl.hydrateRoot = Sh.hydrateRoot; function qv() { return u.jsx("div", {}) }/**
 * @remix-run/router v1.15.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Cs() { return Cs = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Cs.apply(this, arguments) } var wn; (function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" })(wn || (wn = {})); const kh = "popstate"; function Jv(e) { e === void 0 && (e = {}); function t(i, r) { let { pathname: s, search: o, hash: a } = i.location; return Yc("", { pathname: s, search: o, hash: a }, r.state && r.state.usr || null, r.state && r.state.key || "default") } function n(i, r) { return typeof r == "string" ? r : ga(r) } return ex(t, n, null, e) } function je(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function zm(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function Zv() { return Math.random().toString(36).substr(2, 8) } function Ch(e, t) { return { usr: e.state, key: e.key, idx: t } } function Yc(e, t, n, i) { return n === void 0 && (n = null), Cs({ pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" }, typeof t == "string" ? fr(t) : t, { state: n, key: t && t.key || i || Zv() }) } function ga(e) { let { pathname: t = "/", search: n = "", hash: i = "" } = e; return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), i && i !== "#" && (t += i.charAt(0) === "#" ? i : "#" + i), t } function fr(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let i = e.indexOf("?"); i >= 0 && (t.search = e.substr(i), e = e.substr(0, i)), e && (t.pathname = e) } return t } function ex(e, t, n, i) { i === void 0 && (i = {}); let { window: r = document.defaultView, v5Compat: s = !1 } = i, o = r.history, a = wn.Pop, l = null, c = d(); c == null && (c = 0, o.replaceState(Cs({}, o.state, { idx: c }), "")); function d() { return (o.state || { idx: null }).idx } function f() { a = wn.Pop; let x = d(), y = x == null ? null : x - c; c = x, l && l({ action: a, location: v.location, delta: y }) } function h(x, y) { a = wn.Push; let m = Yc(v.location, x, y); n && n(m, x), c = d() + 1; let b = Ch(m, c), j = v.createHref(m); try { o.pushState(b, "", j) } catch (w) { if (w instanceof DOMException && w.name === "DataCloneError") throw w; r.location.assign(j) } s && l && l({ action: a, location: v.location, delta: 1 }) } function p(x, y) { a = wn.Replace; let m = Yc(v.location, x, y); n && n(m, x), c = d(); let b = Ch(m, c), j = v.createHref(m); o.replaceState(b, "", j), s && l && l({ action: a, location: v.location, delta: 0 }) } function g(x) { let y = r.location.origin !== "null" ? r.location.origin : r.location.href, m = typeof x == "string" ? x : ga(x); return m = m.replace(/ $/, "%20"), je(y, "No window.location.(origin|href) available to create URL for href: " + m), new URL(m, y) } let v = { get action() { return a }, get location() { return e(r, o) }, listen(x) { if (l) throw new Error("A history only accepts one active listener"); return r.addEventListener(kh, f), l = x, () => { r.removeEventListener(kh, f), l = null } }, createHref(x) { return t(r, x) }, createURL: g, encodeLocation(x) { let y = g(x); return { pathname: y.pathname, search: y.search, hash: y.hash } }, push: h, replace: p, go(x) { return o.go(x) } }; return v } var Oh; (function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" })(Oh || (Oh = {})); function tx(e, t, n) { n === void 0 && (n = "/"); let i = typeof t == "string" ? fr(t) : t, r = $d(i.pathname || "/", n); if (r == null) return null; let s = Lm(e); nx(s); let o = null; for (let a = 0; o == null && a < s.length; ++a) { let l = px(r); o = dx(s[a], l) } return o } function Lm(e, t, n, i) { t === void 0 && (t = []), n === void 0 && (n = []), i === void 0 && (i = ""); let r = (s, o, a) => { let l = { relativePath: a === void 0 ? s.path || "" : a, caseSensitive: s.caseSensitive === !0, childrenIndex: o, route: s }; l.relativePath.startsWith("/") && (je(l.relativePath.startsWith(i), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + i + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), l.relativePath = l.relativePath.slice(i.length)); let c = zn([i, l.relativePath]), d = n.concat(l); s.children && s.children.length > 0 && (je(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')), Lm(s.children, t, d, c)), !(s.path == null && !s.index) && t.push({ path: c, score: cx(c, s.index), routesMeta: d }) }; return e.forEach((s, o) => { var a; if (s.path === "" || !((a = s.path) != null && a.includes("?"))) r(s, o); else for (let l of Am(s.path)) r(s, o, l) }), t } function Am(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...i] = t, r = n.endsWith("?"), s = n.replace(/\?$/, ""); if (i.length === 0) return r ? [s, ""] : [s]; let o = Am(i.join("/")), a = []; return a.push(...o.map(l => l === "" ? s : [s, l].join("/"))), r && a.push(...o), a.map(l => e.startsWith("/") && l === "" ? "/" : l) } function nx(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : ux(t.routesMeta.map(i => i.childrenIndex), n.routesMeta.map(i => i.childrenIndex))) } const ix = /^:[\w-]+$/, rx = 3, sx = 2, ox = 1, ax = 10, lx = -2, Ph = e => e === "*"; function cx(e, t) { let n = e.split("/"), i = n.length; return n.some(Ph) && (i += lx), t && (i += sx), n.filter(r => !Ph(r)).reduce((r, s) => r + (ix.test(s) ? rx : s === "" ? ox : ax), i) } function ux(e, t) { return e.length === t.length && e.slice(0, -1).every((i, r) => i === t[r]) ? e[e.length - 1] - t[t.length - 1] : 0 } function dx(e, t) { let { routesMeta: n } = e, i = {}, r = "/", s = []; for (let o = 0; o < n.length; ++o) { let a = n[o], l = o === n.length - 1, c = r === "/" ? t : t.slice(r.length) || "/", d = fx({ path: a.relativePath, caseSensitive: a.caseSensitive, end: l }, c); if (!d) return null; Object.assign(i, d.params); let f = a.route; s.push({ params: i, pathname: zn([r, d.pathname]), pathnameBase: vx(zn([r, d.pathnameBase])), route: f }), d.pathnameBase !== "/" && (r = zn([r, d.pathnameBase])) } return s } function fx(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, i] = hx(e.path, e.caseSensitive, e.end), r = t.match(n); if (!r) return null; let s = r[0], o = s.replace(/(.)\/+$/, "$1"), a = r.slice(1); return { params: i.reduce((c, d, f) => { let { paramName: h, isOptional: p } = d; if (h === "*") { let v = a[f] || ""; o = s.slice(0, s.length - v.length).replace(/(.)\/+$/, "$1") } const g = a[f]; return p && !g ? c[h] = void 0 : c[h] = (g || "").replace(/%2F/g, "/"), c }, {}), pathname: s, pathnameBase: o, pattern: e } } function hx(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !0), zm(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')); let i = [], r = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (i.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (i.push({ paramName: "*" }), r += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? r += "\\/*$" : e !== "" && e !== "/" && (r += "(?:(?=\\/|$))"), [new RegExp(r, t ? void 0 : "i"), i] } function px(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return zm(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e } } function $d(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, i = e.charAt(n); return i && i !== "/" ? null : e.slice(n) || "/" } function gx(e, t) { t === void 0 && (t = "/"); let { pathname: n, search: i = "", hash: r = "" } = typeof e == "string" ? fr(e) : e; return { pathname: n ? n.startsWith("/") ? n : mx(n, t) : t, search: xx(i), hash: bx(r) } } function mx(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(r => { r === ".." ? n.length > 1 && n.pop() : r !== "." && n.push(r) }), n.length > 1 ? n.join("/") : "/" } function Ll(e, t, n, i) { return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(i) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function yx(e) { return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0) } function Bd(e, t) { let n = yx(e); return t ? n.map((i, r) => r === e.length - 1 ? i.pathname : i.pathnameBase) : n.map(i => i.pathnameBase) } function Wd(e, t, n, i) { i === void 0 && (i = !1); let r; typeof e == "string" ? r = fr(e) : (r = Cs({}, e), je(!r.pathname || !r.pathname.includes("?"), Ll("?", "pathname", "search", r)), je(!r.pathname || !r.pathname.includes("#"), Ll("#", "pathname", "hash", r)), je(!r.search || !r.search.includes("#"), Ll("#", "search", "hash", r))); let s = e === "" || r.pathname === "", o = s ? "/" : r.pathname, a; if (o == null) a = n; else { let f = t.length - 1; if (!i && o.startsWith("..")) { let h = o.split("/"); for (; h[0] === "..";)h.shift(), f -= 1; r.pathname = h.join("/") } a = f >= 0 ? t[f] : "/" } let l = gx(r, a), c = o && o !== "/" && o.endsWith("/"), d = (s || o === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (c || d) && (l.pathname += "/"), l } const zn = e => e.join("/").replace(/\/\/+/g, "/"), vx = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), xx = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, bx = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e; function _x(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } const Im = ["post", "put", "patch", "delete"]; new Set(Im); const wx = ["get", ...Im]; new Set(wx);/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Os() { return Os = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Os.apply(this, arguments) } const Vd = S.createContext(null), jx = S.createContext(null), Un = S.createContext(null), Ja = S.createContext(null), Xt = S.createContext({ outlet: null, matches: [], isDataRoute: !1 }), Fm = S.createContext(null); function Sx(e, t) { let { relative: n } = t === void 0 ? {} : t; hr() || je(!1); let { basename: i, navigator: r } = S.useContext(Un), { hash: s, pathname: o, search: a } = Wm(e, { relative: n }), l = o; return i !== "/" && (l = o === "/" ? i : zn([i, o])), r.createHref({ pathname: l, search: a, hash: s }) } function hr() { return S.useContext(Ja) != null } function Vs() { return hr() || je(!1), S.useContext(Ja).location } function $m(e) { S.useContext(Un).static || S.useLayoutEffect(e) } function Za() { let { isDataRoute: e } = S.useContext(Xt); return e ? Fx() : kx() } function kx() { hr() || je(!1); let e = S.useContext(Vd), { basename: t, future: n, navigator: i } = S.useContext(Un), { matches: r } = S.useContext(Xt), { pathname: s } = Vs(), o = JSON.stringify(Bd(r, n.v7_relativeSplatPath)), a = S.useRef(!1); return $m(() => { a.current = !0 }), S.useCallback(function (c, d) { if (d === void 0 && (d = {}), !a.current) return; if (typeof c == "number") { i.go(c); return } let f = Wd(c, JSON.parse(o), s, d.relative === "path"); e == null && t !== "/" && (f.pathname = f.pathname === "/" ? t : zn([t, f.pathname])), (d.replace ? i.replace : i.push)(f, d.state, d) }, [t, i, o, s, e]) } const Cx = S.createContext(null); function Ox(e) { let t = S.useContext(Xt).outlet; return t && S.createElement(Cx.Provider, { value: e }, t) } function Bm() { let { matches: e } = S.useContext(Xt), t = e[e.length - 1]; return t ? t.params : {} } function Wm(e, t) { let { relative: n } = t === void 0 ? {} : t, { future: i } = S.useContext(Un), { matches: r } = S.useContext(Xt), { pathname: s } = Vs(), o = JSON.stringify(Bd(r, i.v7_relativeSplatPath)); return S.useMemo(() => Wd(e, JSON.parse(o), s, n === "path"), [e, o, s, n]) } function Px(e, t) { return Ex(e, t) } function Ex(e, t, n, i) { hr() || je(!1); let { navigator: r } = S.useContext(Un), { matches: s } = S.useContext(Xt), o = s[s.length - 1], a = o ? o.params : {}; o && o.pathname; let l = o ? o.pathnameBase : "/"; o && o.route; let c = Vs(), d; if (t) { var f; let x = typeof t == "string" ? fr(t) : t; l === "/" || (f = x.pathname) != null && f.startsWith(l) || je(!1), d = x } else d = c; let h = d.pathname || "/", p = h; if (l !== "/") { let x = l.replace(/^\//, "").split("/"); p = "/" + h.replace(/^\//, "").split("/").slice(x.length).join("/") } let g = tx(e, { pathname: p }), v = Rx(g && g.map(x => Object.assign({}, x, { params: Object.assign({}, a, x.params), pathname: zn([l, r.encodeLocation ? r.encodeLocation(x.pathname).pathname : x.pathname]), pathnameBase: x.pathnameBase === "/" ? l : zn([l, r.encodeLocation ? r.encodeLocation(x.pathnameBase).pathname : x.pathnameBase]) })), s, n, i); return t && v ? S.createElement(Ja.Provider, { value: { location: Os({ pathname: "/", search: "", hash: "", state: null, key: "default" }, d), navigationType: wn.Pop } }, v) : v } function Mx() { let e = Ix(), t = _x(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return S.createElement(S.Fragment, null, S.createElement("h2", null, "Unexpected Application Error!"), S.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? S.createElement("pre", { style: r }, n) : null, null) } const Dx = S.createElement(Mx, null); class Tx extends S.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, n) { return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : n.error, location: n.location, revalidation: t.revalidation || n.revalidation } } componentDidCatch(t, n) { console.error("React Router caught the following error during render", t, n) } render() { return this.state.error !== void 0 ? S.createElement(Xt.Provider, { value: this.props.routeContext }, S.createElement(Fm.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Nx(e) { let { routeContext: t, match: n, children: i } = e, r = S.useContext(Vd); return r && r.static && r.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = n.route.id), S.createElement(Xt.Provider, { value: t }, i) } function Rx(e, t, n, i) { var r; if (t === void 0 && (t = []), n === void 0 && (n = null), i === void 0 && (i = null), e == null) { var s; if ((s = n) != null && s.errors) e = n.matches; else return null } let o = e, a = (r = n) == null ? void 0 : r.errors; if (a != null) { let d = o.findIndex(f => f.route.id && (a == null ? void 0 : a[f.route.id])); d >= 0 || je(!1), o = o.slice(0, Math.min(o.length, d + 1)) } let l = !1, c = -1; if (n && i && i.v7_partialHydration) for (let d = 0; d < o.length; d++) { let f = o[d]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = d), f.route.id) { let { loaderData: h, errors: p } = n, g = f.route.loader && h[f.route.id] === void 0 && (!p || p[f.route.id] === void 0); if (f.route.lazy || g) { l = !0, c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]]; break } } } return o.reduceRight((d, f, h) => { let p, g = !1, v = null, x = null; n && (p = a && f.route.id ? a[f.route.id] : void 0, v = f.route.errorElement || Dx, l && (c < 0 && h === 0 ? ($x("route-fallback", !1), g = !0, x = null) : c === h && (g = !0, x = f.route.hydrateFallbackElement || null))); let y = t.concat(o.slice(0, h + 1)), m = () => { let b; return p ? b = v : g ? b = x : f.route.Component ? b = S.createElement(f.route.Component, null) : f.route.element ? b = f.route.element : b = d, S.createElement(Nx, { match: f, routeContext: { outlet: d, matches: y, isDataRoute: n != null }, children: b }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || h === 0) ? S.createElement(Tx, { location: n.location, revalidation: n.revalidation, component: v, error: p, children: m(), routeContext: { outlet: null, matches: y, isDataRoute: !0 } }) : m() }, null) } var Vm = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(Vm || {}), ma = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(ma || {}); function zx(e) { let t = S.useContext(Vd); return t || je(!1), t } function Lx(e) { let t = S.useContext(jx); return t || je(!1), t } function Ax(e) { let t = S.useContext(Xt); return t || je(!1), t } function Um(e) { let t = Ax(), n = t.matches[t.matches.length - 1]; return n.route.id || je(!1), n.route.id } function Ix() { var e; let t = S.useContext(Fm), n = Lx(ma.UseRouteError), i = Um(ma.UseRouteError); return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[i] } function Fx() { let { router: e } = zx(Vm.UseNavigateStable), t = Um(ma.UseNavigateStable), n = S.useRef(!1); return $m(() => { n.current = !0 }), S.useCallback(function (r, s) { s === void 0 && (s = {}), n.current && (typeof r == "number" ? e.navigate(r) : e.navigate(r, Os({ fromRouteId: t }, s))) }, [e, t]) } const Eh = {}; function $x(e, t, n) { !t && !Eh[e] && (Eh[e] = !0) } function Pr(e) { let { to: t, replace: n, state: i, relative: r } = e; hr() || je(!1); let { future: s, static: o } = S.useContext(Un), { matches: a } = S.useContext(Xt), { pathname: l } = Vs(), c = Za(), d = Wd(t, Bd(a, s.v7_relativeSplatPath), l, r === "path"), f = JSON.stringify(d); return S.useEffect(() => c(JSON.parse(f), { replace: n, state: i, relative: r }), [c, f, r, n, i]), null } function pr(e) { return Ox(e.context) } function W(e) { je(!1) } function Bx(e) { let { basename: t = "/", children: n = null, location: i, navigationType: r = wn.Pop, navigator: s, static: o = !1, future: a } = e; hr() && je(!1); let l = t.replace(/^\/*/, "/"), c = S.useMemo(() => ({ basename: l, navigator: s, static: o, future: Os({ v7_relativeSplatPath: !1 }, a) }), [l, a, s, o]); typeof i == "string" && (i = fr(i)); let { pathname: d = "/", search: f = "", hash: h = "", state: p = null, key: g = "default" } = i, v = S.useMemo(() => { let x = $d(d, l); return x == null ? null : { location: { pathname: x, search: f, hash: h, state: p, key: g }, navigationType: r } }, [l, d, f, h, p, g, r]); return v == null ? null : S.createElement(Un.Provider, { value: c }, S.createElement(Ja.Provider, { children: n, value: v })) } function Wx(e) { let { children: t, location: n } = e; return Px(Xc(t), n) } new Promise(() => { }); function Xc(e, t) { t === void 0 && (t = []); let n = []; return S.Children.forEach(e, (i, r) => { if (!S.isValidElement(i)) return; let s = [...t, r]; if (i.type === S.Fragment) { n.push.apply(n, Xc(i.props.children, s)); return } i.type !== W && je(!1), !i.props.index || !i.props.children || je(!1); let o = { id: i.props.id || s.join("-"), caseSensitive: i.props.caseSensitive, element: i.props.element, Component: i.props.Component, index: i.props.index, path: i.props.path, loader: i.props.loader, action: i.props.action, errorElement: i.props.errorElement, ErrorBoundary: i.props.ErrorBoundary, hasErrorBoundary: i.props.ErrorBoundary != null || i.props.errorElement != null, shouldRevalidate: i.props.shouldRevalidate, handle: i.props.handle, lazy: i.props.lazy }; i.props.children && (o.children = Xc(i.props.children, s)), n.push(o) }), n }/**
 * React Router DOM v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Kc() { return Kc = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Kc.apply(this, arguments) } function Vx(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function Ux(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function Hx(e, t) { return e.button === 0 && (!t || t === "_self") && !Ux(e) } const Yx = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], Xx = "6"; try { window.__reactRouterVersion = Xx } catch { } const Kx = "startTransition", Mh = B2[Kx]; function Gx(e) { let { basename: t, children: n, future: i, window: r } = e, s = S.useRef(); s.current == null && (s.current = Jv({ window: r, v5Compat: !0 })); let o = s.current, [a, l] = S.useState({ action: o.action, location: o.location }), { v7_startTransition: c } = i || {}, d = S.useCallback(f => { c && Mh ? Mh(() => l(f)) : l(f) }, [l, c]); return S.useLayoutEffect(() => o.listen(d), [o, d]), S.createElement(Bx, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: o, future: i }) } const Qx = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", qx = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Q = S.forwardRef(function (t, n) { let { onClick: i, relative: r, reloadDocument: s, replace: o, state: a, target: l, to: c, preventScrollReset: d, unstable_viewTransition: f } = t, h = Vx(t, Yx), { basename: p } = S.useContext(Un), g, v = !1; if (typeof c == "string" && qx.test(c) && (g = c, Qx)) try { let b = new URL(window.location.href), j = c.startsWith("//") ? new URL(b.protocol + c) : new URL(c), w = $d(j.pathname, p); j.origin === b.origin && w != null ? c = w + j.search + j.hash : v = !0 } catch { } let x = Sx(c, { relative: r }), y = Jx(c, { replace: o, state: a, target: l, preventScrollReset: d, relative: r, unstable_viewTransition: f }); function m(b) { i && i(b), b.defaultPrevented || y(b) } return S.createElement("a", Kc({}, h, { href: g || x, onClick: v || s ? i : m, ref: n, target: l })) }); var Dh; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(Dh || (Dh = {})); var Th; (function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" })(Th || (Th = {})); function Jx(e, t) { let { target: n, replace: i, state: r, preventScrollReset: s, relative: o, unstable_viewTransition: a } = t === void 0 ? {} : t, l = Za(), c = Vs(), d = Wm(e, { relative: o }); return S.useCallback(f => { if (Hx(f, n)) { f.preventDefault(); let h = i !== void 0 ? i : ga(c) === ga(d); l(e, { replace: h, state: r, preventScrollReset: s, relative: o, unstable_viewTransition: a }) } }, [c, l, d, i, r, n, e, s, o, a]) } var Hm = { exports: {} }, Zx = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED", e3 = Zx, t3 = e3; function Ym() { } function Xm() { } Xm.resetWarningCache = Ym; var n3 = function () { function e(i, r, s, o, a, l) { if (l !== t3) { var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw c.name = "Invariant Violation", c } } e.isRequired = e; function t() { return e } var n = { array: e, bigint: e, bool: e, func: e, number: e, object: e, string: e, symbol: e, any: e, arrayOf: t, element: e, elementType: e, instanceOf: t, node: e, objectOf: t, oneOf: t, oneOfType: t, shape: t, exact: t, checkPropTypes: Xm, resetWarningCache: Ym }; return n.PropTypes = n, n }; Hm.exports = n3(); var i3 = Hm.exports; const _ = za(i3); var Km = { exports: {} };/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function (e) { (function () { var t = {}.hasOwnProperty; function n() { for (var s = "", o = 0; o < arguments.length; o++) { var a = arguments[o]; a && (s = r(s, i(a))) } return s } function i(s) { if (typeof s == "string" || typeof s == "number") return s; if (typeof s != "object") return ""; if (Array.isArray(s)) return n.apply(null, s); if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) return s.toString(); var o = ""; for (var a in s) t.call(s, a) && s[a] && (o = r(o, a)); return o } function r(s, o) { return o ? s ? s + " " + o : s + o : s } e.exports ? (n.default = n, e.exports = n) : window.classNames = n })() })(Km); var r3 = Km.exports; const ee = za(r3); function Ps(e) { "@babel/helpers - typeof"; return Ps = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Ps(e) } function s3() { var e = document.createElement("div"); e.style.position = "absolute", e.style.top = "-9999px", e.style.width = "50px", e.style.height = "50px", e.style.overflow = "scroll", document.body.appendChild(e); var t = e.offsetWidth - e.clientWidth; return document.body.removeChild(e), t } function Gm(e) { document.body.style.paddingRight = e > 0 ? "".concat(e, "px") : null } function o3() { return document.body.clientWidth < window.innerWidth } function a3() { var e = window.getComputedStyle(document.body, null); return parseInt(e && e.getPropertyValue("padding-right") || 0, 10) } function l3() { var e = s3(), t = document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top")[0], n = t ? parseInt(t.style.paddingRight || 0, 10) : 0; o3() && Gm(n + e) } var c3; function U() { var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c3; return t ? e.split(" ").map(function (n) { return t[n] || n }).join(" ") : e } function Qm(e, t) { var n = {}; return Object.keys(e).forEach(function (i) { t.indexOf(i) === -1 && (n[i] = e[i]) }), n } function u3(e, t) { for (var n = Array.isArray(t) ? t : [t], i = n.length, r, s = {}; i > 0;)i -= 1, r = n[i], s[r] = e[r]; return s } var Nh = {}; function Gc(e) { Nh[e] || (typeof console < "u" && console.error(e), Nh[e] = !0) } function d3(e, t) {
    return function (i, r, s) {
        i[r] !== null && typeof i[r] < "u" && Gc('"'.concat(r, '" property of "').concat(s, `" has been deprecated.
`).concat(t)); for (var o = arguments.length, a = new Array(o > 3 ? o - 3 : 0), l = 3; l < o; l++)a[l - 3] = arguments[l]; return e.apply(void 0, [i, r, s].concat(a))
    }
} var f3 = (typeof window > "u" ? "undefined" : Ps(window)) === "object" && window.Element || function () { }; function h3(e, t, n) { if (!(e[t] instanceof f3)) return new Error("Invalid prop `" + t + "` supplied to `" + n + "`. Expected prop to be an instance of Element. Validation failed.") } var p3 = _.oneOfType([_.string, _.func, h3, _.shape({ current: _.any })]), pe = _.oneOfType([_.func, _.string, _.shape({ $$typeof: _.symbol, render: _.func }), _.arrayOf(_.oneOfType([_.func, _.string, _.shape({ $$typeof: _.symbol, render: _.func })]))]), Qc = { Fade: 150, Collapse: 350, Modal: 300, Carousel: 600, Offcanvas: 300 }, Rh = ["in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited"], g3 = { esc: 27, space: 32, enter: 13, tab: 9, up: 38, down: 40, home: 36, end: 35, n: 78, p: 80 }, Ud = !!(typeof window < "u" && window.document && window.document.createElement); function m3(e) { return e && Ps(e) === "object" ? "current" in e : !1 } function y3(e) { return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e) } function Hd(e) { var t = Ps(e); return e != null && (t === "object" || t === "function") } function v3(e) { if (!Hd(e)) return !1; var t = y3(e); return t === "[object Function]" || t === "[object AsyncFunction]" || t === "[object GeneratorFunction]" || t === "[object Proxy]" } function x3(e) { if (m3(e)) return e.current; if (v3(e)) return e(); if (typeof e == "string" && Ud) { var t = document.querySelectorAll(e); if (t.length || (t = document.querySelectorAll("#".concat(e))), !t.length) throw new Error("The target '".concat(e, "' could not be identified in the dom, tip: check spelling")); return t } return e } function zh(e) { return e === null ? !1 : Array.isArray(e) || Ud && typeof e.length == "number" } function b3(e, t) { var n = x3(e); return t ? zh(n) ? n : n === null ? [] : [n] : zh(n) ? n[0] : n } var _3 = ["a[href]", "area[href]", "input:not([disabled]):not([type=hidden])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "object", "embed", "[tabindex]:not(.modal):not(.offcanvas)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'], w3 = ["className", "cssModule", "fluid", "tag"]; function qc() { return qc = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, qc.apply(this, arguments) } function j3(e, t) { if (e == null) return {}; var n = S3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function S3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var k3 = { tag: pe, fluid: _.oneOfType([_.bool, _.string]), className: _.string, cssModule: _.object }; function el(e) { var t = e.className, n = e.cssModule, i = e.fluid, r = e.tag, s = r === void 0 ? "div" : r, o = j3(e, w3), a = "container"; i === !0 ? a = "container-fluid" : i && (a = "container-".concat(i)); var l = U(ee(t, a), n); return I.createElement(s, qc({}, o, { className: l })) } el.propTypes = k3; var C3 = ["className", "cssModule", "noGutters", "tag", "widths"]; function Jc() { return Jc = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Jc.apply(this, arguments) } function O3(e, t) { if (e == null) return {}; var n = P3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function P3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var E3 = ["xs", "sm", "md", "lg", "xl", "xxl"], ji = _.oneOfType([_.number, _.string]), M3 = { tag: pe, noGutters: d3(_.bool, "Please use Bootstrap 5 gutter utility classes. https://getbootstrap.com/docs/5.0/layout/gutters/"), className: _.string, cssModule: _.object, xs: ji, sm: ji, md: ji, lg: ji, xl: ji, xxl: ji, widths: _.array }; function Vt(e) { var t = e.className, n = e.cssModule, i = e.noGutters, r = e.tag, s = r === void 0 ? "div" : r, o = e.widths, a = o === void 0 ? E3 : o, l = O3(e, C3), c = []; a.forEach(function (f, h) { var p = e[f]; if (delete l[f], !!p) { var g = !h; c.push(g ? "row-cols-".concat(p) : "row-cols-".concat(f, "-").concat(p)) } }); var d = U(ee(t, i ? "gx-0" : null, "row", c), n); return I.createElement(s, Jc({}, l, { className: d })) } Vt.propTypes = M3; var D3 = ["className", "cssModule", "widths", "tag"]; function Zc() { return Zc = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Zc.apply(this, arguments) } function T3(e, t) { if (e == null) return {}; var n = N3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function N3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function Al(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } var qm = ["xs", "sm", "md", "lg", "xl", "xxl"], Lh = _.oneOfType([_.number, _.string]), Si = _.oneOfType([_.bool, _.number, _.string, _.shape({ size: _.oneOfType([_.bool, _.number, _.string]), order: Lh, offset: Lh })]), R3 = { tag: pe, xs: Si, sm: Si, md: Si, lg: Si, xl: Si, xxl: Si, className: _.string, cssModule: _.object, widths: _.array }, Ah = function (t, n, i) { return i === !0 || i === "" ? t ? "col" : "col-".concat(n) : i === "auto" ? t ? "col-auto" : "col-".concat(n, "-auto") : t ? "col-".concat(i) : "col-".concat(n, "-").concat(i) }, z3 = function (t, n) { var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : qm, r = t, s = []; return i.forEach(function (o, a) { var l = r[o]; if (delete r[o], !(!l && l !== "")) { var c = !a; if (Hd(l)) { var d, f = c ? "-" : "-".concat(o, "-"), h = Ah(c, o, l.size); s.push(U(ee((d = {}, Al(d, h, l.size || l.size === ""), Al(d, "order".concat(f).concat(l.order), l.order || l.order === 0), Al(d, "offset".concat(f).concat(l.offset), l.offset || l.offset === 0), d)), n)) } else { var p = Ah(c, o, l); s.push(p) } } }), { colClasses: s, modifiedAttributes: r } }; function rn(e) { var t = e.className, n = e.cssModule, i = e.widths, r = i === void 0 ? qm : i, s = e.tag, o = s === void 0 ? "div" : s, a = T3(e, D3), l = z3(a, n, r), c = l.modifiedAttributes, d = l.colClasses; d.length || d.push("col"); var f = U(ee(t, d), n); return I.createElement(o, Zc({}, c, { className: f })) } rn.propTypes = R3; var L3 = ["expand", "className", "cssModule", "light", "dark", "fixed", "sticky", "color", "container", "tag", "children"]; function eu() { return eu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, eu.apply(this, arguments) } function Il(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function A3(e, t) { if (e == null) return {}; var n = I3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function I3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var F3 = { children: _.node, className: _.string, color: _.string, container: _.oneOfType([_.bool, _.string]), cssModule: _.object, dark: _.bool, expand: _.oneOfType([_.bool, _.string]), fixed: _.string, light: _.bool, role: _.string, sticky: _.string, tag: pe }, $3 = function (t) { return t === !1 ? !1 : t === !0 || t === "xs" ? "navbar-expand" : "navbar-expand-".concat(t) }; function tl(e) { var t, n = e.expand, i = n === void 0 ? !1 : n, r = e.className, s = e.cssModule, o = e.light, a = e.dark, l = e.fixed, c = e.sticky, d = e.color, f = e.container, h = f === void 0 ? "fluid" : f, p = e.tag, g = p === void 0 ? "nav" : p, v = e.children, x = A3(e, L3), y = U(ee(r, "navbar", $3(i), (t = { "navbar-light": o, "navbar-dark": a }, Il(t, "bg-".concat(d), d), Il(t, "fixed-".concat(l), l), Il(t, "sticky-".concat(c), c), t)), s), m = h && h === !0 ? "container" : "container-".concat(h); return I.createElement(g, eu({}, x, { className: y }), h ? I.createElement("div", { className: m }, v) : v) } tl.propTypes = F3; var B3 = ["className", "cssModule", "tag"]; function tu() { return tu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, tu.apply(this, arguments) } function W3(e, t) { if (e == null) return {}; var n = V3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function V3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var U3 = { className: _.string, cssModule: _.object, tag: pe }; function nl(e) { var t = e.className, n = e.cssModule, i = e.tag, r = i === void 0 ? "a" : i, s = W3(e, B3), o = U(ee(t, "navbar-brand"), n); return I.createElement(r, tu({}, s, { className: o })) } nl.propTypes = U3; var H3 = ["className", "cssModule", "tabs", "pills", "vertical", "horizontal", "justified", "fill", "navbar", "card", "tag"]; function nu() { return nu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, nu.apply(this, arguments) } function Y3(e, t) { if (e == null) return {}; var n = X3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function X3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var K3 = { card: _.bool, className: _.string, cssModule: _.object, fill: _.bool, horizontal: _.oneOf(["center", "end"]), justified: _.bool, navbar: _.bool, pills: _.bool, tabs: _.bool, tag: pe, vertical: _.oneOfType([_.bool, _.string]) }, G3 = function (t) { return t === !1 ? !1 : t === !0 || t === "xs" ? "flex-column" : "flex-".concat(t, "-column") }; function il(e) { var t = e.className, n = e.cssModule, i = e.tabs, r = e.pills, s = e.vertical, o = s === void 0 ? !1 : s, a = e.horizontal, l = e.justified, c = e.fill, d = e.navbar, f = e.card, h = e.tag, p = h === void 0 ? "ul" : h, g = Y3(e, H3), v = U(ee(t, d ? "navbar-nav" : "nav", a ? "justify-content-".concat(a) : !1, G3(o), { "nav-tabs": i, "card-header-tabs": f && i, "nav-pills": r, "card-header-pills": f && r, "nav-justified": l, "nav-fill": c }), n); return I.createElement(p, nu({}, g, { className: v })) } il.propTypes = K3; var Q3 = ["className", "cssModule", "active", "tag"]; function iu() { return iu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, iu.apply(this, arguments) } function q3(e, t) { if (e == null) return {}; var n = J3(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function J3(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var Z3 = { active: _.bool, className: _.string, cssModule: _.object, tag: pe }; function st(e) { var t = e.className, n = e.cssModule, i = e.active, r = e.tag, s = r === void 0 ? "li" : r, o = q3(e, Q3), a = U(ee(t, "nav-item", i ? "active" : !1), n); return I.createElement(s, iu({}, o, { className: a })) } st.propTypes = Z3; function ru(e) { "@babel/helpers - typeof"; return ru = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, ru(e) } var eb = ["className", "cssModule", "active", "tag", "innerRef"]; function su() { return su = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, su.apply(this, arguments) } function tb(e, t) { if (e == null) return {}; var n = nb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function nb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function ib(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function Ih(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function rb(e, t, n) { return t && Ih(e.prototype, t), n && Ih(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function sb(e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && ou(e, t) } function ou(e, t) { return ou = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (i, r) { return i.__proto__ = r, i }, ou(e, t) } function ob(e) { var t = lb(); return function () { var i = ya(e), r; if (t) { var s = ya(this).constructor; r = Reflect.construct(i, arguments, s) } else r = i.apply(this, arguments); return ab(this, r) } } function ab(e, t) { if (t && (ru(t) === "object" || typeof t == "function")) return t; if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Jm(e) } function Jm(e) { if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function lb() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function ya(e) { return ya = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, ya(e) } var cb = { active: _.bool, className: _.string, cssModule: _.object, disabled: _.bool, href: _.any, innerRef: _.oneOfType([_.object, _.func, _.string]), onClick: _.func, tag: pe }, Zm = function (e) { sb(n, e); var t = ob(n); function n(i) { var r; return ib(this, n), r = t.call(this, i), r.onClick = r.onClick.bind(Jm(r)), r } return rb(n, [{ key: "onClick", value: function (r) { if (this.props.disabled) { r.preventDefault(); return } this.props.href === "#" && r.preventDefault(), this.props.onClick && this.props.onClick(r) } }, { key: "render", value: function () { var r = this.props, s = r.className, o = r.cssModule, a = r.active, l = r.tag, c = l === void 0 ? "a" : l, d = r.innerRef, f = tb(r, eb), h = U(ee(s, "nav-link", { disabled: f.disabled, active: a }), o); return I.createElement(c, su({}, f, { ref: d, onClick: this.onClick, className: h })) } }]), n }(I.Component); Zm.propTypes = cb; const bt = Zm; var ub = ["className", "cssModule", "variant", "innerRef"]; function au() { return au = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, au.apply(this, arguments) } function Fh(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable })), n.push.apply(n, i) } return n } function db(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Fh(Object(n), !0).forEach(function (i) { fb(e, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fh(Object(n)).forEach(function (i) { Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i)) }) } return e } function fb(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function hb(e, t) { if (e == null) return {}; var n = pb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function pb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var gb = { active: _.bool, "aria-label": _.string, onClick: _.func, variant: _.oneOf(["white"]), className: _.string, cssModule: _.object, innerRef: _.oneOfType([_.object, _.string, _.func]) }; function e0(e) { var t = e.className; e.cssModule; var n = e.variant, i = e.innerRef, r = hb(e, ub), s = U(ee(t, "btn-close", n && "btn-close-".concat(n))); return I.createElement("button", au({ ref: i, type: "button", className: s }, db({ "aria-label": "close" }, r))) } e0.propTypes = gb; var mb = ["active", "aria-label", "block", "className", "close", "cssModule", "color", "outline", "size", "tag", "innerRef"]; function lu() { return lu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, lu.apply(this, arguments) } function yb(e, t) { if (e == null) return {}; var n = vb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function vb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var xb = { active: _.bool, "aria-label": _.string, block: _.bool, children: _.node, className: _.string, cssModule: _.object, close: _.bool, color: _.string, disabled: _.bool, innerRef: _.oneOfType([_.object, _.func, _.string]), onClick: _.func, outline: _.bool, size: _.string, tag: pe }; function L(e) { var t = S.useCallback(function (m) { if (e.disabled) { m.preventDefault(); return } if (e.onClick) return e.onClick(m) }, [e.onClick, e.disabled]), n = e.active, i = e["aria-label"], r = e.block, s = e.className, o = e.close, a = e.cssModule, l = e.color, c = l === void 0 ? "secondary" : l, d = e.outline, f = e.size, h = e.tag, p = h === void 0 ? "button" : h, g = e.innerRef, v = yb(e, mb); if (o) return I.createElement(e0, v); var x = "btn".concat(d ? "-outline" : "", "-").concat(c), y = U(ee(s, "btn", x, f ? "btn-".concat(f) : !1, r ? "d-block w-100" : !1, { active: n, disabled: e.disabled }), a); return v.href && p === "button" && (p = "a"), I.createElement(p, lu({ type: p === "button" && v.onClick ? "button" : void 0 }, v, { className: y, ref: g, onClick: t, "aria-label": i })) } L.propTypes = xb; function bb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function cu(e, t) { return cu = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (i, r) { return i.__proto__ = r, i }, cu(e, t) } function _b(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, cu(e, t) } const $h = { disabled: !1 }, t0 = I.createContext(null); var wb = function (t) { return t.scrollTop }, $r = "unmounted", Zn = "exited", ei = "entering", Mi = "entered", uu = "exiting", Lt = function (e) { _b(t, e); function t(i, r) { var s; s = e.call(this, i, r) || this; var o = r, a = o && !o.isMounting ? i.enter : i.appear, l; return s.appearStatus = null, i.in ? a ? (l = Zn, s.appearStatus = ei) : l = Mi : i.unmountOnExit || i.mountOnEnter ? l = $r : l = Zn, s.state = { status: l }, s.nextCallback = null, s } t.getDerivedStateFromProps = function (r, s) { var o = r.in; return o && s.status === $r ? { status: Zn } : null }; var n = t.prototype; return n.componentDidMount = function () { this.updateStatus(!0, this.appearStatus) }, n.componentDidUpdate = function (r) { var s = null; if (r !== this.props) { var o = this.state.status; this.props.in ? o !== ei && o !== Mi && (s = ei) : (o === ei || o === Mi) && (s = uu) } this.updateStatus(!1, s) }, n.componentWillUnmount = function () { this.cancelNextCallback() }, n.getTimeouts = function () { var r = this.props.timeout, s, o, a; return s = o = a = r, r != null && typeof r != "number" && (s = r.exit, o = r.enter, a = r.appear !== void 0 ? r.appear : o), { exit: s, enter: o, appear: a } }, n.updateStatus = function (r, s) { if (r === void 0 && (r = !1), s !== null) if (this.cancelNextCallback(), s === ei) { if (this.props.unmountOnExit || this.props.mountOnEnter) { var o = this.props.nodeRef ? this.props.nodeRef.current : Fr.findDOMNode(this); o && wb(o) } this.performEnter(r) } else this.performExit(); else this.props.unmountOnExit && this.state.status === Zn && this.setState({ status: $r }) }, n.performEnter = function (r) { var s = this, o = this.props.enter, a = this.context ? this.context.isMounting : r, l = this.props.nodeRef ? [a] : [Fr.findDOMNode(this), a], c = l[0], d = l[1], f = this.getTimeouts(), h = a ? f.appear : f.enter; if (!r && !o || $h.disabled) { this.safeSetState({ status: Mi }, function () { s.props.onEntered(c) }); return } this.props.onEnter(c, d), this.safeSetState({ status: ei }, function () { s.props.onEntering(c, d), s.onTransitionEnd(h, function () { s.safeSetState({ status: Mi }, function () { s.props.onEntered(c, d) }) }) }) }, n.performExit = function () { var r = this, s = this.props.exit, o = this.getTimeouts(), a = this.props.nodeRef ? void 0 : Fr.findDOMNode(this); if (!s || $h.disabled) { this.safeSetState({ status: Zn }, function () { r.props.onExited(a) }); return } this.props.onExit(a), this.safeSetState({ status: uu }, function () { r.props.onExiting(a), r.onTransitionEnd(o.exit, function () { r.safeSetState({ status: Zn }, function () { r.props.onExited(a) }) }) }) }, n.cancelNextCallback = function () { this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null) }, n.safeSetState = function (r, s) { s = this.setNextCallback(s), this.setState(r, s) }, n.setNextCallback = function (r) { var s = this, o = !0; return this.nextCallback = function (a) { o && (o = !1, s.nextCallback = null, r(a)) }, this.nextCallback.cancel = function () { o = !1 }, this.nextCallback }, n.onTransitionEnd = function (r, s) { this.setNextCallback(s); var o = this.props.nodeRef ? this.props.nodeRef.current : Fr.findDOMNode(this), a = r == null && !this.props.addEndListener; if (!o || a) { setTimeout(this.nextCallback, 0); return } if (this.props.addEndListener) { var l = this.props.nodeRef ? [this.nextCallback] : [o, this.nextCallback], c = l[0], d = l[1]; this.props.addEndListener(c, d) } r != null && setTimeout(this.nextCallback, r) }, n.render = function () { var r = this.state.status; if (r === $r) return null; var s = this.props, o = s.children; s.in, s.mountOnEnter, s.unmountOnExit, s.appear, s.enter, s.exit, s.timeout, s.addEndListener, s.onEnter, s.onEntering, s.onEntered, s.onExit, s.onExiting, s.onExited, s.nodeRef; var a = bb(s, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]); return I.createElement(t0.Provider, { value: null }, typeof o == "function" ? o(r, a) : I.cloneElement(I.Children.only(o), a)) }, t }(I.Component); Lt.contextType = t0; Lt.propTypes = {}; function ki() { } Lt.defaultProps = { in: !1, mountOnEnter: !1, unmountOnExit: !1, appear: !1, enter: !0, exit: !0, onEnter: ki, onEntering: ki, onEntered: ki, onExit: ki, onExiting: ki, onExited: ki }; Lt.UNMOUNTED = $r; Lt.EXITED = Zn; Lt.ENTERING = ei; Lt.ENTERED = Mi; Lt.EXITING = uu; var jb = ["tag", "baseClass", "baseClassActive", "className", "cssModule", "children", "innerRef"]; function va() { return va = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, va.apply(this, arguments) } function Sb(e, t) { if (e == null) return {}; var n = kb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function kb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function Bh(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable })), n.push.apply(n, i) } return n } function Es(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Bh(Object(n), !0).forEach(function (i) { Cb(e, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bh(Object(n)).forEach(function (i) { Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i)) }) } return e } function Cb(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } var Ob = Es(Es({}, Lt.propTypes), {}, { children: _.oneOfType([_.arrayOf(_.node), _.node]), tag: pe, baseClass: _.string, baseClassActive: _.string, className: _.string, cssModule: _.object, innerRef: _.oneOfType([_.object, _.string, _.func]) }), n0 = Es(Es({}, Lt.defaultProps), {}, { timeout: Qc.Fade, appear: !0, enter: !0, exit: !0, in: !0 }); function oi(e) { var t = S.useRef(null), n = e.tag, i = n === void 0 ? "div" : n, r = e.baseClass, s = r === void 0 ? "fade" : r, o = e.baseClassActive, a = o === void 0 ? "show" : o, l = e.className, c = e.cssModule, d = e.children, f = e.innerRef, h = f === void 0 ? t : f, p = Sb(e, jb), g = u3(Es({ defaultProps: n0 }, p), Rh), v = Qm(p, Rh); return I.createElement(Lt, va({ nodeRef: h }, g), function (x) { var y = x === "entered", m = U(ee(l, s, y && a), c); return I.createElement(i, va({ className: m }, v, { ref: h }), d) }) } oi.propTypes = Ob; oi.defaultProps = n0; var Pb = ["className", "cssModule", "color", "body", "inverse", "outline", "tag", "innerRef"]; function du() { return du = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, du.apply(this, arguments) } function Eb(e, t) { if (e == null) return {}; var n = Mb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function Mb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var Db = { body: _.bool, className: _.string, color: _.string, cssModule: _.object, innerRef: _.oneOfType([_.object, _.string, _.func]), inverse: _.bool, outline: _.bool, tag: pe }; function gr(e) { var t = e.className, n = e.cssModule, i = e.color, r = e.body, s = e.inverse, o = e.outline, a = e.tag, l = a === void 0 ? "div" : a, c = e.innerRef, d = Eb(e, Pb), f = U(ee(t, "card", s ? "text-white" : !1, r ? "card-body" : !1, i ? "".concat(o ? "border" : "bg", "-").concat(i) : !1), n); return I.createElement(l, du({}, d, { className: f, ref: c })) } gr.propTypes = Db; var Tb = ["className", "cssModule", "innerRef", "tag"]; function fu() { return fu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, fu.apply(this, arguments) } function Nb(e, t) { if (e == null) return {}; var n = Rb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function Rb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var zb = { className: _.string, cssModule: _.object, innerRef: _.oneOfType([_.object, _.string, _.func]), tag: pe }; function mr(e) { var t = e.className, n = e.cssModule, i = e.innerRef, r = e.tag, s = r === void 0 ? "div" : r, o = Nb(e, Tb), a = U(ee(t, "card-body"), n); return I.createElement(s, fu({}, o, { className: a, ref: i })) } mr.propTypes = zb; var Lb = ["className", "cssModule", "tag"]; function hu() { return hu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, hu.apply(this, arguments) } function Ab(e, t) { if (e == null) return {}; var n = Ib(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function Ib(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var Fb = { className: _.string, cssModule: _.object, tag: pe }; function yr(e) { var t = e.className, n = e.cssModule, i = e.tag, r = i === void 0 ? "div" : i, s = Ab(e, Lb), o = U(ee(t, "card-subtitle"), n); return I.createElement(r, hu({}, s, { className: o })) } yr.propTypes = Fb; var $b = ["className", "cssModule", "tag"]; function pu() { return pu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, pu.apply(this, arguments) } function Bb(e, t) { if (e == null) return {}; var n = Wb(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function Wb(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var Vb = { className: _.string, cssModule: _.object, tag: pe }; function vr(e) { var t = e.className, n = e.cssModule, i = e.tag, r = i === void 0 ? "div" : i, s = Bb(e, $b), o = U(ee(t, "card-title"), n); return I.createElement(r, pu({}, s, { className: o })) } vr.propTypes = Vb; function gu(e) { "@babel/helpers - typeof"; return gu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, gu(e) } function Ub(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function Wh(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function Hb(e, t, n) { return t && Wh(e.prototype, t), n && Wh(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function Yb(e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && mu(e, t) } function mu(e, t) { return mu = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (i, r) { return i.__proto__ = r, i }, mu(e, t) } function Xb(e) { var t = Qb(); return function () { var i = xa(e), r; if (t) { var s = xa(this).constructor; r = Reflect.construct(i, arguments, s) } else r = i.apply(this, arguments); return Kb(this, r) } } function Kb(e, t) { if (t && (gu(t) === "object" || typeof t == "function")) return t; if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Gb(e) } function Gb(e) { if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function Qb() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function xa(e) { return xa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, xa(e) } var qb = { children: _.node.isRequired, node: _.any }, i0 = function (e) { Yb(n, e); var t = Xb(n); function n() { return Ub(this, n), t.apply(this, arguments) } return Hb(n, [{ key: "componentWillUnmount", value: function () { this.defaultNode && document.body.removeChild(this.defaultNode), this.defaultNode = null } }, { key: "render", value: function () { return Ud ? (!this.props.node && !this.defaultNode && (this.defaultNode = document.createElement("div"), document.body.appendChild(this.defaultNode)), Fr.createPortal(this.props.children, this.props.node || this.defaultNode)) : null } }]), n }(I.Component); i0.propTypes = qb; const Jb = i0; function yu(e) { "@babel/helpers - typeof"; return yu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, yu(e) } function Vh(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable })), n.push.apply(n, i) } return n } function Ci(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}; t % 2 ? Vh(Object(n), !0).forEach(function (i) { Di(e, i, n[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vh(Object(n)).forEach(function (i) { Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i)) }) } return e } function ns() { return ns = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, ns.apply(this, arguments) } function Di(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function Zb(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function Uh(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function e4(e, t, n) { return t && Uh(e.prototype, t), n && Uh(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function t4(e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && vu(e, t) } function vu(e, t) { return vu = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (i, r) { return i.__proto__ = r, i }, vu(e, t) } function n4(e) { var t = r4(); return function () { var i = ba(e), r; if (t) { var s = ba(this).constructor; r = Reflect.construct(i, arguments, s) } else r = i.apply(this, arguments); return i4(this, r) } } function i4(e, t) { if (t && (yu(t) === "object" || typeof t == "function")) return t; if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return yt(e) } function yt(e) { if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function r4() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function ba(e) { return ba = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, ba(e) } function _a() { } var Hh = _.shape(oi.propTypes), r0 = { autoFocus: _.bool, backdrop: _.oneOfType([_.bool, _.oneOf(["static"])]), backdropClassName: _.string, backdropTransition: Hh, centered: _.bool, children: _.node, contentClassName: _.string, className: _.string, container: p3, cssModule: _.object, external: _.node, fade: _.bool, fullscreen: _.oneOfType([_.bool, _.oneOf(["sm", "md", "lg", "xl"])]), innerRef: _.oneOfType([_.object, _.string, _.func]), isOpen: _.bool, keyboard: _.bool, labelledBy: _.string, modalClassName: _.string, modalTransition: Hh, onClosed: _.func, onEnter: _.func, onExit: _.func, onOpened: _.func, returnFocusAfterClose: _.bool, role: _.string, scrollable: _.bool, size: _.string, toggle: _.func, trapFocus: _.bool, unmountOnClose: _.bool, wrapClassName: _.string, zIndex: _.oneOfType([_.number, _.string]) }, s4 = Object.keys(r0), o4 = { isOpen: !1, autoFocus: !0, centered: !1, scrollable: !1, role: "dialog", backdrop: !0, keyboard: !0, zIndex: 1050, fade: !0, onOpened: _a, onClosed: _a, modalTransition: { timeout: Qc.Modal }, backdropTransition: { mountOnEnter: !0, timeout: Qc.Fade }, unmountOnClose: !0, returnFocusAfterClose: !0, container: "body", trapFocus: !1 }, Us = function (e) { t4(n, e); var t = n4(n); function n(i) { var r; return Zb(this, n), r = t.call(this, i), r._element = null, r._originalBodyPadding = null, r.getFocusableChildren = r.getFocusableChildren.bind(yt(r)), r.handleBackdropClick = r.handleBackdropClick.bind(yt(r)), r.handleBackdropMouseDown = r.handleBackdropMouseDown.bind(yt(r)), r.handleEscape = r.handleEscape.bind(yt(r)), r.handleStaticBackdropAnimation = r.handleStaticBackdropAnimation.bind(yt(r)), r.handleTab = r.handleTab.bind(yt(r)), r.onOpened = r.onOpened.bind(yt(r)), r.onClosed = r.onClosed.bind(yt(r)), r.manageFocusAfterClose = r.manageFocusAfterClose.bind(yt(r)), r.clearBackdropAnimationTimeout = r.clearBackdropAnimationTimeout.bind(yt(r)), r.trapFocus = r.trapFocus.bind(yt(r)), r.state = { isOpen: !1, showStaticBackdropAnimation: !1 }, r } return e4(n, [{ key: "componentDidMount", value: function () { var r = this.props, s = r.isOpen, o = r.autoFocus, a = r.onEnter; s && (this.init(), this.setState({ isOpen: !0 }), o && this.setFocus()), a && a(), document.addEventListener("focus", this.trapFocus, !0), this._isMounted = !0 } }, { key: "componentDidUpdate", value: function (r, s) { if (this.props.isOpen && !r.isOpen) { this.init(), this.setState({ isOpen: !0 }); return } this.props.autoFocus && this.state.isOpen && !s.isOpen && this.setFocus(), this._element && r.zIndex !== this.props.zIndex && (this._element.style.zIndex = this.props.zIndex) } }, { key: "componentWillUnmount", value: function () { this.clearBackdropAnimationTimeout(), this.props.onExit && this.props.onExit(), this._element && (this.destroy(), (this.props.isOpen || this.state.isOpen) && this.close()), document.removeEventListener("focus", this.trapFocus, !0), this._isMounted = !1 } }, { key: "handleBackdropClick", value: function (r) { if (r.target === this._mouseDownElement) { r.stopPropagation(); var s = this._dialog ? this._dialog.parentNode : null; if (s && r.target === s && this.props.backdrop === "static" && this.handleStaticBackdropAnimation(), !this.props.isOpen || this.props.backdrop !== !0) return; s && r.target === s && this.props.toggle && this.props.toggle(r) } } }, { key: "handleTab", value: function (r) { if (r.which === 9 && !(this.modalIndex < n.openCount - 1)) { var s = this.getFocusableChildren(), o = s.length; if (o !== 0) { for (var a = this.getFocusedChild(), l = 0, c = 0; c < o; c += 1)if (s[c] === a) { l = c; break } r.shiftKey && l === 0 ? (r.preventDefault(), s[o - 1].focus()) : !r.shiftKey && l === o - 1 && (r.preventDefault(), s[0].focus()) } } } }, { key: "handleBackdropMouseDown", value: function (r) { this._mouseDownElement = r.target } }, { key: "handleEscape", value: function (r) { this.props.isOpen && r.keyCode === g3.esc && this.props.toggle && (this.props.keyboard ? (r.preventDefault(), r.stopPropagation(), this.props.toggle(r)) : this.props.backdrop === "static" && (r.preventDefault(), r.stopPropagation(), this.handleStaticBackdropAnimation())) } }, { key: "handleStaticBackdropAnimation", value: function () { var r = this; this.clearBackdropAnimationTimeout(), this.setState({ showStaticBackdropAnimation: !0 }), this._backdropAnimationTimeout = setTimeout(function () { r.setState({ showStaticBackdropAnimation: !1 }) }, 100) } }, { key: "onOpened", value: function (r, s) { this.props.onOpened(), (this.props.modalTransition.onEntered || _a)(r, s) } }, { key: "onClosed", value: function (r) { var s = this.props.unmountOnClose; this.props.onClosed(), (this.props.modalTransition.onExited || _a)(r), s && this.destroy(), this.close(), this._isMounted && this.setState({ isOpen: !1 }) } }, { key: "setFocus", value: function () { this._dialog && this._dialog.parentNode && typeof this._dialog.parentNode.focus == "function" && this._dialog.parentNode.focus() } }, { key: "getFocusableChildren", value: function () { return this._element.querySelectorAll(_3.join(", ")) } }, { key: "getFocusedChild", value: function () { var r, s = this.getFocusableChildren(); try { r = document.activeElement } catch { r = s[0] } return r } }, { key: "trapFocus", value: function (r) { if (this.props.trapFocus && this._element && !(this._dialog && this._dialog.parentNode === r.target) && !(this.modalIndex < n.openCount - 1)) { for (var s = this.getFocusableChildren(), o = 0; o < s.length; o += 1)if (s[o] === r.target) return; s.length > 0 && (r.preventDefault(), r.stopPropagation(), s[0].focus()) } } }, { key: "init", value: function () { try { this._triggeringElement = document.activeElement } catch { this._triggeringElement = null } this._element || (this._element = document.createElement("div"), this._element.setAttribute("tabindex", "-1"), this._element.style.position = "relative", this._element.style.zIndex = this.props.zIndex, this._mountContainer = b3(this.props.container), this._mountContainer.appendChild(this._element)), this._originalBodyPadding = a3(), n.openCount < 1 && (n.originalBodyOverflow = window.getComputedStyle(document.body).overflow), l3(), n.openCount === 0 && (document.body.className = ee(document.body.className, U("modal-open", this.props.cssModule)), document.body.style.overflow = "hidden"), this.modalIndex = n.openCount, n.openCount += 1 } }, { key: "destroy", value: function () { this._element && (this._mountContainer.removeChild(this._element), this._element = null), this.manageFocusAfterClose() } }, { key: "manageFocusAfterClose", value: function () { if (this._triggeringElement) { var r = this.props.returnFocusAfterClose; this._triggeringElement.focus && r && this._triggeringElement.focus(), this._triggeringElement = null } } }, { key: "close", value: function () { if (n.openCount <= 1) { var r = U("modal-open", this.props.cssModule), s = new RegExp("(^| )".concat(r, "( |$)")); document.body.className = document.body.className.replace(s, " ").trim(), document.body.style.overflow = n.originalBodyOverflow } this.manageFocusAfterClose(), n.openCount = Math.max(0, n.openCount - 1), Gm(this._originalBodyPadding) } }, { key: "clearBackdropAnimationTimeout", value: function () { this._backdropAnimationTimeout && (clearTimeout(this._backdropAnimationTimeout), this._backdropAnimationTimeout = void 0) } }, { key: "renderModalDialog", value: function () { var r, s = this, o = Qm(this.props, s4), a = "modal-dialog"; return I.createElement("div", ns({}, o, { className: U(ee(a, this.props.className, (r = {}, Di(r, "modal-".concat(this.props.size), this.props.size), Di(r, "".concat(a, "-centered"), this.props.centered), Di(r, "".concat(a, "-scrollable"), this.props.scrollable), Di(r, "modal-fullscreen", this.props.fullscreen === !0), Di(r, "modal-fullscreen-".concat(this.props.fullscreen, "-down"), typeof this.props.fullscreen == "string"), r)), this.props.cssModule), role: "document", ref: function (c) { s._dialog = c } }), I.createElement("div", { className: U(ee("modal-content", this.props.contentClassName), this.props.cssModule) }, this.props.children)) } }, { key: "render", value: function () { var r = this.props.unmountOnClose; if (this._element && (this.state.isOpen || !r)) { var s = !!this._element && !this.state.isOpen && !r; this._element.style.display = s ? "none" : "block"; var o = this.props, a = o.wrapClassName, l = o.modalClassName, c = o.backdropClassName, d = o.cssModule, f = o.isOpen, h = o.backdrop, p = o.role, g = o.labelledBy, v = o.external, x = o.innerRef, y = { onClick: this.handleBackdropClick, onMouseDown: this.handleBackdropMouseDown, onKeyUp: this.handleEscape, onKeyDown: this.handleTab, style: { display: "block" }, "aria-labelledby": g, "aria-modal": !0, role: p, tabIndex: "-1" }, m = this.props.fade, b = Ci(Ci(Ci({}, oi.defaultProps), this.props.modalTransition), {}, { baseClass: m ? this.props.modalTransition.baseClass : "", timeout: m ? this.props.modalTransition.timeout : 0 }), j = Ci(Ci(Ci({}, oi.defaultProps), this.props.backdropTransition), {}, { baseClass: m ? this.props.backdropTransition.baseClass : "", timeout: m ? this.props.backdropTransition.timeout : 0 }), w = h && (m ? I.createElement(oi, ns({}, j, { in: f && !!h, cssModule: d, className: U(ee("modal-backdrop", c), d) })) : I.createElement("div", { className: U(ee("modal-backdrop", "show", c), d) })); return I.createElement(Jb, { node: this._element }, I.createElement("div", { className: U(a) }, I.createElement(oi, ns({}, y, b, { in: f, onEntered: this.onOpened, onExited: this.onClosed, cssModule: d, className: U(ee("modal", l, this.state.showStaticBackdropAnimation && "modal-static"), d), innerRef: x }), v, this.renderModalDialog()), w)) } return null } }]), n }(I.Component); Us.propTypes = r0; Us.defaultProps = o4; Us.openCount = 0; Us.originalBodyOverflow = null; const wt = Us; var a4 = ["className", "cssModule", "children", "toggle", "tag", "wrapTag", "closeAriaLabel", "close"]; function xu() { return xu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, xu.apply(this, arguments) } function l4(e, t) { if (e == null) return {}; var n = c4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function c4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var u4 = { children: _.node, className: _.string, close: _.object, closeAriaLabel: _.string, cssModule: _.object, tag: pe, toggle: _.func, wrapTag: pe }; function at(e) { var t, n = e.className, i = e.cssModule, r = e.children, s = e.toggle, o = e.tag, a = o === void 0 ? "h5" : o, l = e.wrapTag, c = l === void 0 ? "div" : l, d = e.closeAriaLabel, f = d === void 0 ? "Close" : d, h = e.close, p = l4(e, a4), g = U(ee(n, "modal-header"), i); return !h && s && (t = I.createElement("button", { type: "button", onClick: s, className: U("btn-close", i), "aria-label": f })), I.createElement(c, xu({}, p, { className: g }), I.createElement(a, { className: U("modal-title", i) }, r), h || t) } at.propTypes = u4; var d4 = ["className", "cssModule", "tag"]; function bu() { return bu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, bu.apply(this, arguments) } function f4(e, t) { if (e == null) return {}; var n = h4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function h4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var p4 = { className: _.string, cssModule: _.object, tag: pe }; function lt(e) { var t = e.className, n = e.cssModule, i = e.tag, r = i === void 0 ? "div" : i, s = f4(e, d4), o = U(ee(t, "modal-body"), n); return I.createElement(r, bu({}, s, { className: o })) } lt.propTypes = p4; var g4 = ["className", "cssModule", "tag"]; function _u() { return _u = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, _u.apply(this, arguments) } function m4(e, t) { if (e == null) return {}; var n = y4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function y4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var v4 = { className: _.string, cssModule: _.object, tag: pe }; function ct(e) { var t = e.className, n = e.cssModule, i = e.tag, r = i === void 0 ? "div" : i, s = m4(e, g4), o = U(ee(t, "modal-footer"), n); return I.createElement(r, _u({}, s, { className: o })) } ct.propTypes = v4; var x4 = ["className", "cssModule", "size", "bordered", "borderless", "striped", "dark", "hover", "responsive", "tag", "responsiveTag", "innerRef"]; function wu() { return wu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, wu.apply(this, arguments) } function b4(e, t) { if (e == null) return {}; var n = _4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function _4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var w4 = { bordered: _.bool, borderless: _.bool, className: _.string, cssModule: _.object, dark: _.bool, hover: _.bool, innerRef: _.oneOfType([_.func, _.string, _.object]), responsive: _.oneOfType([_.bool, _.string]), responsiveTag: pe, size: _.string, striped: _.bool, tag: pe }; function tt(e) { var t = e.className, n = e.cssModule, i = e.size, r = e.bordered, s = e.borderless, o = e.striped, a = e.dark, l = e.hover, c = e.responsive, d = e.tag, f = d === void 0 ? "table" : d, h = e.responsiveTag, p = h === void 0 ? "div" : h, g = e.innerRef, v = b4(e, x4), x = U(ee(t, "table", i ? "table-" + i : !1, r ? "table-bordered" : !1, s ? "table-borderless" : !1, o ? "table-striped" : !1, a ? "table-dark" : !1, l ? "table-hover" : !1), n), y = I.createElement(f, wu({}, v, { ref: g, className: x })); if (c) { var m = U(c === !0 ? "table-responsive" : "table-responsive-".concat(c), n); return I.createElement(p, { className: m }, y) } return y } tt.propTypes = w4; function ju(e) { "@babel/helpers - typeof"; return ju = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, ju(e) } var j4 = ["className", "cssModule", "tag", "innerRef"]; function Su() { return Su = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Su.apply(this, arguments) } function S4(e, t) { if (e == null) return {}; var n = k4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function k4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function C4(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function Yh(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function O4(e, t, n) { return t && Yh(e.prototype, t), n && Yh(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function P4(e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && ku(e, t) } function ku(e, t) { return ku = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (i, r) { return i.__proto__ = r, i }, ku(e, t) } function E4(e) { var t = D4(); return function () { var i = wa(e), r; if (t) { var s = wa(this).constructor; r = Reflect.construct(i, arguments, s) } else r = i.apply(this, arguments); return M4(this, r) } } function M4(e, t) { if (t && (ju(t) === "object" || typeof t == "function")) return t; if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Cu(e) } function Cu(e) { if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function D4() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function wa(e) { return wa = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, wa(e) } var T4 = { children: _.node, tag: pe, innerRef: _.oneOfType([_.object, _.func, _.string]), className: _.string, cssModule: _.object }, s0 = function (e) { P4(n, e); var t = E4(n); function n(i) { var r; return C4(this, n), r = t.call(this, i), r.getRef = r.getRef.bind(Cu(r)), r.submit = r.submit.bind(Cu(r)), r } return O4(n, [{ key: "getRef", value: function (r) { this.props.innerRef && this.props.innerRef(r), this.ref = r } }, { key: "submit", value: function () { this.ref && this.ref.submit() } }, { key: "render", value: function () { var r = this.props, s = r.className, o = r.cssModule, a = r.tag, l = a === void 0 ? "form" : a, c = r.innerRef, d = S4(r, j4), f = U(s, o); return I.createElement(l, Su({}, d, { ref: c, className: f })) } }]), n }(S.Component); s0.propTypes = T4; const Yd = s0; var N4 = ["className", "cssModule", "row", "disabled", "check", "inline", "floating", "noMargin", "tag", "switch"]; function Ou() { return Ou = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Ou.apply(this, arguments) } function R4(e, t) { if (e == null) return {}; var n = z4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function z4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var L4 = { children: _.node, row: _.bool, check: _.bool, switch: _.bool, inline: _.bool, floating: _.bool, noMargin: _.bool, disabled: _.bool, tag: pe, className: _.string, cssModule: _.object }; function Qi(e) { var t = e.className, n = e.cssModule, i = e.row, r = e.disabled, s = e.check, o = e.inline, a = e.floating, l = e.noMargin, c = e.tag, d = c === void 0 ? "div" : c, f = e.switch, h = R4(e, N4), p = s || f, g = U(ee(t, i ? "row" : !1, p ? "form-check" : !1, f ? "form-switch" : !1, p || l ? !1 : "mb-3", p && o ? "form-check-inline" : !1, p && r ? "disabled" : !1, a && "form-floating"), n); return d === "fieldset" && (h.disabled = r), I.createElement(d, Ou({}, h, { className: g })) } Qi.propTypes = L4; function Pu(e) { "@babel/helpers - typeof"; return Pu = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, Pu(e) } var A4 = ["className", "cssModule", "type", "bsSize", "valid", "invalid", "tag", "addon", "plaintext", "innerRef"]; function Eu() { return Eu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Eu.apply(this, arguments) } function I4(e, t) { if (e == null) return {}; var n = F4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function F4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } function $4(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function Xh(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function B4(e, t, n) { return t && Xh(e.prototype, t), n && Xh(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function W4(e, t) { if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && Mu(e, t) } function Mu(e, t) { return Mu = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (i, r) { return i.__proto__ = r, i }, Mu(e, t) } function V4(e) { var t = H4(); return function () { var i = ja(e), r; if (t) { var s = ja(this).constructor; r = Reflect.construct(i, arguments, s) } else r = i.apply(this, arguments); return U4(this, r) } } function U4(e, t) { if (t && (Pu(t) === "object" || typeof t == "function")) return t; if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined"); return Du(e) } function Du(e) { if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function H4() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch { return !1 } } function ja(e) { return ja = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (n) { return n.__proto__ || Object.getPrototypeOf(n) }, ja(e) } var Y4 = { children: _.node, type: _.string, size: _.oneOfType([_.number, _.string]), bsSize: _.string, valid: _.bool, invalid: _.bool, tag: pe, innerRef: _.oneOfType([_.object, _.func, _.string]), plaintext: _.bool, addon: _.bool, className: _.string, cssModule: _.object }, o0 = function (e) { W4(n, e); var t = V4(n); function n(i) { var r; return $4(this, n), r = t.call(this, i), r.getRef = r.getRef.bind(Du(r)), r.focus = r.focus.bind(Du(r)), r } return B4(n, [{ key: "getRef", value: function (r) { this.props.innerRef && this.props.innerRef(r), this.ref = r } }, { key: "focus", value: function () { this.ref && this.ref.focus() } }, { key: "render", value: function () { var r = this.props, s = r.className, o = r.cssModule, a = r.type, l = a === void 0 ? "text" : a, c = r.bsSize, d = r.valid, f = r.invalid, h = r.tag, p = r.addon, g = r.plaintext, v = r.innerRef, x = I4(r, A4), y = ["switch", "radio", "checkbox"].indexOf(l) > -1, m = /\D/g, b = l === "textarea", j = l === "select", w = l === "range", k = h || (j || b ? l : "input"), C = "form-control"; g ? (C = "".concat(C, "-plaintext"), k = h || "input") : w ? C = "form-range" : j ? C = "form-select" : y && (p ? C = null : C = "form-check-input"), x.size && m.test(x.size) && (Gc(`Please use the prop "bsSize" instead of the "size" to bootstrap's input sizing.`), c = x.size, delete x.size); var O = U(ee(s, f && "is-invalid", d && "is-valid", c ? j ? "form-select-".concat(c) : "form-control-".concat(c) : !1, C), o); return (k === "input" || h && typeof h == "function") && (x.type = l === "switch" ? "checkbox" : l), x.children && !(g || l === "select" || typeof k != "string" || k === "select") && (Gc('Input with a type of "'.concat(l, '" cannot have children. Please use "value"/"defaultValue" instead.')), delete x.children), I.createElement(k, Eu({}, x, { ref: v, className: O, "aria-invalid": f })) } }]), n }(I.Component); o0.propTypes = Y4; const V = o0; var X4 = ["className", "cssModule", "hidden", "widths", "tag", "check", "size", "for"]; function Tu() { return Tu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]) } return e }, Tu.apply(this, arguments) } function Fl(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function K4(e, t) { if (e == null) return {}; var n = G4(e, t), i, r; if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++)i = s[r], !(t.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(e, i) && (n[i] = e[i]) } return n } function G4(e, t) { if (e == null) return {}; var n = {}, i = Object.keys(e), r, s; for (s = 0; s < i.length; s++)r = i[s], !(t.indexOf(r) >= 0) && (n[r] = e[r]); return n } var Q4 = ["xs", "sm", "md", "lg", "xl", "xxl"], $l = _.oneOfType([_.number, _.string]), Oi = _.oneOfType([_.bool, _.string, _.number, _.shape({ size: $l, order: $l, offset: $l })]), q4 = { children: _.node, hidden: _.bool, check: _.bool, size: _.string, for: _.string, tag: pe, className: _.string, cssModule: _.object, xs: Oi, sm: Oi, md: Oi, lg: Oi, xl: Oi, xxl: Oi, widths: _.array }, Kh = function (t, n, i) { return i === !0 || i === "" ? t ? "col" : "col-".concat(n) : i === "auto" ? t ? "col-auto" : "col-".concat(n, "-auto") : t ? "col-".concat(i) : "col-".concat(n, "-").concat(i) }; function Bt(e) { var t = e.className, n = e.cssModule, i = e.hidden, r = e.widths, s = r === void 0 ? Q4 : r, o = e.tag, a = o === void 0 ? "label" : o, l = e.check, c = e.size, d = e.for, f = K4(e, X4), h = []; s.forEach(function (x, y) { var m = e[x]; if (delete f[x], !(!m && m !== "")) { var b = !y, j; if (Hd(m)) { var w, k = b ? "-" : "-".concat(x, "-"); j = Kh(b, x, m.size), h.push(U(ee((w = {}, Fl(w, j, m.size || m.size === ""), Fl(w, "order".concat(k).concat(m.order), m.order || m.order === 0), Fl(w, "offset".concat(k).concat(m.offset), m.offset || m.offset === 0), w))), n) } else j = Kh(b, x, m), h.push(j) } }); var p = c || h.length, g = !(l || p), v = U(ee(t, i ? "visually-hidden" : !1, l ? "form-check-label" : !1, c ? "col-form-label-".concat(c) : !1, h, p ? "col-form-label" : !1, g ? "form-label" : !1), n); return I.createElement(a, Tu({ htmlFor: d }, f, { className: v })) } Bt.propTypes = q4; function a0(e) { const [t, n] = S.useState(!1), i = () => n(!t); return u.jsxs("div", { children: [u.jsx("p", { onClick: i, children: "Terms" }), u.jsxs(wt, { isOpen: t, toggle: i, ...e, children: [u.jsx(at, { toggle: i, children: "Modal title" }), u.jsx(lt, { children: "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum." }), u.jsxs(ct, { children: [u.jsx(L, { color: "primary", onClick: i, children: "Do Something" }), " ", u.jsx(L, { color: "secondary", onClick: i, children: "Cancel" })] })] })] }) } function l0() { const [e, t] = S.useState(!1), n = () => { t(!e) }, [i, r] = S.useState(""), [s, o] = S.useState(""), a = d => { const f = d.target.value; r(f) }, l = d => { const f = d.target.value; o(f) }, c = d => { d.preventDefault() }; return u.jsxs("div", { className: "form-container", children: [!e && u.jsxs(Yd, { className: "register-form", onSubmit: c, children: [u.jsx("div", { className: "form-header", children: u.jsx("h2", { children: "Register" }) }), u.jsxs(Qi, { children: [u.jsx(Bt, { children: "Email" }), u.jsx(V, { type: "email", name: "email", id: "email", placeholder: "Enter your school email...", required: !0 })] }), u.jsxs(Qi, { children: [u.jsx("label", { children: "Password" }), u.jsx("input", { type: "password", value: i, name: "password", id: "password", placeholder: "Enter your password...", onChange: a, required: !0 })] }), u.jsxs(Qi, { children: [u.jsx("label", { children: "Confirm password" }), u.jsx("input", { type: "password", value: s, name: "confirm-password", id: "confirm-password", placeholder: "Re-enter your password...", onChange: l, required: !0, pattern: i, title: "Password confirmation does not match" })] }), u.jsxs("div", { className: "term-check-box", children: [u.jsx(V, { type: "checkbox", required: !0 }), " Agree with ", u.jsx(Q, { to: "terms", children: u.jsx(a0, {}) })] }), u.jsx("div", { className: "register-button", children: u.jsx(L, { type: "submit", children: "Sign-up" }) }), u.jsx("div", { className: "form-footer", children: u.jsxs("p", { children: ["Already have an account?.", u.jsx(Q, { to: "/login", onClick: n, children: " Sign in" })] }) })] }), e && u.jsx(Xd, {})] }) } const J4 = [{ id: 1, email: "admin@example.com", password: "admin123", role: "admin" }, { id: 2, email: "manager@example.com", password: "manager123", role: "manager" }, { id: 3, email: "coordinator@example.com", password: "coordinator123", role: "coordinator" }, { id: 4, email: "student@example.com", password: "student123", role: "student" }, { id: 5, email: "guest@example.com", password: "guest123", role: "guest" }]; function Xd() { const [e, t] = S.useState(!1), n = () => { t(!e) }, [i, r] = S.useState(""), [s, o] = S.useState(""), [a, l] = S.useState(""), c = Za(), d = f => { f.preventDefault(); const h = J4.find(p => p.email === i && p.password === s); if (h) { switch (console.log("Login successful!"), console.log(h.role), h.role) { case "admin": c("/admin"); break; case "manager": c("/manager"); break; case "coordinator": c("/coordinator"); break; case "student": c("/user"); break; case "guest": c("/guest"); break }localStorage.setItem("user", JSON.stringify(h)), l("") } else console.error("Login failed!"), l("Incorrect email or password.") }; return u.jsxs("div", { className: "form-container", children: [!e && u.jsxs(Yd, { className: "login-form", onSubmit: d, children: [u.jsx("div", { className: "form-header", children: u.jsx("h2", { children: "Login" }) }), u.jsxs(Qi, { children: [u.jsx(Bt, { children: "Email" }), u.jsx(V, { type: "email", value: i, onChange: f => r(f.target.value), id: "email", placeholder: "Enter your school email...", required: !0 })] }), u.jsxs(Qi, { children: [u.jsx("label", { children: "Password" }), u.jsx("input", { type: "password", value: s, onChange: f => o(f.target.value), id: "password", placeholder: "Enter your password...", required: !0 })] }), u.jsxs("div", { className: "login-button", children: [u.jsx(L, { type: "submit", children: u.jsx("b", { children: "Sign-in" }) }), u.jsxs("p", { children: [" or ", u.jsx(Q, { to: "/register", onClick: n, children: " Register" })] })] }), a && { error: a }, u.jsx("div", { className: "form-footer", children: u.jsxs("p", { children: ["Forgot your password? ", u.jsx(Q, { to: "/reset", children: "Reset now!" })] }) })] }), e && u.jsx(l0, {})] }) } const Z4 = () => u.jsx("footer", { children: u.jsxs("div", { className: "Footer-container", children: [u.jsx("p", { children: u.jsx(Q, { to: "/", children: "Copyright  2024" }) }), u.jsx("p", { children: u.jsx(Q, { to: "/privacy", children: "Privacy & cookies" }) }), u.jsx("p", { children: u.jsx(Q, { to: "/help", children: "Need more help?" }) })] }) }); function e_() { const [e, t] = S.useState(!1), n = () => { t(!e) }; return u.jsxs("div", { className: "homepage-container", children: [u.jsx("div", { className: "homepage-logo" }), u.jsxs("div", { className: "start-button", children: [!e && u.jsx(Q, { to: "/login", children: u.jsx(L, { onClick: n, children: "Start Journey" }) }), u.jsx("div", { className: "form", children: e && u.jsx(Xd, {}) })] }), u.jsx(Z4, {})] }) } function t_() { return u.jsx("div", { children: u.jsx("h1", { children: "About Page" }) }) } function n_() { return u.jsx("div", { children: u.jsx("h1", { children: "Contact Page" }) }) } function i_() { return u.jsx("div", { children: "NotFound" }) } function r_() { return u.jsx("div", { className: "navbar-container", children: u.jsxs(tl, { children: [u.jsx(nl, { children: u.jsx("img", { className: "navbar-logo", src: "src\\assets\\logo.jpg", style: { width: "100%" } }) }), u.jsxs(il, { className: "mr-auto", navbar: !0, children: [u.jsxs(st, { className: "navbar-item", children: [u.jsxs(Q, { to: "dashboard", children: [" ", u.jsx("box-icon", { name: "home" })] }), u.jsx(bt, { tag: Q, to: "dashboard", children: "Home" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsxs(Q, { to: "submission", children: [u.jsx("box-icon", { name: "dock-left" }), " "] }), u.jsx(bt, { tag: Q, to: "submissions", children: "Reports" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "create", children: u.jsx("box-icon", { name: "plus-circle" }) }), u.jsx(bt, { tag: Q, to: "create", children: "Create" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "messages", children: u.jsx("box-icon", { name: "message-rounded-dots" }) }), u.jsx(bt, { tag: Q, to: "profile", children: "Profile" })] })] })] }) }) } function s_() { return u.jsxs("div", { className: "landing-page-container", children: [u.jsx("div", { className: "navbar", children: u.jsx(r_, {}) }), u.jsx("div", { className: "content", children: u.jsx(pr, {}) })] }) } function o_() { return u.jsx("div", { className: "navbar-container", children: u.jsxs(tl, { children: [u.jsx(nl, { children: u.jsx("img", { className: "navbar-logo", src: "src\\assets\\logo.jpg" }) }), u.jsxs(il, { className: "mr-auto", navbar: !0, children: [u.jsxs(st, { className: "navbar-item", children: [u.jsx("box-icon", { name: "home" }), u.jsx(bt, { tag: Q, to: "", children: "Home" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx("box-icon", { type: "solid", name: "dashboard" }), u.jsx(bt, { tag: Q, to: "dashboard", children: "Board" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx("box-icon", { name: "user-circle" }), u.jsx(bt, { tag: Q, to: "profile", children: "Profile" })] })] })] }) }) } function a_() { return u.jsxs("div", { className: "landing-page-container", children: [u.jsx("div", { className: "navbar", children: u.jsx(o_, {}) }), u.jsx("div", { className: "content", children: u.jsx(pr, {}) })] }) } function l_() { return u.jsx("div", { className: "navbar-container", children: u.jsxs(tl, { children: [u.jsx(nl, { children: u.jsx("img", { className: "navbar-logo", src: "https://telegraph-image-bak.pages.dev/file/4416b1da140c3ac1902ce.png" }) }), u.jsxs(il, { className: "mr-auto", navbar: !0, children: [u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "", children: u.jsx("box-icon", { type: "solid", name: "home" }) }), u.jsx(bt, { tag: Q, to: "", children: "Home" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "director", children: u.jsx("box-icon", { type: "solid", name: "user-rectangle" }) }), u.jsx(bt, { tag: Q, to: "director", children: "Directors" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "courses", children: u.jsx("box-icon", { type: "solid", name: "collection" }) }), u.jsx(bt, { tag: Q, to: "courses", children: "Courses" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "classes", children: u.jsx("box-icon", { type: "solid", name: "school" }) }), u.jsx(bt, { tag: Q, to: "classes", children: "Classes" })] }), u.jsxs(st, { className: "navbar-item", children: [u.jsx(Q, { to: "profile", children: u.jsx("box-icon", { name: "user-circle" }) }), u.jsx(bt, { tag: Q, to: "profile", children: "Profile" })] })] })] }) }) } function c_() { return u.jsxs("div", { className: "landing-page-container", children: [u.jsx("div", { className: "navbar", children: u.jsx(l_, {}) }), u.jsx("div", { className: "content", children: u.jsx(pr, {}) })] }) } function u_() { return u.jsxs("div", { className: "dashboard-container", children: [u.jsxs("div", { className: "dashboard-search", children: [u.jsx("box-icon", { name: "search-alt-2" }), u.jsx(V, { type: "search", placeholder: "Search courses here... " })] }), u.jsx("div", { className: "dashboard-content", children: u.jsxs(gr, { style: { width: "18%" }, children: [u.jsx("img", { alt: "Sample", src: "https://picsum.photos/300/200", style: { width: "100%" } }), u.jsxs(mr, { className: "articles-container", children: [u.jsx(vr, { tag: "h2", children: "Class name" }), u.jsx(yr, { className: "mb-2 text-muted", tag: "h3", children: "Class Id" }), u.jsxs(L, { children: ["Detail", u.jsx("box-icon", { name: "link-external" })] })] })] }) })] }) } function d_() { const [e, t] = S.useState(""), [n, i] = S.useState(""), [r, s] = S.useState(""), o = () => { console.log("Searching with the following parameters:"), console.log("Course Name:", e), console.log("Course Date:", n), console.log("Course Status:", r) }; return u.jsx("div", { children: u.jsx("div", { children: u.jsxs(Yd, { className: "search-course-container", children: [u.jsxs("div", { className: "search-input", children: [u.jsx(V, { type: "text", name: "course", id: "course", placeholder: "Enter Course...", onChange: a => t(a.target.value) }), u.jsx(V, { type: "date", name: "date", id: "courseDate", onChange: a => i(a.target.value) }), u.jsxs(V, { type: "select", name: "status", id: "courseStatus", onChange: a => s(a.target.value), children: [u.jsx("option", { children: "Opening" }), u.jsx("option", { children: "Closed" })] })] }), u.jsx(L, { onClick: o, children: " Search" })] }) }) }) } function f_() { return u.jsx("div", { children: "Messages" }) } function Kd() { const e = Za(), t = () => { localStorage.removeItem("user"), e("/login") }; return u.jsx("div", { className: "header", children: u.jsx(L, { onClick: t, children: "Logout" }) }) } function h_() { return u.jsx("div", { children: u.jsx("div", { children: u.jsxs(el, { children: [u.jsx(Vt, { children: u.jsxs(rn, { children: [u.jsx("div", { className: "profile-Header", children: u.jsx("div", { className: "profile-picture" }) }), u.jsx("div", { className: "logout-btn", children: u.jsx(Kd, {}) })] }) }), u.jsx(Vt, { children: u.jsx(rn, { children: u.jsx(tt, { children: u.jsxs("tbody", { children: [u.jsx("tr", { children: u.jsx("th", { children: "ID:" }) }), u.jsx("tr", { children: u.jsx("th", { children: "Name:" }) }), u.jsx("tr", { children: u.jsx("th", { children: "Email:" }) }), u.jsx("tr", { children: u.jsx("th", { children: "Password:" }) })] }) }) }) }), u.jsx(Vt, { children: u.jsx(rn, {}) }), u.jsx(Vt, { children: u.jsx(rn, { children: u.jsxs(tt, { children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Purpose" }), u.jsx("th", { children: "Data submission" }), u.jsx("th", { children: "Status" })] }) }), u.jsxs("tbody", { children: [u.jsxs("tr", { children: [u.jsx("td", { children: "Purpose 1" }), u.jsx("td", { children: "2024-03-04" }), u.jsx("td", { children: "Graded" })] }), u.jsxs("tr", { children: [u.jsx("td", { children: "..." }), u.jsx("td", { children: "..." }), u.jsx("td", { children: "UnGraded" })] })] })] }) }) })] }) }) }) } const p_ = () => u.jsxs("div", { children: [u.jsx("h1", { children: "Coordinator" }), u.jsx("div", { className: "dashboard-content", children: u.jsxs(gr, { style: { width: "18%" }, children: [u.jsx("img", { alt: "Sample", src: "https://picsum.photos/300/200", style: { width: "100%" } }), u.jsxs(mr, { className: "articles-container", children: [u.jsx(vr, { tag: "h2", children: "Class name" }), u.jsx(yr, { className: "mb-2 text-muted", tag: "h3", children: "Course Name" }), u.jsx(L, { children: u.jsxs(Q, { to: "/coordinator/classroom", children: ["Detail", u.jsx("box-icon", { name: "link-external" })] }) })] })] }) })] }); function Gh() { return u.jsxs("div", { children: [u.jsx("h1", { children: "Articles" }), u.jsxs(V, { type: "select", width: "18%", children: [u.jsx("option", { children: "Article 1" }), u.jsx("option", { children: "Article 2" }), u.jsx("option", { children: "Article 3" }), u.jsx("option", { children: "Article 4" }), u.jsx("option", { children: "Article 5" }), u.jsx("option", { children: "Article 6" }), u.jsx("option", { children: "Article 7" }), u.jsx("option", { children: "Article 8" }), u.jsx("option", { children: "Article 9" }), u.jsx("option", { children: "Article 10" }), u.jsx("option", { children: "Article 11" }), u.jsx("option", { children: "Article 12" }), u.jsx("option", { children: "Article 13" }), u.jsx("option", { children: "Article 14" }), u.jsx("option", { children: "Article 15" }), u.jsx("option", { children: "Article 16" }), u.jsx("option", { children: "Article 17" }), u.jsx("option", { children: "Article 18" })] }), u.jsx("div", { className: "ungraded-articles", children: u.jsx("h2", { children: "Ungraded articles" }) }), u.jsx("div", { className: "graded-articles", children: u.jsx("h2", { children: "Graded articles" }) })] }) } function g_() { return u.jsx("div", { children: u.jsx(el, { children: u.jsxs(Vt, { children: [u.jsxs("div", { className: "col-8", children: [u.jsx("h2", { children: "Welcome, Student!" }), u.jsx("h2", { children: "Article Submission" }), u.jsx("p", { children: "Title" }), u.jsx(V, { type: "text", name: "article-title", placeholder: "Enter article title" }), u.jsx("p", { children: "Author name" }), u.jsx(V, { type: "text", name: "author-name", placeholder: "Enter author name" }), u.jsx("p", { children: "Article content" }), u.jsx(V, { className: "article-content", type: "text", placeholder: "Enter article content" }), u.jsx("p", { children: "Upload Article (World document)" }), u.jsx(V, { type: "file", name: "article-file", placeholder: "Choose file" }), u.jsx("p", { children: "Upload Image" }), u.jsx(V, { type: "file", name: "image-file", placeholder: "Choose file" }), u.jsx(V, { type: "checkbox", onChange: e => console.log(e.target.checked) }), " ", u.jsx("strong", { children: "I agree to Terms and Conditions" }), u.jsx(L, { children: "Submit" })] }), u.jsxs("div", { className: "col-4", children: [u.jsx("h2", { children: "Submitted Article" }), u.jsxs(tt, { size: "sm", children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Course" }), u.jsx("th", { children: "Author" })] }) }), u.jsx("tbody", {})] })] })] }) }) }) } function m_() { return u.jsxs("div", { children: [u.jsx("div", {}), u.jsxs(tt, { responsive: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "#" }), u.jsx("th", { children: "Name" }), u.jsx("th", { children: "ID" }), u.jsx("th", { children: "Classroom" }), u.jsx("th", { children: "Mark" }), u.jsx("th", { children: "Createt By" }), u.jsx("th", { children: "Modified By" })] }) }), u.jsxs("tbody", { children: [u.jsxs("tr", { children: [u.jsx("th", { scope: "row", children: "1" }), u.jsx("td", { children: "Table cell" }), u.jsx("td", { children: "Table cell" }), u.jsx("td", { children: u.jsx(L, { children: "SLL" }) }), u.jsx("td", { children: u.jsx(V, { type: "number" }) }), u.jsx("td", { children: u.jsx(L, { children: "Approve" }) }), u.jsx("td", { children: u.jsx(L, { children: "Reject" }) })] }), u.jsxs("tr", { children: [u.jsx("th", { scope: "row", children: "2" }), u.jsx("td", { children: "Table cell" }), u.jsx("td", { children: "Table cell" }), u.jsx("td", { children: u.jsx(L, { children: "Sll" }) }), u.jsx("td", { children: u.jsx(V, { type: "number" }) }), u.jsx("td", { children: u.jsx(L, { children: "Approve" }) }), u.jsx("td", { children: u.jsx(L, { children: "Reject" }) })] }), u.jsxs("tr", { children: [u.jsx("th", { scope: "row", children: "3" }), u.jsx("td", { children: "Table cell" }), u.jsx("td", { children: "Table cell" }), u.jsx("td", { children: u.jsx(L, { children: "Sll" }) }), u.jsx("td", { children: u.jsx(V, { type: "number" }) }), u.jsx("td", { children: u.jsx(L, { children: "Approve" }) }), u.jsx("td", { children: u.jsx(L, { children: "Reject" }) })] })] })] })] }) } function y_() { return u.jsx("div", { children: "Message" }) } function v_() { return u.jsx("div", { children: u.jsx("div", { children: u.jsxs(el, { children: [u.jsx(Vt, { children: u.jsxs(rn, { children: [u.jsx("div", { className: "profile-Header", children: u.jsx("div", { className: "profile-picture" }) }), u.jsx("div", { className: "logout-btn", children: u.jsx(Kd, {}) })] }) }), u.jsx(Vt, { children: u.jsx(rn, { children: u.jsx(tt, { children: u.jsxs("tbody", { children: [u.jsxs("tr", { children: [u.jsx("th", { children: "ID:" }), u.jsx("td", { children: "12345" }), u.jsx("th", { children: "Major:" }), u.jsx("td", { children: "Computer " })] }), u.jsxs("tr", { children: [u.jsx("th", { children: "Name:" }), u.jsx("td", { children: "ABC" }), u.jsx("th", { children: "Class:" }), u.jsx("td", { children: "2024" })] }), u.jsxs("tr", { children: [u.jsx("th", { children: "Email:" }), u.jsx("td", { children: "ABC@example.com" })] })] }) }) }) }), u.jsx(Vt, { children: u.jsx(rn, { children: u.jsxs(tt, { children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Date" }), u.jsx("th", { children: "Attendance" }), u.jsx("th", { children: "Notes" })] }) }), u.jsxs("tbody", { children: [u.jsxs("tr", { children: [u.jsx("td", { children: "2024-03-04" }), u.jsx("td", { children: "Present" }), u.jsx("td", { children: "Notes..." })] }), u.jsxs("tr", { children: [u.jsx("td", { children: "2024-03-04" }), u.jsx("td", { children: "Absent" }), u.jsx("td", { children: "Notes..." })] })] })] }) }) }), u.jsx(Vt, { children: u.jsx(rn, { children: u.jsxs(tt, { children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Purpose" }), u.jsx("th", { children: "Data submission" }), u.jsx("th", { children: "Status" })] }) }), u.jsxs("tbody", { children: [u.jsxs("tr", { children: [u.jsx("td", { children: "Purpose 1" }), u.jsx("td", { children: "2024-03-04" }), u.jsx("td", { children: "Approved" })] }), u.jsxs("tr", { children: [u.jsx("td", { children: "..." }), u.jsx("td", { children: "..." }), u.jsx("td", { children: "Rejected" })] })] })] }) }) })] }) }) }) }/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */function Hs(e) { return e + .5 | 0 } const jn = (e, t, n) => Math.max(Math.min(e, n), t); function Br(e) { return jn(Hs(e * 2.55), 0, 255) } function Ln(e) { return jn(Hs(e * 255), 0, 255) } function en(e) { return jn(Hs(e / 2.55) / 100, 0, 1) } function Qh(e) { return jn(Hs(e * 100), 0, 100) } const mt = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Nu = [..."0123456789ABCDEF"], x_ = e => Nu[e & 15], b_ = e => Nu[(e & 240) >> 4] + Nu[e & 15], fo = e => (e & 240) >> 4 === (e & 15), __ = e => fo(e.r) && fo(e.g) && fo(e.b) && fo(e.a); function w_(e) { var t = e.length, n; return e[0] === "#" && (t === 4 || t === 5 ? n = { r: 255 & mt[e[1]] * 17, g: 255 & mt[e[2]] * 17, b: 255 & mt[e[3]] * 17, a: t === 5 ? mt[e[4]] * 17 : 255 } : (t === 7 || t === 9) && (n = { r: mt[e[1]] << 4 | mt[e[2]], g: mt[e[3]] << 4 | mt[e[4]], b: mt[e[5]] << 4 | mt[e[6]], a: t === 9 ? mt[e[7]] << 4 | mt[e[8]] : 255 })), n } const j_ = (e, t) => e < 255 ? t(e) : ""; function S_(e) { var t = __(e) ? x_ : b_; return e ? "#" + t(e.r) + t(e.g) + t(e.b) + j_(e.a, t) : void 0 } const k_ = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function c0(e, t, n) { const i = t * Math.min(n, 1 - n), r = (s, o = (s + e / 30) % 12) => n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [r(0), r(8), r(4)] } function C_(e, t, n) { const i = (r, s = (r + e / 60) % 6) => n - n * t * Math.max(Math.min(s, 4 - s, 1), 0); return [i(5), i(3), i(1)] } function O_(e, t, n) { const i = c0(e, 1, .5); let r; for (t + n > 1 && (r = 1 / (t + n), t *= r, n *= r), r = 0; r < 3; r++)i[r] *= 1 - t - n, i[r] += t; return i } function P_(e, t, n, i, r) { return e === r ? (t - n) / i + (t < n ? 6 : 0) : t === r ? (n - e) / i + 2 : (e - t) / i + 4 } function Gd(e) { const n = e.r / 255, i = e.g / 255, r = e.b / 255, s = Math.max(n, i, r), o = Math.min(n, i, r), a = (s + o) / 2; let l, c, d; return s !== o && (d = s - o, c = a > .5 ? d / (2 - s - o) : d / (s + o), l = P_(n, i, r, d, s), l = l * 60 + .5), [l | 0, c || 0, a] } function Qd(e, t, n, i) { return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, i)).map(Ln) } function qd(e, t, n) { return Qd(c0, e, t, n) } function E_(e, t, n) { return Qd(O_, e, t, n) } function M_(e, t, n) { return Qd(C_, e, t, n) } function u0(e) { return (e % 360 + 360) % 360 } function D_(e) { const t = k_.exec(e); let n = 255, i; if (!t) return; t[5] !== i && (n = t[6] ? Br(+t[5]) : Ln(+t[5])); const r = u0(+t[2]), s = +t[3] / 100, o = +t[4] / 100; return t[1] === "hwb" ? i = E_(r, s, o) : t[1] === "hsv" ? i = M_(r, s, o) : i = qd(r, s, o), { r: i[0], g: i[1], b: i[2], a: n } } function T_(e, t) { var n = Gd(e); n[0] = u0(n[0] + t), n = qd(n), e.r = n[0], e.g = n[1], e.b = n[2] } function N_(e) { if (!e) return; const t = Gd(e), n = t[0], i = Qh(t[1]), r = Qh(t[2]); return e.a < 255 ? `hsla(${n}, ${i}%, ${r}%, ${en(e.a)})` : `hsl(${n}, ${i}%, ${r}%)` } const qh = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, Jh = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; function R_() { const e = {}, t = Object.keys(Jh), n = Object.keys(qh); let i, r, s, o, a; for (i = 0; i < t.length; i++) { for (o = a = t[i], r = 0; r < n.length; r++)s = n[r], a = a.replace(s, qh[s]); s = parseInt(Jh[o], 16), e[a] = [s >> 16 & 255, s >> 8 & 255, s & 255] } return e } let ho; function z_(e) { ho || (ho = R_(), ho.transparent = [0, 0, 0, 0]); const t = ho[e.toLowerCase()]; return t && { r: t[0], g: t[1], b: t[2], a: t.length === 4 ? t[3] : 255 } } const L_ = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; function A_(e) { const t = L_.exec(e); let n = 255, i, r, s; if (t) { if (t[7] !== i) { const o = +t[7]; n = t[8] ? Br(o) : jn(o * 255, 0, 255) } return i = +t[1], r = +t[3], s = +t[5], i = 255 & (t[2] ? Br(i) : jn(i, 0, 255)), r = 255 & (t[4] ? Br(r) : jn(r, 0, 255)), s = 255 & (t[6] ? Br(s) : jn(s, 0, 255)), { r: i, g: r, b: s, a: n } } } function I_(e) { return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${en(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`) } const Bl = e => e <= .0031308 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - .055, Pi = e => e <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4); function F_(e, t, n) { const i = Pi(en(e.r)), r = Pi(en(e.g)), s = Pi(en(e.b)); return { r: Ln(Bl(i + n * (Pi(en(t.r)) - i))), g: Ln(Bl(r + n * (Pi(en(t.g)) - r))), b: Ln(Bl(s + n * (Pi(en(t.b)) - s))), a: e.a + n * (t.a - e.a) } } function po(e, t, n) { if (e) { let i = Gd(e); i[t] = Math.max(0, Math.min(i[t] + i[t] * n, t === 0 ? 360 : 1)), i = qd(i), e.r = i[0], e.g = i[1], e.b = i[2] } } function d0(e, t) { return e && Object.assign(t || {}, e) } function Zh(e) { var t = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Ln(e[3]))) : (t = d0(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Ln(t.a)), t } function $_(e) { return e.charAt(0) === "r" ? A_(e) : D_(e) } class Ms { constructor(t) { if (t instanceof Ms) return t; const n = typeof t; let i; n === "object" ? i = Zh(t) : n === "string" && (i = w_(t) || z_(t) || $_(t)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var t = d0(this._rgb); return t && (t.a = en(t.a)), t } set rgb(t) { this._rgb = Zh(t) } rgbString() { return this._valid ? I_(this._rgb) : void 0 } hexString() { return this._valid ? S_(this._rgb) : void 0 } hslString() { return this._valid ? N_(this._rgb) : void 0 } mix(t, n) { if (t) { const i = this.rgb, r = t.rgb; let s; const o = n === s ? .5 : n, a = 2 * o - 1, l = i.a - r.a, c = ((a * l === -1 ? a : (a + l) / (1 + a * l)) + 1) / 2; s = 1 - c, i.r = 255 & c * i.r + s * r.r + .5, i.g = 255 & c * i.g + s * r.g + .5, i.b = 255 & c * i.b + s * r.b + .5, i.a = o * i.a + (1 - o) * r.a, this.rgb = i } return this } interpolate(t, n) { return t && (this._rgb = F_(this._rgb, t._rgb, n)), this } clone() { return new Ms(this.rgb) } alpha(t) { return this._rgb.a = Ln(t), this } clearer(t) { const n = this._rgb; return n.a *= 1 - t, this } greyscale() { const t = this._rgb, n = Hs(t.r * .3 + t.g * .59 + t.b * .11); return t.r = t.g = t.b = n, this } opaquer(t) { const n = this._rgb; return n.a *= 1 + t, this } negate() { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this } lighten(t) { return po(this._rgb, 2, t), this } darken(t) { return po(this._rgb, 2, -t), this } saturate(t) { return po(this._rgb, 1, t), this } desaturate(t) { return po(this._rgb, 1, -t), this } rotate(t) { return T_(this._rgb, t), this } }/*!
 * Chart.js v4.4.2
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */function Gt() { } const B_ = (() => { let e = 0; return () => e++ })(); function G(e) { return e === null || typeof e > "u" } function ce(e) { if (Array.isArray && Array.isArray(e)) return !0; const t = Object.prototype.toString.call(e); return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]" } function H(e) { return e !== null && Object.prototype.toString.call(e) === "[object Object]" } function xe(e) { return (typeof e == "number" || e instanceof Number) && isFinite(+e) } function nt(e, t) { return xe(e) ? e : t } function B(e, t) { return typeof e > "u" ? t : e } const W_ = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, f0 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e; function oe(e, t, n) { if (e && typeof e.call == "function") return e.apply(n, t) } function te(e, t, n, i) { let r, s, o; if (ce(e)) if (s = e.length, i) for (r = s - 1; r >= 0; r--)t.call(n, e[r], r); else for (r = 0; r < s; r++)t.call(n, e[r], r); else if (H(e)) for (o = Object.keys(e), s = o.length, r = 0; r < s; r++)t.call(n, e[o[r]], o[r]) } function Sa(e, t) { let n, i, r, s; if (!e || !t || e.length !== t.length) return !1; for (n = 0, i = e.length; n < i; ++n)if (r = e[n], s = t[n], r.datasetIndex !== s.datasetIndex || r.index !== s.index) return !1; return !0 } function ka(e) { if (ce(e)) return e.map(ka); if (H(e)) { const t = Object.create(null), n = Object.keys(e), i = n.length; let r = 0; for (; r < i; ++r)t[n[r]] = ka(e[n[r]]); return t } return e } function h0(e) { return ["__proto__", "prototype", "constructor"].indexOf(e) === -1 } function V_(e, t, n, i) { if (!h0(e)) return; const r = t[e], s = n[e]; H(r) && H(s) ? Ds(r, s, i) : t[e] = ka(s) } function Ds(e, t, n) { const i = ce(t) ? t : [t], r = i.length; if (!H(e)) return e; n = n || {}; const s = n.merger || V_; let o; for (let a = 0; a < r; ++a) { if (o = i[a], !H(o)) continue; const l = Object.keys(o); for (let c = 0, d = l.length; c < d; ++c)s(l[c], e, o, n) } return e } function is(e, t) { return Ds(e, t, { merger: U_ }) } function U_(e, t, n) { if (!h0(e)) return; const i = t[e], r = n[e]; H(i) && H(r) ? is(i, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = ka(r)) } const ep = { "": e => e, x: e => e.x, y: e => e.y }; function H_(e) { const t = e.split("."), n = []; let i = ""; for (const r of t) i += r, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i), i = ""); return n } function Y_(e) { const t = H_(e); return n => { for (const i of t) { if (i === "") break; n = n && n[i] } return n } } function Fn(e, t) { return (ep[t] || (ep[t] = Y_(t)))(e) } function Jd(e) { return e.charAt(0).toUpperCase() + e.slice(1) } const Ts = e => typeof e < "u", $n = e => typeof e == "function", tp = (e, t) => { if (e.size !== t.size) return !1; for (const n of e) if (!t.has(n)) return !1; return !0 }; function X_(e) { return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu" } const fe = Math.PI, de = 2 * fe, K_ = de + fe, Ca = Number.POSITIVE_INFINITY, G_ = fe / 180, we = fe / 2, Xn = fe / 4, np = fe * 2 / 3, Sn = Math.log10, Yt = Math.sign; function rs(e, t, n) { return Math.abs(e - t) < n } function ip(e) { const t = Math.round(e); e = rs(e, t, e / 1e3) ? t : e; const n = Math.pow(10, Math.floor(Sn(e))), i = e / n; return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n } function Q_(e) { const t = [], n = Math.sqrt(e); let i; for (i = 1; i < n; i++)e % i === 0 && (t.push(i), t.push(e / i)); return n === (n | 0) && t.push(n), t.sort((r, s) => r - s).pop(), t } function or(e) { return !isNaN(parseFloat(e)) && isFinite(e) } function q_(e, t) { const n = Math.round(e); return n - t <= e && n + t >= e } function p0(e, t, n) { let i, r, s; for (i = 0, r = e.length; i < r; i++)s = e[i][n], isNaN(s) || (t.min = Math.min(t.min, s), t.max = Math.max(t.max, s)) } function Mt(e) { return e * (fe / 180) } function Zd(e) { return e * (180 / fe) } function rp(e) { if (!xe(e)) return; let t = 1, n = 0; for (; Math.round(e * t) / t !== e;)t *= 10, n++; return n } function g0(e, t) { const n = t.x - e.x, i = t.y - e.y, r = Math.sqrt(n * n + i * i); let s = Math.atan2(i, n); return s < -.5 * fe && (s += de), { angle: s, distance: r } } function Ru(e, t) { return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) } function J_(e, t) { return (e - t + K_) % de - fe } function rt(e) { return (e % de + de) % de } function Ns(e, t, n, i) { const r = rt(e), s = rt(t), o = rt(n), a = rt(s - r), l = rt(o - r), c = rt(r - s), d = rt(r - o); return r === s || r === o || i && s === o || a > l && c < d } function De(e, t, n) { return Math.max(t, Math.min(n, e)) } function Z_(e) { return De(e, -32768, 32767) } function sn(e, t, n, i = 1e-6) { return e >= Math.min(t, n) - i && e <= Math.max(t, n) + i } function ef(e, t, n) { n = n || (o => e[o] < t); let i = e.length - 1, r = 0, s; for (; i - r > 1;)s = r + i >> 1, n(s) ? r = s : i = s; return { lo: r, hi: i } } const on = (e, t, n, i) => ef(e, n, i ? r => { const s = e[r][t]; return s < n || s === n && e[r + 1][t] === n } : r => e[r][t] < n), e5 = (e, t, n) => ef(e, n, i => e[i][t] >= n); function t5(e, t, n) { let i = 0, r = e.length; for (; i < r && e[i] < t;)i++; for (; r > i && e[r - 1] > n;)r--; return i > 0 || r < e.length ? e.slice(i, r) : e } const m0 = ["push", "pop", "shift", "splice", "unshift"]; function n5(e, t) { if (e._chartjs) { e._chartjs.listeners.push(t); return } Object.defineProperty(e, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [t] } }), m0.forEach(n => { const i = "_onData" + Jd(n), r = e[n]; Object.defineProperty(e, n, { configurable: !0, enumerable: !1, value(...s) { const o = r.apply(this, s); return e._chartjs.listeners.forEach(a => { typeof a[i] == "function" && a[i](...s) }), o } }) }) } function sp(e, t) { const n = e._chartjs; if (!n) return; const i = n.listeners, r = i.indexOf(t); r !== -1 && i.splice(r, 1), !(i.length > 0) && (m0.forEach(s => { delete e[s] }), delete e._chartjs) } function y0(e) { const t = new Set(e); return t.size === e.length ? e : Array.from(t) } const v0 = function () { return typeof window > "u" ? function (e) { return e() } : window.requestAnimationFrame }(); function x0(e, t) { let n = [], i = !1; return function (...r) { n = r, i || (i = !0, v0.call(window, () => { i = !1, e.apply(t, n) })) } } function i5(e, t) { let n; return function (...i) { return t ? (clearTimeout(n), n = setTimeout(e, t, i)) : e.apply(this, i), t } } const tf = e => e === "start" ? "left" : e === "end" ? "right" : "center", Fe = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, r5 = (e, t, n, i) => e === (i ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t; function b0(e, t, n) { const i = t.length; let r = 0, s = i; if (e._sorted) { const { iScale: o, _parsed: a } = e, l = o.axis, { min: c, max: d, minDefined: f, maxDefined: h } = o.getUserBounds(); f && (r = De(Math.min(on(a, l, c).lo, n ? i : on(t, l, o.getPixelForValue(c)).lo), 0, i - 1)), h ? s = De(Math.max(on(a, o.axis, d, !0).hi + 1, n ? 0 : on(t, l, o.getPixelForValue(d), !0).hi + 1), r, i) - r : s = i - r } return { start: r, count: s } } function _0(e) { const { xScale: t, yScale: n, _scaleRanges: i } = e, r = { xmin: t.min, xmax: t.max, ymin: n.min, ymax: n.max }; if (!i) return e._scaleRanges = r, !0; const s = i.xmin !== t.min || i.xmax !== t.max || i.ymin !== n.min || i.ymax !== n.max; return Object.assign(i, r), s } const go = e => e === 0 || e === 1, op = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * de / n)), ap = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * de / n) + 1, ss = { linear: e => e, easeInQuad: e => e * e, easeOutQuad: e => -e * (e - 2), easeInOutQuad: e => (e /= .5) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1), easeInCubic: e => e * e * e, easeOutCubic: e => (e -= 1) * e * e + 1, easeInOutCubic: e => (e /= .5) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2), easeInQuart: e => e * e * e * e, easeOutQuart: e => -((e -= 1) * e * e * e - 1), easeInOutQuart: e => (e /= .5) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2), easeInQuint: e => e * e * e * e * e, easeOutQuint: e => (e -= 1) * e * e * e * e + 1, easeInOutQuint: e => (e /= .5) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2), easeInSine: e => -Math.cos(e * we) + 1, easeOutSine: e => Math.sin(e * we), easeInOutSine: e => -.5 * (Math.cos(fe * e) - 1), easeInExpo: e => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)), easeOutExpo: e => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1, easeInOutExpo: e => go(e) ? e : e < .5 ? .5 * Math.pow(2, 10 * (e * 2 - 1)) : .5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2), easeInCirc: e => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1), easeOutCirc: e => Math.sqrt(1 - (e -= 1) * e), easeInOutCirc: e => (e /= .5) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1), easeInElastic: e => go(e) ? e : op(e, .075, .3), easeOutElastic: e => go(e) ? e : ap(e, .075, .3), easeInOutElastic(e) { return go(e) ? e : e < .5 ? .5 * op(e * 2, .1125, .45) : .5 + .5 * ap(e * 2 - 1, .1125, .45) }, easeInBack(e) { return e * e * ((1.70158 + 1) * e - 1.70158) }, easeOutBack(e) { return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1 }, easeInOutBack(e) { let t = 1.70158; return (e /= .5) < 1 ? .5 * (e * e * (((t *= 1.525) + 1) * e - t)) : .5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2) }, easeInBounce: e => 1 - ss.easeOutBounce(1 - e), easeOutBounce(e) { return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375 }, easeInOutBounce: e => e < .5 ? ss.easeInBounce(e * 2) * .5 : ss.easeOutBounce(e * 2 - 1) * .5 + .5 }; function nf(e) { if (e && typeof e == "object") { const t = e.toString(); return t === "[object CanvasPattern]" || t === "[object CanvasGradient]" } return !1 } function lp(e) { return nf(e) ? e : new Ms(e) } function Wl(e) { return nf(e) ? e : new Ms(e).saturate(.5).darken(.1).hexString() } const s5 = ["x", "y", "borderWidth", "radius", "tension"], o5 = ["color", "borderColor", "backgroundColor"]; function a5(e) { e.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }), e.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: t => t !== "onProgress" && t !== "onComplete" && t !== "fn" }), e.set("animations", { colors: { type: "color", properties: o5 }, numbers: { type: "number", properties: s5 } }), e.describe("animations", { _fallback: "animation" }), e.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: t => t | 0 } } } }) } function l5(e) { e.set("layout", { autoPadding: !0, padding: { top: 0, right: 0, bottom: 0, left: 0 } }) } const cp = new Map; function c5(e, t) { t = t || {}; const n = e + JSON.stringify(t); let i = cp.get(n); return i || (i = new Intl.NumberFormat(e, t), cp.set(n, i)), i } function Ys(e, t, n) { return c5(t, n).format(e) } const w0 = { values(e) { return ce(e) ? e : "" + e }, numeric(e, t, n) { if (e === 0) return "0"; const i = this.chart.options.locale; let r, s = e; if (n.length > 1) { const c = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value)); (c < 1e-4 || c > 1e15) && (r = "scientific"), s = u5(e, n) } const o = Sn(Math.abs(s)), a = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = { notation: r, minimumFractionDigits: a, maximumFractionDigits: a }; return Object.assign(l, this.options.ticks.format), Ys(e, i, l) }, logarithmic(e, t, n) { if (e === 0) return "0"; const i = n[t].significand || e / Math.pow(10, Math.floor(Sn(e))); return [1, 2, 3, 5, 10, 15].includes(i) || t > .8 * n.length ? w0.numeric.call(this, e, t, n) : "" } }; function u5(e, t) { let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value; return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n } var rl = { formatters: w0 }; function d5(e) { e.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", clip: !0, grace: 0, grid: { display: !0, lineWidth: 1, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (t, n) => n.lineWidth, tickColor: (t, n) => n.color, offset: !1 }, border: { display: !0, dash: [], dashOffset: 0, width: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: rl.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", { _fallback: !1, _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser", _indexable: t => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash" }), e.describe("scales", { _fallback: "scale" }), e.describe("scale.ticks", { _scriptable: t => t !== "backdropPadding" && t !== "callback", _indexable: t => t !== "backdropPadding" }) } const yi = Object.create(null), zu = Object.create(null); function os(e, t) { if (!t) return e; const n = t.split("."); for (let i = 0, r = n.length; i < r; ++i) { const s = n[i]; e = e[s] || (e[s] = Object.create(null)) } return e } function Vl(e, t, n) { return typeof t == "string" ? Ds(os(e, t), n) : Ds(os(e, ""), t) } class f5 { constructor(t, n) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = i => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (i, r) => Wl(r.backgroundColor), this.hoverBorderColor = (i, r) => Wl(r.borderColor), this.hoverColor = (i, r) => Wl(r.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0, includeInvisible: !1 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n) } set(t, n) { return Vl(this, t, n) } get(t) { return os(this, t) } describe(t, n) { return Vl(zu, t, n) } override(t, n) { return Vl(yi, t, n) } route(t, n, i, r) { const s = os(this, t), o = os(this, i), a = "_" + n; Object.defineProperties(s, { [a]: { value: s[n], writable: !0 }, [n]: { enumerable: !0, get() { const l = this[a], c = o[r]; return H(l) ? Object.assign({}, c, l) : B(l, c) }, set(l) { this[a] = l } } }) } apply(t) { t.forEach(n => n(this)) } } var be = new f5({ _scriptable: e => !e.startsWith("on"), _indexable: e => e !== "events", hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }, [a5, l5, d5]); function h5(e) { return !e || G(e.size) || G(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family } function Oa(e, t, n, i, r) { let s = t[r]; return s || (s = t[r] = e.measureText(r).width, n.push(r)), s > i && (i = s), i } function p5(e, t, n, i) { i = i || {}; let r = i.data = i.data || {}, s = i.garbageCollect = i.garbageCollect || []; i.font !== t && (r = i.data = {}, s = i.garbageCollect = [], i.font = t), e.save(), e.font = t; let o = 0; const a = n.length; let l, c, d, f, h; for (l = 0; l < a; l++)if (f = n[l], f != null && !ce(f)) o = Oa(e, r, s, o, f); else if (ce(f)) for (c = 0, d = f.length; c < d; c++)h = f[c], h != null && !ce(h) && (o = Oa(e, r, s, o, h)); e.restore(); const p = s.length / 2; if (p > n.length) { for (l = 0; l < p; l++)delete r[s[l]]; s.splice(0, p) } return o } function Kn(e, t, n) { const i = e.currentDevicePixelRatio, r = n !== 0 ? Math.max(n / 2, .5) : 0; return Math.round((t - r) * i) / i + r } function up(e, t) { t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore() } function Lu(e, t, n, i) { j0(e, t, n, i, null) } function j0(e, t, n, i, r) { let s, o, a, l, c, d, f, h; const p = t.pointStyle, g = t.rotation, v = t.radius; let x = (g || 0) * G_; if (p && typeof p == "object" && (s = p.toString(), s === "[object HTMLImageElement]" || s === "[object HTMLCanvasElement]")) { e.save(), e.translate(n, i), e.rotate(x), e.drawImage(p, -p.width / 2, -p.height / 2, p.width, p.height), e.restore(); return } if (!(isNaN(v) || v <= 0)) { switch (e.beginPath(), p) { default: r ? e.ellipse(n, i, r / 2, v, 0, 0, de) : e.arc(n, i, v, 0, de), e.closePath(); break; case "triangle": d = r ? r / 2 : v, e.moveTo(n + Math.sin(x) * d, i - Math.cos(x) * v), x += np, e.lineTo(n + Math.sin(x) * d, i - Math.cos(x) * v), x += np, e.lineTo(n + Math.sin(x) * d, i - Math.cos(x) * v), e.closePath(); break; case "rectRounded": c = v * .516, l = v - c, o = Math.cos(x + Xn) * l, f = Math.cos(x + Xn) * (r ? r / 2 - c : l), a = Math.sin(x + Xn) * l, h = Math.sin(x + Xn) * (r ? r / 2 - c : l), e.arc(n - f, i - a, c, x - fe, x - we), e.arc(n + h, i - o, c, x - we, x), e.arc(n + f, i + a, c, x, x + we), e.arc(n - h, i + o, c, x + we, x + fe), e.closePath(); break; case "rect": if (!g) { l = Math.SQRT1_2 * v, d = r ? r / 2 : l, e.rect(n - d, i - l, 2 * d, 2 * l); break } x += Xn; case "rectRot": f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, h = Math.sin(x) * (r ? r / 2 : v), e.moveTo(n - f, i - a), e.lineTo(n + h, i - o), e.lineTo(n + f, i + a), e.lineTo(n - h, i + o), e.closePath(); break; case "crossRot": x += Xn; case "cross": f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, h = Math.sin(x) * (r ? r / 2 : v), e.moveTo(n - f, i - a), e.lineTo(n + f, i + a), e.moveTo(n + h, i - o), e.lineTo(n - h, i + o); break; case "star": f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, h = Math.sin(x) * (r ? r / 2 : v), e.moveTo(n - f, i - a), e.lineTo(n + f, i + a), e.moveTo(n + h, i - o), e.lineTo(n - h, i + o), x += Xn, f = Math.cos(x) * (r ? r / 2 : v), o = Math.cos(x) * v, a = Math.sin(x) * v, h = Math.sin(x) * (r ? r / 2 : v), e.moveTo(n - f, i - a), e.lineTo(n + f, i + a), e.moveTo(n + h, i - o), e.lineTo(n - h, i + o); break; case "line": o = r ? r / 2 : Math.cos(x) * v, a = Math.sin(x) * v, e.moveTo(n - o, i - a), e.lineTo(n + o, i + a); break; case "dash": e.moveTo(n, i), e.lineTo(n + Math.cos(x) * (r ? r / 2 : v), i + Math.sin(x) * v); break; case !1: e.closePath(); break }e.fill(), t.borderWidth > 0 && e.stroke() } } function an(e, t, n) { return n = n || .5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n } function sl(e, t) { e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip() } function ol(e) { e.restore() } function g5(e, t, n, i, r) { if (!t) return e.lineTo(n.x, n.y); if (r === "middle") { const s = (t.x + n.x) / 2; e.lineTo(s, t.y), e.lineTo(s, n.y) } else r === "after" != !!i ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y); e.lineTo(n.x, n.y) } function m5(e, t, n, i) { if (!t) return e.lineTo(n.x, n.y); e.bezierCurveTo(i ? t.cp1x : t.cp2x, i ? t.cp1y : t.cp2y, i ? n.cp2x : n.cp1x, i ? n.cp2y : n.cp1y, n.x, n.y) } function y5(e, t) { t.translation && e.translate(t.translation[0], t.translation[1]), G(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline) } function v5(e, t, n, i, r) { if (r.strikethrough || r.underline) { const s = e.measureText(i), o = t - s.actualBoundingBoxLeft, a = t + s.actualBoundingBoxRight, l = n - s.actualBoundingBoxAscent, c = n + s.actualBoundingBoxDescent, d = r.strikethrough ? (l + c) / 2 : c; e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = r.decorationWidth || 2, e.moveTo(o, d), e.lineTo(a, d), e.stroke() } } function x5(e, t) { const n = e.fillStyle; e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n } function vi(e, t, n, i, r, s = {}) { const o = ce(t) ? t : [t], a = s.strokeWidth > 0 && s.strokeColor !== ""; let l, c; for (e.save(), e.font = r.string, y5(e, s), l = 0; l < o.length; ++l)c = o[l], s.backdrop && x5(e, s.backdrop), a && (s.strokeColor && (e.strokeStyle = s.strokeColor), G(s.strokeWidth) || (e.lineWidth = s.strokeWidth), e.strokeText(c, n, i, s.maxWidth)), e.fillText(c, n, i, s.maxWidth), v5(e, n, i, c, s), i += Number(r.lineHeight); e.restore() } function Rs(e, t) { const { x: n, y: i, w: r, h: s, radius: o } = t; e.arc(n + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * fe, fe, !0), e.lineTo(n, i + s - o.bottomLeft), e.arc(n + o.bottomLeft, i + s - o.bottomLeft, o.bottomLeft, fe, we, !0), e.lineTo(n + r - o.bottomRight, i + s), e.arc(n + r - o.bottomRight, i + s - o.bottomRight, o.bottomRight, we, 0, !0), e.lineTo(n + r, i + o.topRight), e.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -we, !0), e.lineTo(n + o.topLeft, i) } const b5 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, _5 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/; function w5(e, t) { const n = ("" + e).match(b5); if (!n || n[1] === "normal") return t * 1.2; switch (e = +n[2], n[3]) { case "px": return e; case "%": e /= 100; break }return t * e } const j5 = e => +e || 0; function rf(e, t) { const n = {}, i = H(t), r = i ? Object.keys(t) : t, s = H(e) ? i ? o => B(e[o], e[t[o]]) : o => e[o] : () => e; for (const o of r) n[o] = j5(s(o)); return n } function S0(e) { return rf(e, { top: "y", right: "x", bottom: "y", left: "x" }) } function ui(e) { return rf(e, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function Ve(e) { const t = S0(e); return t.width = t.left + t.right, t.height = t.top + t.bottom, t } function Pe(e, t) { e = e || {}, t = t || be.font; let n = B(e.size, t.size); typeof n == "string" && (n = parseInt(n, 10)); let i = B(e.style, t.style); i && !("" + i).match(_5) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0); const r = { family: B(e.family, t.family), lineHeight: w5(B(e.lineHeight, t.lineHeight), n), size: n, style: i, weight: B(e.weight, t.weight), string: "" }; return r.string = h5(r), r } function Wr(e, t, n, i) { let r = !0, s, o, a; for (s = 0, o = e.length; s < o; ++s)if (a = e[s], a !== void 0 && (t !== void 0 && typeof a == "function" && (a = a(t), r = !1), n !== void 0 && ce(a) && (a = a[n % a.length], r = !1), a !== void 0)) return i && !r && (i.cacheable = !1), a } function S5(e, t, n) { const { min: i, max: r } = e, s = f0(t, (r - i) / 2), o = (a, l) => n && a === 0 ? 0 : a + l; return { min: o(i, -Math.abs(s)), max: o(r, s) } } function Hn(e, t) { return Object.assign(Object.create(e), t) } function sf(e, t = [""], n, i, r = () => e[0]) { const s = n || e; typeof i > "u" && (i = P0("_fallback", e)); const o = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: e, _rootScopes: s, _fallback: i, _getTarget: r, override: a => sf([a, ...e], t, s, i) }; return new Proxy(o, { deleteProperty(a, l) { return delete a[l], delete a._keys, delete e[0][l], !0 }, get(a, l) { return C0(a, l, () => T5(l, t, e, a)) }, getOwnPropertyDescriptor(a, l) { return Reflect.getOwnPropertyDescriptor(a._scopes[0], l) }, getPrototypeOf() { return Reflect.getPrototypeOf(e[0]) }, has(a, l) { return fp(a).includes(l) }, ownKeys(a) { return fp(a) }, set(a, l, c) { const d = a._storage || (a._storage = r()); return a[l] = d[l] = c, delete a._keys, !0 } }) } function ar(e, t, n, i) { const r = { _cacheable: !1, _proxy: e, _context: t, _subProxy: n, _stack: new Set, _descriptors: k0(e, i), setContext: s => ar(e, s, n, i), override: s => ar(e.override(s), t, n, i) }; return new Proxy(r, { deleteProperty(s, o) { return delete s[o], delete e[o], !0 }, get(s, o, a) { return C0(s, o, () => C5(s, o, a)) }, getOwnPropertyDescriptor(s, o) { return s._descriptors.allKeys ? Reflect.has(e, o) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(e, o) }, getPrototypeOf() { return Reflect.getPrototypeOf(e) }, has(s, o) { return Reflect.has(e, o) }, ownKeys() { return Reflect.ownKeys(e) }, set(s, o, a) { return e[o] = a, delete s[o], !0 } }) } function k0(e, t = { scriptable: !0, indexable: !0 }) { const { _scriptable: n = t.scriptable, _indexable: i = t.indexable, _allKeys: r = t.allKeys } = e; return { allKeys: r, scriptable: n, indexable: i, isScriptable: $n(n) ? n : () => n, isIndexable: $n(i) ? i : () => i } } const k5 = (e, t) => e ? e + Jd(t) : t, of = (e, t) => H(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object); function C0(e, t, n) { if (Object.prototype.hasOwnProperty.call(e, t)) return e[t]; const i = n(); return e[t] = i, i } function C5(e, t, n) { const { _proxy: i, _context: r, _subProxy: s, _descriptors: o } = e; let a = i[t]; return $n(a) && o.isScriptable(t) && (a = O5(t, a, e, n)), ce(a) && a.length && (a = P5(t, a, e, o.isIndexable)), of(t, a) && (a = ar(a, r, s && s[t], o)), a } function O5(e, t, n, i) { const { _proxy: r, _context: s, _subProxy: o, _stack: a } = n; if (a.has(e)) throw new Error("Recursion detected: " + Array.from(a).join("->") + "->" + e); a.add(e); let l = t(s, o || i); return a.delete(e), of(e, l) && (l = af(r._scopes, r, e, l)), l } function P5(e, t, n, i) { const { _proxy: r, _context: s, _subProxy: o, _descriptors: a } = n; if (typeof s.index < "u" && i(e)) return t[s.index % t.length]; if (H(t[0])) { const l = t, c = r._scopes.filter(d => d !== l); t = []; for (const d of l) { const f = af(c, r, e, d); t.push(ar(f, s, o && o[e], a)) } } return t } function O0(e, t, n) { return $n(e) ? e(t, n) : e } const E5 = (e, t) => e === !0 ? t : typeof e == "string" ? Fn(t, e) : void 0; function M5(e, t, n, i, r) { for (const s of t) { const o = E5(n, s); if (o) { e.add(o); const a = O0(o._fallback, n, r); if (typeof a < "u" && a !== n && a !== i) return a } else if (o === !1 && typeof i < "u" && n !== i) return null } return !1 } function af(e, t, n, i) { const r = t._rootScopes, s = O0(t._fallback, n, i), o = [...e, ...r], a = new Set; a.add(i); let l = dp(a, o, n, s || n, i); return l === null || typeof s < "u" && s !== n && (l = dp(a, o, s, l, i), l === null) ? !1 : sf(Array.from(a), [""], r, s, () => D5(t, n, i)) } function dp(e, t, n, i, r) { for (; n;)n = M5(e, t, n, i, r); return n } function D5(e, t, n) { const i = e._getTarget(); t in i || (i[t] = {}); const r = i[t]; return ce(r) && H(n) ? n : r || {} } function T5(e, t, n, i) { let r; for (const s of t) if (r = P0(k5(s, e), n), typeof r < "u") return of(e, r) ? af(n, i, e, r) : r } function P0(e, t) { for (const n of t) { if (!n) continue; const i = n[e]; if (typeof i < "u") return i } } function fp(e) { let t = e._keys; return t || (t = e._keys = N5(e._scopes)), t } function N5(e) { const t = new Set; for (const n of e) for (const i of Object.keys(n).filter(r => !r.startsWith("_"))) t.add(i); return Array.from(t) } function E0(e, t, n, i) { const { iScale: r } = e, { key: s = "r" } = this._parsing, o = new Array(i); let a, l, c, d; for (a = 0, l = i; a < l; ++a)c = a + n, d = t[c], o[a] = { r: r.parse(Fn(d, s), c) }; return o } const R5 = Number.EPSILON || 1e-14, lr = (e, t) => t < e.length && !e[t].skip && e[t], M0 = e => e === "x" ? "y" : "x"; function z5(e, t, n, i) { const r = e.skip ? t : e, s = t, o = n.skip ? t : n, a = Ru(s, r), l = Ru(o, s); let c = a / (a + l), d = l / (a + l); c = isNaN(c) ? 0 : c, d = isNaN(d) ? 0 : d; const f = i * c, h = i * d; return { previous: { x: s.x - f * (o.x - r.x), y: s.y - f * (o.y - r.y) }, next: { x: s.x + h * (o.x - r.x), y: s.y + h * (o.y - r.y) } } } function L5(e, t, n) { const i = e.length; let r, s, o, a, l, c = lr(e, 0); for (let d = 0; d < i - 1; ++d)if (l = c, c = lr(e, d + 1), !(!l || !c)) { if (rs(t[d], 0, R5)) { n[d] = n[d + 1] = 0; continue } r = n[d] / t[d], s = n[d + 1] / t[d], a = Math.pow(r, 2) + Math.pow(s, 2), !(a <= 9) && (o = 3 / Math.sqrt(a), n[d] = r * o * t[d], n[d + 1] = s * o * t[d]) } } function A5(e, t, n = "x") { const i = M0(n), r = e.length; let s, o, a, l = lr(e, 0); for (let c = 0; c < r; ++c) { if (o = a, a = l, l = lr(e, c + 1), !a) continue; const d = a[n], f = a[i]; o && (s = (d - o[n]) / 3, a[`cp1${n}`] = d - s, a[`cp1${i}`] = f - s * t[c]), l && (s = (l[n] - d) / 3, a[`cp2${n}`] = d + s, a[`cp2${i}`] = f + s * t[c]) } } function I5(e, t = "x") { const n = M0(t), i = e.length, r = Array(i).fill(0), s = Array(i); let o, a, l, c = lr(e, 0); for (o = 0; o < i; ++o)if (a = l, l = c, c = lr(e, o + 1), !!l) { if (c) { const d = c[t] - l[t]; r[o] = d !== 0 ? (c[n] - l[n]) / d : 0 } s[o] = a ? c ? Yt(r[o - 1]) !== Yt(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o] } L5(e, r, s), A5(e, s, t) } function mo(e, t, n) { return Math.max(Math.min(e, n), t) } function F5(e, t) { let n, i, r, s, o, a = an(e[0], t); for (n = 0, i = e.length; n < i; ++n)o = s, s = a, a = n < i - 1 && an(e[n + 1], t), s && (r = e[n], o && (r.cp1x = mo(r.cp1x, t.left, t.right), r.cp1y = mo(r.cp1y, t.top, t.bottom)), a && (r.cp2x = mo(r.cp2x, t.left, t.right), r.cp2y = mo(r.cp2y, t.top, t.bottom))) } function $5(e, t, n, i, r) { let s, o, a, l; if (t.spanGaps && (e = e.filter(c => !c.skip)), t.cubicInterpolationMode === "monotone") I5(e, r); else { let c = i ? e[e.length - 1] : e[0]; for (s = 0, o = e.length; s < o; ++s)a = e[s], l = z5(c, a, e[Math.min(s + 1, o - (i ? 0 : 1)) % o], t.tension), a.cp1x = l.previous.x, a.cp1y = l.previous.y, a.cp2x = l.next.x, a.cp2y = l.next.y, c = a } t.capBezierPoints && F5(e, n) } function lf() { return typeof window < "u" && typeof document < "u" } function cf(e) { let t = e.parentNode; return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t } function Pa(e, t, n) { let i; return typeof e == "string" ? (i = parseInt(e, 10), e.indexOf("%") !== -1 && (i = i / 100 * t.parentNode[n])) : i = e, i } const al = e => e.ownerDocument.defaultView.getComputedStyle(e, null); function B5(e, t) { return al(e).getPropertyValue(t) } const W5 = ["top", "right", "bottom", "left"]; function di(e, t, n) { const i = {}; n = n ? "-" + n : ""; for (let r = 0; r < 4; r++) { const s = W5[r]; i[s] = parseFloat(e[t + "-" + s + n]) || 0 } return i.width = i.left + i.right, i.height = i.top + i.bottom, i } const V5 = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot); function U5(e, t) { const n = e.touches, i = n && n.length ? n[0] : e, { offsetX: r, offsetY: s } = i; let o = !1, a, l; if (V5(r, s, e.target)) a = r, l = s; else { const c = t.getBoundingClientRect(); a = i.clientX - c.left, l = i.clientY - c.top, o = !0 } return { x: a, y: l, box: o } } function ti(e, t) { if ("native" in e) return e; const { canvas: n, currentDevicePixelRatio: i } = t, r = al(n), s = r.boxSizing === "border-box", o = di(r, "padding"), a = di(r, "border", "width"), { x: l, y: c, box: d } = U5(e, n), f = o.left + (d && a.left), h = o.top + (d && a.top); let { width: p, height: g } = t; return s && (p -= o.width + a.width, g -= o.height + a.height), { x: Math.round((l - f) / p * n.width / i), y: Math.round((c - h) / g * n.height / i) } } function H5(e, t, n) { let i, r; if (t === void 0 || n === void 0) { const s = cf(e); if (!s) t = e.clientWidth, n = e.clientHeight; else { const o = s.getBoundingClientRect(), a = al(s), l = di(a, "border", "width"), c = di(a, "padding"); t = o.width - c.width - l.width, n = o.height - c.height - l.height, i = Pa(a.maxWidth, s, "clientWidth"), r = Pa(a.maxHeight, s, "clientHeight") } } return { width: t, height: n, maxWidth: i || Ca, maxHeight: r || Ca } } const yo = e => Math.round(e * 10) / 10; function Y5(e, t, n, i) { const r = al(e), s = di(r, "margin"), o = Pa(r.maxWidth, e, "clientWidth") || Ca, a = Pa(r.maxHeight, e, "clientHeight") || Ca, l = H5(e, t, n); let { width: c, height: d } = l; if (r.boxSizing === "content-box") { const h = di(r, "border", "width"), p = di(r, "padding"); c -= p.width + h.width, d -= p.height + h.height } return c = Math.max(0, c - s.width), d = Math.max(0, i ? c / i : d - s.height), c = yo(Math.min(c, o, l.maxWidth)), d = yo(Math.min(d, a, l.maxHeight)), c && !d && (d = yo(c / 2)), (t !== void 0 || n !== void 0) && i && l.height && d > l.height && (d = l.height, c = yo(Math.floor(d * i))), { width: c, height: d } } function hp(e, t, n) { const i = t || 1, r = Math.floor(e.height * i), s = Math.floor(e.width * i); e.height = Math.floor(e.height), e.width = Math.floor(e.width); const o = e.canvas; return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${e.height}px`, o.style.width = `${e.width}px`), e.currentDevicePixelRatio !== i || o.height !== r || o.width !== s ? (e.currentDevicePixelRatio = i, o.height = r, o.width = s, e.ctx.setTransform(i, 0, 0, i, 0, 0), !0) : !1 } const X5 = function () { let e = !1; try { const t = { get passive() { return e = !0, !1 } }; lf() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t)) } catch { } return e }(); function pp(e, t) { const n = B5(e, t), i = n && n.match(/^(\d+)(\.\d+)?px$/); return i ? +i[1] : void 0 } function ni(e, t, n, i) { return { x: e.x + n * (t.x - e.x), y: e.y + n * (t.y - e.y) } } function K5(e, t, n, i) { return { x: e.x + n * (t.x - e.x), y: i === "middle" ? n < .5 ? e.y : t.y : i === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y } } function G5(e, t, n, i) { const r = { x: e.cp2x, y: e.cp2y }, s = { x: t.cp1x, y: t.cp1y }, o = ni(e, r, n), a = ni(r, s, n), l = ni(s, t, n), c = ni(o, a, n), d = ni(a, l, n); return ni(c, d, n) } const Q5 = function (e, t) { return { x(n) { return e + e + t - n }, setWidth(n) { t = n }, textAlign(n) { return n === "center" ? n : n === "right" ? "left" : "right" }, xPlus(n, i) { return n - i }, leftForLtr(n, i) { return n - i } } }, q5 = function () { return { x(e) { return e }, setWidth(e) { }, textAlign(e) { return e }, xPlus(e, t) { return e + t }, leftForLtr(e, t) { return e } } }; function qi(e, t, n) { return e ? Q5(t, n) : q5() } function D0(e, t) { let n, i; (t === "ltr" || t === "rtl") && (n = e.canvas.style, i = [n.getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", t, "important"), e.prevTextDirection = i) } function T0(e, t) { t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1])) } function N0(e) { return e === "angle" ? { between: Ns, compare: J_, normalize: rt } : { between: sn, compare: (t, n) => t - n, normalize: t => t } } function gp({ start: e, end: t, count: n, loop: i, style: r }) { return { start: e % n, end: t % n, loop: i && (t - e + 1) % n === 0, style: r } } function J5(e, t, n) { const { property: i, start: r, end: s } = n, { between: o, normalize: a } = N0(i), l = t.length; let { start: c, end: d, loop: f } = e, h, p; if (f) { for (c += l, d += l, h = 0, p = l; h < p && o(a(t[c % l][i]), r, s); ++h)c--, d--; c %= l, d %= l } return d < c && (d += l), { start: c, end: d, loop: f, style: e.style } } function R0(e, t, n) { if (!n) return [e]; const { property: i, start: r, end: s } = n, o = t.length, { compare: a, between: l, normalize: c } = N0(i), { start: d, end: f, loop: h, style: p } = J5(e, t, n), g = []; let v = !1, x = null, y, m, b; const j = () => l(r, b, y) && a(r, b) !== 0, w = () => a(s, y) === 0 || l(s, b, y), k = () => v || j(), C = () => !v || w(); for (let O = d, D = d; O <= f; ++O)m = t[O % o], !m.skip && (y = c(m[i]), y !== b && (v = l(y, r, s), x === null && k() && (x = a(y, r) === 0 ? O : D), x !== null && C() && (g.push(gp({ start: x, end: O, loop: h, count: o, style: p })), x = null), D = O, b = y)); return x !== null && g.push(gp({ start: x, end: f, loop: h, count: o, style: p })), g } function z0(e, t) { const n = [], i = e.segments; for (let r = 0; r < i.length; r++) { const s = R0(i[r], e.points, t); s.length && n.push(...s) } return n } function Z5(e, t, n, i) { let r = 0, s = t - 1; if (n && !i) for (; r < t && !e[r].skip;)r++; for (; r < t && e[r].skip;)r++; for (r %= t, n && (s += r); s > r && e[s % t].skip;)s--; return s %= t, { start: r, end: s } } function ew(e, t, n, i) { const r = e.length, s = []; let o = t, a = e[t], l; for (l = t + 1; l <= n; ++l) { const c = e[l % r]; c.skip || c.stop ? a.skip || (i = !1, s.push({ start: t % r, end: (l - 1) % r, loop: i }), t = o = c.stop ? l : null) : (o = l, a.skip && (t = l)), a = c } return o !== null && s.push({ start: t % r, end: o % r, loop: i }), s } function tw(e, t) { const n = e.points, i = e.options.spanGaps, r = n.length; if (!r) return []; const s = !!e._loop, { start: o, end: a } = Z5(n, r, s, i); if (i === !0) return mp(e, [{ start: o, end: a, loop: s }], n, t); const l = a < o ? a + r : a, c = !!e._fullLoop && o === 0 && a === r - 1; return mp(e, ew(n, o, l, c), n, t) } function mp(e, t, n, i) { return !i || !i.setContext || !n ? t : nw(e, t, n, i) } function nw(e, t, n, i) { const r = e._chart.getContext(), s = yp(e.options), { _datasetIndex: o, options: { spanGaps: a } } = e, l = n.length, c = []; let d = s, f = t[0].start, h = f; function p(g, v, x, y) { const m = a ? -1 : 1; if (g !== v) { for (g += l; n[g % l].skip;)g -= m; for (; n[v % l].skip;)v += m; g % l !== v % l && (c.push({ start: g % l, end: v % l, loop: x, style: y }), d = y, f = v % l) } } for (const g of t) { f = a ? f : g.start; let v = n[f % l], x; for (h = f + 1; h <= g.end; h++) { const y = n[h % l]; x = yp(i.setContext(Hn(r, { type: "segment", p0: v, p1: y, p0DataIndex: (h - 1) % l, p1DataIndex: h % l, datasetIndex: o }))), iw(x, d) && p(f, h - 1, g.loop, d), v = y, d = x } f < h - 1 && p(f, h - 1, g.loop, d) } return c } function yp(e) { return { backgroundColor: e.backgroundColor, borderCapStyle: e.borderCapStyle, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderJoinStyle: e.borderJoinStyle, borderWidth: e.borderWidth, borderColor: e.borderColor } } function iw(e, t) { if (!t) return !1; const n = [], i = function (r, s) { return nf(s) ? (n.includes(s) || n.push(s), n.indexOf(s)) : s }; return JSON.stringify(e, i) !== JSON.stringify(t, i) }/*!
 * Chart.js v4.4.2
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */class rw { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(t, n, i, r) { const s = n.listeners[r], o = n.duration; s.forEach(a => a({ chart: t, initial: n.initial, numSteps: o, currentStep: Math.min(i - n.start, o) })) } _refresh() { this._request || (this._running = !0, this._request = v0.call(window, () => { this._update(), this._request = null, this._running && this._refresh() })) } _update(t = Date.now()) { let n = 0; this._charts.forEach((i, r) => { if (!i.running || !i.items.length) return; const s = i.items; let o = s.length - 1, a = !1, l; for (; o >= 0; --o)l = s[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(t), a = !0) : (s[o] = s[s.length - 1], s.pop()); a && (r.draw(), this._notify(r, i, t, "progress")), s.length || (i.running = !1, this._notify(r, i, t, "complete"), i.initial = !1), n += s.length }), this._lastDate = t, n === 0 && (this._running = !1) } _getAnims(t) { const n = this._charts; let i = n.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, n.set(t, i)), i } listen(t, n, i) { this._getAnims(t).listeners[n].push(i) } add(t, n) { !n || !n.length || this._getAnims(t).items.push(...n) } has(t) { return this._getAnims(t).items.length > 0 } start(t) { const n = this._charts.get(t); n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((i, r) => Math.max(i, r._duration), 0), this._refresh()) } running(t) { if (!this._running) return !1; const n = this._charts.get(t); return !(!n || !n.running || !n.items.length) } stop(t) { const n = this._charts.get(t); if (!n || !n.items.length) return; const i = n.items; let r = i.length - 1; for (; r >= 0; --r)i[r].cancel(); n.items = [], this._notify(t, n, Date.now(), "complete") } remove(t) { return this._charts.delete(t) } } var Qt = new rw; const vp = "transparent", sw = { boolean(e, t, n) { return n > .5 ? t : e }, color(e, t, n) { const i = lp(e || vp), r = i.valid && lp(t || vp); return r && r.valid ? r.mix(i, n).hexString() : t }, number(e, t, n) { return e + (t - e) * n } }; class ow { constructor(t, n, i, r) { const s = n[i]; r = Wr([t.to, r, s, t.from]); const o = Wr([t.from, s, r]); this._active = !0, this._fn = t.fn || sw[t.type || typeof o], this._easing = ss[t.easing] || ss.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = i, this._from = o, this._to = r, this._promises = void 0 } active() { return this._active } update(t, n, i) { if (this._active) { this._notify(!1); const r = this._target[this._prop], s = i - this._start, o = this._duration - s; this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += s, this._loop = !!t.loop, this._to = Wr([t.to, n, r, t.from]), this._from = Wr([t.from, r, n]) } } cancel() { this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1)) } tick(t) { const n = t - this._start, i = this._duration, r = this._prop, s = this._from, o = this._loop, a = this._to; let l; if (this._active = s !== a && (o || n < i), !this._active) { this._target[r] = a, this._notify(!0); return } if (n < 0) { this._target[r] = s; return } l = n / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(s, a, l) } wait() { const t = this._promises || (this._promises = []); return new Promise((n, i) => { t.push({ res: n, rej: i }) }) } _notify(t) { const n = t ? "res" : "rej", i = this._promises || []; for (let r = 0; r < i.length; r++)i[r][n]() } } class L0 { constructor(t, n) { this._chart = t, this._properties = new Map, this.configure(n) } configure(t) { if (!H(t)) return; const n = Object.keys(be.animation), i = this._properties; Object.getOwnPropertyNames(t).forEach(r => { const s = t[r]; if (!H(s)) return; const o = {}; for (const a of n) o[a] = s[a]; (ce(s.properties) && s.properties || [r]).forEach(a => { (a === r || !i.has(a)) && i.set(a, o) }) }) } _animateOptions(t, n) { const i = n.options, r = lw(t, i); if (!r) return []; const s = this._createAnimations(r, i); return i.$shared && aw(t.options.$animations, i).then(() => { t.options = i }, () => { }), s } _createAnimations(t, n) { const i = this._properties, r = [], s = t.$animations || (t.$animations = {}), o = Object.keys(n), a = Date.now(); let l; for (l = o.length - 1; l >= 0; --l) { const c = o[l]; if (c.charAt(0) === "$") continue; if (c === "options") { r.push(...this._animateOptions(t, n)); continue } const d = n[c]; let f = s[c]; const h = i.get(c); if (f) if (h && f.active()) { f.update(h, d, a); continue } else f.cancel(); if (!h || !h.duration) { t[c] = d; continue } s[c] = f = new ow(h, t, c, d), r.push(f) } return r } update(t, n) { if (this._properties.size === 0) { Object.assign(t, n); return } const i = this._createAnimations(t, n); if (i.length) return Qt.add(this._chart, i), !0 } } function aw(e, t) { const n = [], i = Object.keys(t); for (let r = 0; r < i.length; r++) { const s = e[i[r]]; s && s.active() && n.push(s.wait()) } return Promise.all(n) } function lw(e, t) { if (!t) return; let n = e.options; if (!n) { e.options = t; return } return n.$shared && (e.options = n = Object.assign({}, n, { $shared: !1, $animations: {} })), n } function xp(e, t) { const n = e && e.options || {}, i = n.reverse, r = n.min === void 0 ? t : 0, s = n.max === void 0 ? t : 0; return { start: i ? s : r, end: i ? r : s } } function cw(e, t, n) { if (n === !1) return !1; const i = xp(e, n), r = xp(t, n); return { top: r.end, right: i.end, bottom: r.start, left: i.start } } function uw(e) { let t, n, i, r; return H(e) ? (t = e.top, n = e.right, i = e.bottom, r = e.left) : t = n = i = r = e, { top: t, right: n, bottom: i, left: r, disabled: e === !1 } } function A0(e, t) { const n = [], i = e._getSortedDatasetMetas(t); let r, s; for (r = 0, s = i.length; r < s; ++r)n.push(i[r].index); return n } function bp(e, t, n, i = {}) { const r = e.keys, s = i.mode === "single"; let o, a, l, c; if (t !== null) { for (o = 0, a = r.length; o < a; ++o) { if (l = +r[o], l === n) { if (i.all) continue; break } c = e.values[l], xe(c) && (s || t === 0 || Yt(t) === Yt(c)) && (t += c) } return t } } function dw(e) { const t = Object.keys(e), n = new Array(t.length); let i, r, s; for (i = 0, r = t.length; i < r; ++i)s = t[i], n[i] = { x: s, y: e[s] }; return n } function _p(e, t) { const n = e && e.options.stacked; return n || n === void 0 && t.stack !== void 0 } function fw(e, t, n) { return `${e.id}.${t.id}.${n.stack || n.type}` } function hw(e) { const { min: t, max: n, minDefined: i, maxDefined: r } = e.getUserBounds(); return { min: i ? t : Number.NEGATIVE_INFINITY, max: r ? n : Number.POSITIVE_INFINITY } } function pw(e, t, n) { const i = e[t] || (e[t] = {}); return i[n] || (i[n] = {}) } function wp(e, t, n, i) { for (const r of t.getMatchingVisibleMetas(i).reverse()) { const s = e[r.index]; if (n && s > 0 || !n && s < 0) return r.index } return null } function jp(e, t) { const { chart: n, _cachedMeta: i } = e, r = n._stacks || (n._stacks = {}), { iScale: s, vScale: o, index: a } = i, l = s.axis, c = o.axis, d = fw(s, o, i), f = t.length; let h; for (let p = 0; p < f; ++p) { const g = t[p], { [l]: v, [c]: x } = g, y = g._stacks || (g._stacks = {}); h = y[c] = pw(r, d, v), h[a] = x, h._top = wp(h, o, !0, i.type), h._bottom = wp(h, o, !1, i.type); const m = h._visualValues || (h._visualValues = {}); m[a] = x } } function Ul(e, t) { const n = e.scales; return Object.keys(n).filter(i => n[i].axis === t).shift() } function gw(e, t) { return Hn(e, { active: !1, dataset: void 0, datasetIndex: t, index: t, mode: "default", type: "dataset" }) } function mw(e, t, n) { return Hn(e, { active: !1, dataIndex: t, parsed: void 0, raw: void 0, element: n, index: t, mode: "default", type: "data" }) } function Er(e, t) { const n = e.controller.index, i = e.vScale && e.vScale.axis; if (i) { t = t || e._parsed; for (const r of t) { const s = r._stacks; if (!s || s[i] === void 0 || s[i][n] === void 0) return; delete s[i][n], s[i]._visualValues !== void 0 && s[i]._visualValues[n] !== void 0 && delete s[i]._visualValues[n] } } } const Hl = e => e === "reset" || e === "none", Sp = (e, t) => t ? e : Object.assign({}, e), yw = (e, t, n) => e && !t.hidden && t._stacked && { keys: A0(n, !0), values: null }; class Nt { constructor(t, n) { this.chart = t, this._ctx = t.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize() } initialize() { const t = this._cachedMeta; this.configure(), this.linkScales(), t._stacked = _p(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options") } updateIndex(t) { this.index !== t && Er(this._cachedMeta), this.index = t } linkScales() { const t = this.chart, n = this._cachedMeta, i = this.getDataset(), r = (f, h, p, g) => f === "x" ? h : f === "r" ? g : p, s = n.xAxisID = B(i.xAxisID, Ul(t, "x")), o = n.yAxisID = B(i.yAxisID, Ul(t, "y")), a = n.rAxisID = B(i.rAxisID, Ul(t, "r")), l = n.indexAxis, c = n.iAxisID = r(l, s, o, a), d = n.vAxisID = r(l, o, s, a); n.xScale = this.getScaleForId(s), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(a), n.iScale = this.getScaleForId(c), n.vScale = this.getScaleForId(d) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(t) { return this.chart.scales[t] } _getOtherScale(t) { const n = this._cachedMeta; return t === n.iScale ? n.vScale : n.iScale } reset() { this._update("reset") } _destroy() { const t = this._cachedMeta; this._data && sp(this._data, this), t._stacked && Er(t) } _dataCheck() { const t = this.getDataset(), n = t.data || (t.data = []), i = this._data; if (H(n)) this._data = dw(n); else if (i !== n) { if (i) { sp(i, this); const r = this._cachedMeta; Er(r), r._parsed = [] } n && Object.isExtensible(n) && n5(n, this), this._syncList = [], this._data = n } } addElements() { const t = this._cachedMeta; this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType) } buildOrUpdateElements(t) { const n = this._cachedMeta, i = this.getDataset(); let r = !1; this._dataCheck(); const s = n._stacked; n._stacked = _p(n.vScale, n), n.stack !== i.stack && (r = !0, Er(n), n.stack = i.stack), this._resyncElements(t), (r || s !== n._stacked) && jp(this, n._parsed) } configure() { const t = this.chart.config, n = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), n, !0); this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {} } parse(t, n) { const { _cachedMeta: i, _data: r } = this, { iScale: s, _stacked: o } = i, a = s.axis; let l = t === 0 && n === r.length ? !0 : i._sorted, c = t > 0 && i._parsed[t - 1], d, f, h; if (this._parsing === !1) i._parsed = r, i._sorted = !0, h = r; else { ce(r[t]) ? h = this.parseArrayData(i, r, t, n) : H(r[t]) ? h = this.parseObjectData(i, r, t, n) : h = this.parsePrimitiveData(i, r, t, n); const p = () => f[a] === null || c && f[a] < c[a]; for (d = 0; d < n; ++d)i._parsed[d + t] = f = h[d], l && (p() && (l = !1), c = f); i._sorted = l } o && jp(this, h) } parsePrimitiveData(t, n, i, r) { const { iScale: s, vScale: o } = t, a = s.axis, l = o.axis, c = s.getLabels(), d = s === o, f = new Array(r); let h, p, g; for (h = 0, p = r; h < p; ++h)g = h + i, f[h] = { [a]: d || s.parse(c[g], g), [l]: o.parse(n[g], g) }; return f } parseArrayData(t, n, i, r) { const { xScale: s, yScale: o } = t, a = new Array(r); let l, c, d, f; for (l = 0, c = r; l < c; ++l)d = l + i, f = n[d], a[l] = { x: s.parse(f[0], d), y: o.parse(f[1], d) }; return a } parseObjectData(t, n, i, r) { const { xScale: s, yScale: o } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = new Array(r); let d, f, h, p; for (d = 0, f = r; d < f; ++d)h = d + i, p = n[h], c[d] = { x: s.parse(Fn(p, a), h), y: o.parse(Fn(p, l), h) }; return c } getParsed(t) { return this._cachedMeta._parsed[t] } getDataElement(t) { return this._cachedMeta.data[t] } applyStack(t, n, i) { const r = this.chart, s = this._cachedMeta, o = n[t.axis], a = { keys: A0(r, !0), values: n._stacks[t.axis]._visualValues }; return bp(a, o, s.index, { mode: i }) } updateRangeFromParsed(t, n, i, r) { const s = i[n.axis]; let o = s === null ? NaN : s; const a = r && i._stacks[n.axis]; r && a && (r.values = a, o = bp(r, s, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o) } getMinMax(t, n) { const i = this._cachedMeta, r = i._parsed, s = i._sorted && t === i.iScale, o = r.length, a = this._getOtherScale(t), l = yw(n, i, this.chart), c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: d, max: f } = hw(a); let h, p; function g() { p = r[h]; const v = p[a.axis]; return !xe(p[t.axis]) || d > v || f < v } for (h = 0; h < o && !(!g() && (this.updateRangeFromParsed(c, t, p, l), s)); ++h); if (s) { for (h = o - 1; h >= 0; --h)if (!g()) { this.updateRangeFromParsed(c, t, p, l); break } } return c } getAllParsedValues(t) { const n = this._cachedMeta._parsed, i = []; let r, s, o; for (r = 0, s = n.length; r < s; ++r)o = n[r][t.axis], xe(o) && i.push(o); return i } getMaxOverflow() { return !1 } getLabelAndValue(t) { const n = this._cachedMeta, i = n.iScale, r = n.vScale, s = this.getParsed(t); return { label: i ? "" + i.getLabelForValue(s[i.axis]) : "", value: r ? "" + r.getLabelForValue(s[r.axis]) : "" } } _update(t) { const n = this._cachedMeta; this.update(t || "default"), n._clip = uw(B(this.options.clip, cw(n.xScale, n.yScale, this.getMaxOverflow()))) } update(t) { } draw() { const t = this._ctx, n = this.chart, i = this._cachedMeta, r = i.data || [], s = n.chartArea, o = [], a = this._drawStart || 0, l = this._drawCount || r.length - a, c = this.options.drawActiveElementsOnTop; let d; for (i.dataset && i.dataset.draw(t, s, a, l), d = a; d < a + l; ++d) { const f = r[d]; f.hidden || (f.active && c ? o.push(f) : f.draw(t, s)) } for (d = 0; d < o.length; ++d)o[d].draw(t, s) } getStyle(t, n) { const i = n ? "active" : "default"; return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i) } getContext(t, n, i) { const r = this.getDataset(); let s; if (t >= 0 && t < this._cachedMeta.data.length) { const o = this._cachedMeta.data[t]; s = o.$context || (o.$context = mw(this.getContext(), t, o)), s.parsed = this.getParsed(t), s.raw = r.data[t], s.index = s.dataIndex = t } else s = this.$context || (this.$context = gw(this.chart.getContext(), this.index)), s.dataset = r, s.index = s.datasetIndex = this.index; return s.active = !!n, s.mode = i, s } resolveDatasetElementOptions(t) { return this._resolveElementOptions(this.datasetElementType.id, t) } resolveDataElementOptions(t, n) { return this._resolveElementOptions(this.dataElementType.id, n, t) } _resolveElementOptions(t, n = "default", i) { const r = n === "active", s = this._cachedDataOpts, o = t + "-" + n, a = s[o], l = this.enableOptionSharing && Ts(i); if (a) return Sp(a, l); const c = this.chart.config, d = c.datasetElementScopeKeys(this._type, t), f = r ? [`${t}Hover`, "hover", t, ""] : [t, ""], h = c.getOptionScopes(this.getDataset(), d), p = Object.keys(be.elements[t]), g = () => this.getContext(i, r, n), v = c.resolveNamedOptions(h, p, g, f); return v.$shared && (v.$shared = l, s[o] = Object.freeze(Sp(v, l))), v } _resolveAnimations(t, n, i) { const r = this.chart, s = this._cachedDataOpts, o = `animation-${n}`, a = s[o]; if (a) return a; let l; if (r.options.animation !== !1) { const d = this.chart.config, f = d.datasetAnimationScopeKeys(this._type, n), h = d.getOptionScopes(this.getDataset(), f); l = d.createResolver(h, this.getContext(t, i, n)) } const c = new L0(r, l && l.animations); return l && l._cacheable && (s[o] = Object.freeze(c)), c } getSharedOptions(t) { if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t)) } includeOptions(t, n) { return !n || Hl(t) || this.chart._animationsDisabled } _getSharedOptions(t, n) { const i = this.resolveDataElementOptions(t, n), r = this._sharedOptions, s = this.getSharedOptions(i), o = this.includeOptions(n, s) || s !== r; return this.updateSharedOptions(s, n, i), { sharedOptions: s, includeOptions: o } } updateElement(t, n, i, r) { Hl(r) ? Object.assign(t, i) : this._resolveAnimations(n, r).update(t, i) } updateSharedOptions(t, n, i) { t && !Hl(n) && this._resolveAnimations(void 0, n).update(t, i) } _setStyle(t, n, i, r) { t.active = r; const s = this.getStyle(n, r); this._resolveAnimations(n, i, r).update(t, { options: !r && this.getSharedOptions(s) || s }) } removeHoverStyle(t, n, i) { this._setStyle(t, i, "active", !1) } setHoverStyle(t, n, i) { this._setStyle(t, i, "active", !0) } _removeDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !1) } _setDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !0) } _resyncElements(t) { const n = this._data, i = this._cachedMeta.data; for (const [a, l, c] of this._syncList) this[a](l, c); this._syncList = []; const r = i.length, s = n.length, o = Math.min(s, r); o && this.parse(0, o), s > r ? this._insertElements(r, s - r, t) : s < r && this._removeElements(s, r - s) } _insertElements(t, n, i = !0) { const r = this._cachedMeta, s = r.data, o = t + n; let a; const l = c => { for (c.length += n, a = c.length - 1; a >= o; a--)c[a] = c[a - n] }; for (l(s), a = t; a < o; ++a)s[a] = new this.dataElementType; this._parsing && l(r._parsed), this.parse(t, n), i && this.updateElements(s, t, n, "reset") } updateElements(t, n, i, r) { } _removeElements(t, n) { const i = this._cachedMeta; if (this._parsing) { const r = i._parsed.splice(t, n); i._stacked && Er(i, r) } i.data.splice(t, n) } _sync(t) { if (this._parsing) this._syncList.push(t); else { const [n, i, r] = t; this[n](i, r) } this.chart._dataChanges.push([this.index, ...t]) } _onDataPush() { const t = arguments.length; this._sync(["_insertElements", this.getDataset().data.length - t, t]) } _onDataPop() { this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._sync(["_removeElements", 0, 1]) } _onDataSplice(t, n) { n && this._sync(["_removeElements", t, n]); const i = arguments.length - 2; i && this._sync(["_insertElements", t, i]) } _onDataUnshift() { this._sync(["_insertElements", 0, arguments.length]) } } E(Nt, "defaults", {}), E(Nt, "datasetElementType", null), E(Nt, "dataElementType", null); function vw(e, t) { if (!e._cache.$bar) { const n = e.getMatchingVisibleMetas(t); let i = []; for (let r = 0, s = n.length; r < s; r++)i = i.concat(n[r].controller.getAllParsedValues(e)); e._cache.$bar = y0(i.sort((r, s) => r - s)) } return e._cache.$bar } function xw(e) { const t = e.iScale, n = vw(t, e.type); let i = t._length, r, s, o, a; const l = () => { o === 32767 || o === -32768 || (Ts(a) && (i = Math.min(i, Math.abs(o - a) || i)), a = o) }; for (r = 0, s = n.length; r < s; ++r)o = t.getPixelForValue(n[r]), l(); for (a = void 0, r = 0, s = t.ticks.length; r < s; ++r)o = t.getPixelForTick(r), l(); return i } function bw(e, t, n, i) { const r = n.barThickness; let s, o; return G(r) ? (s = t.min * n.categoryPercentage, o = n.barPercentage) : (s = r * i, o = 1), { chunk: s / i, ratio: o, start: t.pixels[e] - s / 2 } } function _w(e, t, n, i) { const r = t.pixels, s = r[e]; let o = e > 0 ? r[e - 1] : null, a = e < r.length - 1 ? r[e + 1] : null; const l = n.categoryPercentage; o === null && (o = s - (a === null ? t.end - t.start : a - s)), a === null && (a = s + s - o); const c = s - (s - Math.min(o, a)) / 2 * l; return { chunk: Math.abs(a - o) / 2 * l / i, ratio: n.barPercentage, start: c } } function ww(e, t, n, i) { const r = n.parse(e[0], i), s = n.parse(e[1], i), o = Math.min(r, s), a = Math.max(r, s); let l = o, c = a; Math.abs(o) > Math.abs(a) && (l = a, c = o), t[n.axis] = c, t._custom = { barStart: l, barEnd: c, start: r, end: s, min: o, max: a } } function I0(e, t, n, i) { return ce(e) ? ww(e, t, n, i) : t[n.axis] = n.parse(e, i), t } function kp(e, t, n, i) { const r = e.iScale, s = e.vScale, o = r.getLabels(), a = r === s, l = []; let c, d, f, h; for (c = n, d = n + i; c < d; ++c)h = t[c], f = {}, f[r.axis] = a || r.parse(o[c], c), l.push(I0(h, f, s, c)); return l } function Yl(e) { return e && e.barStart !== void 0 && e.barEnd !== void 0 } function jw(e, t, n) { return e !== 0 ? Yt(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1) } function Sw(e) { let t, n, i, r, s; return e.horizontal ? (t = e.base > e.x, n = "left", i = "right") : (t = e.base < e.y, n = "bottom", i = "top"), t ? (r = "end", s = "start") : (r = "start", s = "end"), { start: n, end: i, reverse: t, top: r, bottom: s } } function kw(e, t, n, i) { let r = t.borderSkipped; const s = {}; if (!r) { e.borderSkipped = s; return } if (r === !0) { e.borderSkipped = { top: !0, right: !0, bottom: !0, left: !0 }; return } const { start: o, end: a, reverse: l, top: c, bottom: d } = Sw(e); r === "middle" && n && (e.enableBorderRadius = !0, (n._top || 0) === i ? r = c : (n._bottom || 0) === i ? r = d : (s[Cp(d, o, a, l)] = !0, r = c)), s[Cp(r, o, a, l)] = !0, e.borderSkipped = s } function Cp(e, t, n, i) { return i ? (e = Cw(e, t, n), e = Op(e, n, t)) : e = Op(e, t, n), e } function Cw(e, t, n) { return e === t ? n : e === n ? t : e } function Op(e, t, n) { return e === "start" ? t : e === "end" ? n : e } function Ow(e, { inflateAmount: t }, n) { e.inflateAmount = t === "auto" ? n === 1 ? .33 : 0 : t } class Ji extends Nt { parsePrimitiveData(t, n, i, r) { return kp(t, n, i, r) } parseArrayData(t, n, i, r) { return kp(t, n, i, r) } parseObjectData(t, n, i, r) { const { iScale: s, vScale: o } = t, { xAxisKey: a = "x", yAxisKey: l = "y" } = this._parsing, c = s.axis === "x" ? a : l, d = o.axis === "x" ? a : l, f = []; let h, p, g, v; for (h = i, p = i + r; h < p; ++h)v = n[h], g = {}, g[s.axis] = s.parse(Fn(v, c), h), f.push(I0(Fn(v, d), g, o, h)); return f } updateRangeFromParsed(t, n, i, r) { super.updateRangeFromParsed(t, n, i, r); const s = i._custom; s && n === this._cachedMeta.vScale && (t.min = Math.min(t.min, s.min), t.max = Math.max(t.max, s.max)) } getMaxOverflow() { return 0 } getLabelAndValue(t) { const n = this._cachedMeta, { iScale: i, vScale: r } = n, s = this.getParsed(t), o = s._custom, a = Yl(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(s[r.axis]); return { label: "" + i.getLabelForValue(s[i.axis]), value: a } } initialize() { this.enableOptionSharing = !0, super.initialize(); const t = this._cachedMeta; t.stack = this.getDataset().stack } update(t) { const n = this._cachedMeta; this.updateElements(n.data, 0, n.data.length, t) } updateElements(t, n, i, r) { const s = r === "reset", { index: o, _cachedMeta: { vScale: a } } = this, l = a.getBasePixel(), c = a.isHorizontal(), d = this._getRuler(), { sharedOptions: f, includeOptions: h } = this._getSharedOptions(n, r); for (let p = n; p < n + i; p++) { const g = this.getParsed(p), v = s || G(g[a.axis]) ? { base: l, head: l } : this._calculateBarValuePixels(p), x = this._calculateBarIndexPixels(p, d), y = (g._stacks || {})[a.axis], m = { horizontal: c, base: v.base, enableBorderRadius: !y || Yl(g._custom) || o === y._top || o === y._bottom, x: c ? v.head : x.center, y: c ? x.center : v.head, height: c ? x.size : Math.abs(v.size), width: c ? Math.abs(v.size) : x.size }; h && (m.options = f || this.resolveDataElementOptions(p, t[p].active ? "active" : r)); const b = m.options || t[p].options; kw(m, b, y, o), Ow(m, b, d.ratio), this.updateElement(t[p], p, m, r) } } _getStacks(t, n) { const { iScale: i } = this._cachedMeta, r = i.getMatchingVisibleMetas(this._type).filter(l => l.controller.options.grouped), s = i.options.stacked, o = [], a = l => { const c = l.controller.getParsed(n), d = c && c[l.vScale.axis]; if (G(d) || isNaN(d)) return !0 }; for (const l of r) if (!(n !== void 0 && a(l)) && ((s === !1 || o.indexOf(l.stack) === -1 || s === void 0 && l.stack === void 0) && o.push(l.stack), l.index === t)) break; return o.length || o.push(void 0), o } _getStackCount(t) { return this._getStacks(void 0, t).length } _getStackIndex(t, n, i) { const r = this._getStacks(t, i), s = n !== void 0 ? r.indexOf(n) : -1; return s === -1 ? r.length - 1 : s } _getRuler() { const t = this.options, n = this._cachedMeta, i = n.iScale, r = []; let s, o; for (s = 0, o = n.data.length; s < o; ++s)r.push(i.getPixelForValue(this.getParsed(s)[i.axis], s)); const a = t.barThickness; return { min: a || xw(n), pixels: r, start: i._startPixel, end: i._endPixel, stackCount: this._getStackCount(), scale: i, grouped: t.grouped, ratio: a ? 1 : t.categoryPercentage * t.barPercentage } } _calculateBarValuePixels(t) { const { _cachedMeta: { vScale: n, _stacked: i, index: r }, options: { base: s, minBarLength: o } } = this, a = s || 0, l = this.getParsed(t), c = l._custom, d = Yl(c); let f = l[n.axis], h = 0, p = i ? this.applyStack(n, l, i) : f, g, v; p !== f && (h = p - f, p = f), d && (f = c.barStart, p = c.barEnd - c.barStart, f !== 0 && Yt(f) !== Yt(c.barEnd) && (h = 0), h += f); const x = !G(s) && !d ? s : h; let y = n.getPixelForValue(x); if (this.chart.getDataVisibility(t) ? g = n.getPixelForValue(h + p) : g = y, v = g - y, Math.abs(v) < o) { v = jw(v, n, a) * o, f === a && (y -= v / 2); const m = n.getPixelForDecimal(0), b = n.getPixelForDecimal(1), j = Math.min(m, b), w = Math.max(m, b); y = Math.max(Math.min(y, w), j), g = y + v, i && !d && (l._stacks[n.axis]._visualValues[r] = n.getValueForPixel(g) - n.getValueForPixel(y)) } if (y === n.getPixelForValue(a)) { const m = Yt(v) * n.getLineWidthForValue(a) / 2; y += m, v -= m } return { size: v, base: y, head: g, center: g + v / 2 } } _calculateBarIndexPixels(t, n) { const i = n.scale, r = this.options, s = r.skipNull, o = B(r.maxBarThickness, 1 / 0); let a, l; if (n.grouped) { const c = s ? this._getStackCount(t) : n.stackCount, d = r.barThickness === "flex" ? _w(t, n, r, c) : bw(t, n, r, c), f = this._getStackIndex(this.index, this._cachedMeta.stack, s ? t : void 0); a = d.start + d.chunk * f + d.chunk / 2, l = Math.min(o, d.chunk * d.ratio) } else a = i.getPixelForValue(this.getParsed(t)[i.axis], t), l = Math.min(o, n.min * n.ratio); return { base: a - l / 2, head: a + l / 2, center: a, size: l } } draw() { const t = this._cachedMeta, n = t.vScale, i = t.data, r = i.length; let s = 0; for (; s < r; ++s)this.getParsed(s)[n.axis] !== null && i[s].draw(this._ctx) } } E(Ji, "id", "bar"), E(Ji, "defaults", { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }), E(Ji, "overrides", { scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }); class Io extends Nt { initialize() { this.enableOptionSharing = !0, super.initialize() } parsePrimitiveData(t, n, i, r) { const s = super.parsePrimitiveData(t, n, i, r); for (let o = 0; o < s.length; o++)s[o]._custom = this.resolveDataElementOptions(o + i).radius; return s } parseArrayData(t, n, i, r) { const s = super.parseArrayData(t, n, i, r); for (let o = 0; o < s.length; o++) { const a = n[i + o]; s[o]._custom = B(a[2], this.resolveDataElementOptions(o + i).radius) } return s } parseObjectData(t, n, i, r) { const s = super.parseObjectData(t, n, i, r); for (let o = 0; o < s.length; o++) { const a = n[i + o]; s[o]._custom = B(a && a.r && +a.r, this.resolveDataElementOptions(o + i).radius) } return s } getMaxOverflow() { const t = this._cachedMeta.data; let n = 0; for (let i = t.length - 1; i >= 0; --i)n = Math.max(n, t[i].size(this.resolveDataElementOptions(i)) / 2); return n > 0 && n } getLabelAndValue(t) { const n = this._cachedMeta, i = this.chart.data.labels || [], { xScale: r, yScale: s } = n, o = this.getParsed(t), a = r.getLabelForValue(o.x), l = s.getLabelForValue(o.y), c = o._custom; return { label: i[t] || "", value: "(" + a + ", " + l + (c ? ", " + c : "") + ")" } } update(t) { const n = this._cachedMeta.data; this.updateElements(n, 0, n.length, t) } updateElements(t, n, i, r) { const s = r === "reset", { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: l, includeOptions: c } = this._getSharedOptions(n, r), d = o.axis, f = a.axis; for (let h = n; h < n + i; h++) { const p = t[h], g = !s && this.getParsed(h), v = {}, x = v[d] = s ? o.getPixelForDecimal(.5) : o.getPixelForValue(g[d]), y = v[f] = s ? a.getBasePixel() : a.getPixelForValue(g[f]); v.skip = isNaN(x) || isNaN(y), c && (v.options = l || this.resolveDataElementOptions(h, p.active ? "active" : r), s && (v.options.radius = 0)), this.updateElement(p, h, v, r) } } resolveDataElementOptions(t, n) { const i = this.getParsed(t); let r = super.resolveDataElementOptions(t, n); r.$shared && (r = Object.assign({}, r, { $shared: !1 })); const s = r.radius; return n !== "active" && (r.radius = 0), r.radius += B(i && i._custom, s), r } } E(Io, "id", "bubble"), E(Io, "defaults", { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }), E(Io, "overrides", { scales: { x: { type: "linear" }, y: { type: "linear" } } }); function Pw(e, t, n) { let i = 1, r = 1, s = 0, o = 0; if (t < de) { const a = e, l = a + t, c = Math.cos(a), d = Math.sin(a), f = Math.cos(l), h = Math.sin(l), p = (b, j, w) => Ns(b, a, l, !0) ? 1 : Math.max(j, j * n, w, w * n), g = (b, j, w) => Ns(b, a, l, !0) ? -1 : Math.min(j, j * n, w, w * n), v = p(0, c, f), x = p(we, d, h), y = g(fe, c, f), m = g(fe + we, d, h); i = (v - y) / 2, r = (x - m) / 2, s = -(v + y) / 2, o = -(x + m) / 2 } return { ratioX: i, ratioY: r, offsetX: s, offsetY: o } } class ai extends Nt { constructor(t, n) { super(t, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(t, n) { const i = this.getDataset().data, r = this._cachedMeta; if (this._parsing === !1) r._parsed = i; else { let s = l => +i[l]; if (H(i[t])) { const { key: l = "value" } = this._parsing; s = c => +Fn(i[c], l) } let o, a; for (o = t, a = t + n; o < a; ++o)r._parsed[o] = s(o) } } _getRotation() { return Mt(this.options.rotation - 90) } _getCircumference() { return Mt(this.options.circumference) } _getRotationExtents() { let t = de, n = -de; for (let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) { const r = this.chart.getDatasetMeta(i).controller, s = r._getRotation(), o = r._getCircumference(); t = Math.min(t, s), n = Math.max(n, s + o) } return { rotation: t, circumference: n - t } } update(t) { const n = this.chart, { chartArea: i } = n, r = this._cachedMeta, s = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(s) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), l = Math.min(W_(this.options.cutout, a), 1), c = this._getRingWeight(this.index), { circumference: d, rotation: f } = this._getRotationExtents(), { ratioX: h, ratioY: p, offsetX: g, offsetY: v } = Pw(f, d, l), x = (i.width - o) / h, y = (i.height - o) / p, m = Math.max(Math.min(x, y) / 2, 0), b = f0(this.options.radius, m), j = Math.max(b * l, 0), w = (b - j) / this._getVisibleDatasetWeightTotal(); this.offsetX = g * b, this.offsetY = v * b, r.total = this.calculateTotal(), this.outerRadius = b - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * c, 0), this.updateElements(s, 0, s.length, t) } _circumference(t, n) { const i = this.options, r = this._cachedMeta, s = this._getCircumference(); return n && i.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * s / de) } updateElements(t, n, i, r) { const s = r === "reset", o = this.chart, a = o.chartArea, c = o.options.animation, d = (a.left + a.right) / 2, f = (a.top + a.bottom) / 2, h = s && c.animateScale, p = h ? 0 : this.innerRadius, g = h ? 0 : this.outerRadius, { sharedOptions: v, includeOptions: x } = this._getSharedOptions(n, r); let y = this._getRotation(), m; for (m = 0; m < n; ++m)y += this._circumference(m, s); for (m = n; m < n + i; ++m) { const b = this._circumference(m, s), j = t[m], w = { x: d + this.offsetX, y: f + this.offsetY, startAngle: y, endAngle: y + b, circumference: b, outerRadius: g, innerRadius: p }; x && (w.options = v || this.resolveDataElementOptions(m, j.active ? "active" : r)), y += b, this.updateElement(j, m, w, r) } } calculateTotal() { const t = this._cachedMeta, n = t.data; let i = 0, r; for (r = 0; r < n.length; r++) { const s = t._parsed[r]; s !== null && !isNaN(s) && this.chart.getDataVisibility(r) && !n[r].hidden && (i += Math.abs(s)) } return i } calculateCircumference(t) { const n = this._cachedMeta.total; return n > 0 && !isNaN(t) ? de * (Math.abs(t) / n) : 0 } getLabelAndValue(t) { const n = this._cachedMeta, i = this.chart, r = i.data.labels || [], s = Ys(n._parsed[t], i.options.locale); return { label: r[t] || "", value: s } } getMaxBorderWidth(t) { let n = 0; const i = this.chart; let r, s, o, a, l; if (!t) { for (r = 0, s = i.data.datasets.length; r < s; ++r)if (i.isDatasetVisible(r)) { o = i.getDatasetMeta(r), t = o.data, a = o.controller; break } } if (!t) return 0; for (r = 0, s = t.length; r < s; ++r)l = a.resolveDataElementOptions(r), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0)); return n } getMaxOffset(t) { let n = 0; for (let i = 0, r = t.length; i < r; ++i) { const s = this.resolveDataElementOptions(i); n = Math.max(n, s.offset || 0, s.hoverOffset || 0) } return n } _getRingWeightOffset(t) { let n = 0; for (let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (n += this._getRingWeight(i)); return n } _getRingWeight(t) { return Math.max(B(this.chart.data.datasets[t].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } E(ai, "id", "doughnut"), E(ai, "defaults", { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", spacing: 0, indexAxis: "r" }), E(ai, "descriptors", { _scriptable: t => t !== "spacing", _indexable: t => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash") }), E(ai, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const n = t.data; if (n.labels.length && n.datasets.length) { const { labels: { pointStyle: i, color: r } } = t.legend.options; return n.labels.map((s, o) => { const l = t.getDatasetMeta(0).controller.getStyle(o); return { text: s, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: r, lineWidth: l.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(o), index: o } }) } return [] } }, onClick(t, n, i) { i.chart.toggleDataVisibility(n.index), i.chart.update() } } } }); class Fo extends Nt { initialize() { this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize() } update(t) { const n = this._cachedMeta, { dataset: i, data: r = [], _dataset: s } = n, o = this.chart._animationsDisabled; let { start: a, count: l } = b0(n, r, o); this._drawStart = a, this._drawCount = l, _0(n) && (a = 0, l = r.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!s._decimated, i.points = r; const c = this.resolveDatasetElementOptions(t); this.options.showLine || (c.borderWidth = 0), c.segment = this.options.segment, this.updateElement(i, void 0, { animated: !o, options: c }, t), this.updateElements(r, a, l, t) } updateElements(t, n, i, r) { const s = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, { sharedOptions: d, includeOptions: f } = this._getSharedOptions(n, r), h = o.axis, p = a.axis, { spanGaps: g, segment: v } = this.options, x = or(g) ? g : Number.POSITIVE_INFINITY, y = this.chart._animationsDisabled || s || r === "none", m = n + i, b = t.length; let j = n > 0 && this.getParsed(n - 1); for (let w = 0; w < b; ++w) { const k = t[w], C = y ? k : {}; if (w < n || w >= m) { C.skip = !0; continue } const O = this.getParsed(w), D = G(O[p]), T = C[h] = o.getPixelForValue(O[h], w), A = C[p] = s || D ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, O, l) : O[p], w); C.skip = isNaN(T) || isNaN(A) || D, C.stop = w > 0 && Math.abs(O[h] - j[h]) > x, v && (C.parsed = O, C.raw = c.data[w]), f && (C.options = d || this.resolveDataElementOptions(w, k.active ? "active" : r)), y || this.updateElement(k, w, C, r), j = O } } getMaxOverflow() { const t = this._cachedMeta, n = t.dataset, i = n.options && n.options.borderWidth || 0, r = t.data || []; if (!r.length) return i; const s = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1)); return Math.max(i, s, o) / 2 } draw() { const t = this._cachedMeta; t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw() } } E(Fo, "id", "line"), E(Fo, "defaults", { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }), E(Fo, "overrides", { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }); class as extends Nt { constructor(t, n) { super(t, n), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(t) { const n = this._cachedMeta, i = this.chart, r = i.data.labels || [], s = Ys(n._parsed[t].r, i.options.locale); return { label: r[t] || "", value: s } } parseObjectData(t, n, i, r) { return E0.bind(this)(t, n, i, r) } update(t) { const n = this._cachedMeta.data; this._updateRadius(), this.updateElements(n, 0, n.length, t) } getMinMax() { const t = this._cachedMeta, n = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }; return t.data.forEach((i, r) => { const s = this.getParsed(r).r; !isNaN(s) && this.chart.getDataVisibility(r) && (s < n.min && (n.min = s), s > n.max && (n.max = s)) }), n } _updateRadius() { const t = this.chart, n = t.chartArea, i = t.options, r = Math.min(n.right - n.left, n.bottom - n.top), s = Math.max(r / 2, 0), o = Math.max(i.cutoutPercentage ? s / 100 * i.cutoutPercentage : 1, 0), a = (s - o) / t.getVisibleDatasetCount(); this.outerRadius = s - a * this.index, this.innerRadius = this.outerRadius - a } updateElements(t, n, i, r) { const s = r === "reset", o = this.chart, l = o.options.animation, c = this._cachedMeta.rScale, d = c.xCenter, f = c.yCenter, h = c.getIndexAngle(0) - .5 * fe; let p = h, g; const v = 360 / this.countVisibleElements(); for (g = 0; g < n; ++g)p += this._computeAngle(g, r, v); for (g = n; g < n + i; g++) { const x = t[g]; let y = p, m = p + this._computeAngle(g, r, v), b = o.getDataVisibility(g) ? c.getDistanceFromCenterForValue(this.getParsed(g).r) : 0; p = m, s && (l.animateScale && (b = 0), l.animateRotate && (y = m = h)); const j = { x: d, y: f, innerRadius: 0, outerRadius: b, startAngle: y, endAngle: m, options: this.resolveDataElementOptions(g, x.active ? "active" : r) }; this.updateElement(x, g, j, r) } } countVisibleElements() { const t = this._cachedMeta; let n = 0; return t.data.forEach((i, r) => { !isNaN(this.getParsed(r).r) && this.chart.getDataVisibility(r) && n++ }), n } _computeAngle(t, n, i) { return this.chart.getDataVisibility(t) ? Mt(this.resolveDataElementOptions(t, n).angle || i) : 0 } } E(as, "id", "polarArea"), E(as, "defaults", { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }), E(as, "overrides", { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const n = t.data; if (n.labels.length && n.datasets.length) { const { labels: { pointStyle: i, color: r } } = t.legend.options; return n.labels.map((s, o) => { const l = t.getDatasetMeta(0).controller.getStyle(o); return { text: s, fillStyle: l.backgroundColor, strokeStyle: l.borderColor, fontColor: r, lineWidth: l.borderWidth, pointStyle: i, hidden: !t.getDataVisibility(o), index: o } }) } return [] } }, onClick(t, n, i) { i.chart.toggleDataVisibility(n.index), i.chart.update() } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }); class Ea extends ai { } E(Ea, "id", "pie"), E(Ea, "defaults", { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }); class $o extends Nt { getLabelAndValue(t) { const n = this._cachedMeta.vScale, i = this.getParsed(t); return { label: n.getLabels()[t], value: "" + n.getLabelForValue(i[n.axis]) } } parseObjectData(t, n, i, r) { return E0.bind(this)(t, n, i, r) } update(t) { const n = this._cachedMeta, i = n.dataset, r = n.data || [], s = n.iScale.getLabels(); if (i.points = r, t !== "resize") { const o = this.resolveDatasetElementOptions(t); this.options.showLine || (o.borderWidth = 0); const a = { _loop: !0, _fullLoop: s.length === r.length, options: o }; this.updateElement(i, void 0, a, t) } this.updateElements(r, 0, r.length, t) } updateElements(t, n, i, r) { const s = this._cachedMeta.rScale, o = r === "reset"; for (let a = n; a < n + i; a++) { const l = t[a], c = this.resolveDataElementOptions(a, l.active ? "active" : r), d = s.getPointPositionForValue(a, this.getParsed(a).r), f = o ? s.xCenter : d.x, h = o ? s.yCenter : d.y, p = { x: f, y: h, angle: d.angle, skip: isNaN(f) || isNaN(h), options: c }; this.updateElement(l, a, p, r) } } } E($o, "id", "radar"), E($o, "defaults", { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }), E($o, "overrides", { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }); class Bo extends Nt { getLabelAndValue(t) { const n = this._cachedMeta, i = this.chart.data.labels || [], { xScale: r, yScale: s } = n, o = this.getParsed(t), a = r.getLabelForValue(o.x), l = s.getLabelForValue(o.y); return { label: i[t] || "", value: "(" + a + ", " + l + ")" } } update(t) { const n = this._cachedMeta, { data: i = [] } = n, r = this.chart._animationsDisabled; let { start: s, count: o } = b0(n, i, r); if (this._drawStart = s, this._drawCount = o, _0(n) && (s = 0, o = i.length), this.options.showLine) { this.datasetElementType || this.addElements(); const { dataset: a, _dataset: l } = n; a._chart = this.chart, a._datasetIndex = this.index, a._decimated = !!l._decimated, a.points = i; const c = this.resolveDatasetElementOptions(t); c.segment = this.options.segment, this.updateElement(a, void 0, { animated: !r, options: c }, t) } else this.datasetElementType && (delete n.dataset, this.datasetElementType = !1); this.updateElements(i, s, o, t) } addElements() { const { showLine: t } = this.options; !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement("line")), super.addElements() } updateElements(t, n, i, r) { const s = r === "reset", { iScale: o, vScale: a, _stacked: l, _dataset: c } = this._cachedMeta, d = this.resolveDataElementOptions(n, r), f = this.getSharedOptions(d), h = this.includeOptions(r, f), p = o.axis, g = a.axis, { spanGaps: v, segment: x } = this.options, y = or(v) ? v : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || s || r === "none"; let b = n > 0 && this.getParsed(n - 1); for (let j = n; j < n + i; ++j) { const w = t[j], k = this.getParsed(j), C = m ? w : {}, O = G(k[g]), D = C[p] = o.getPixelForValue(k[p], j), T = C[g] = s || O ? a.getBasePixel() : a.getPixelForValue(l ? this.applyStack(a, k, l) : k[g], j); C.skip = isNaN(D) || isNaN(T) || O, C.stop = j > 0 && Math.abs(k[p] - b[p]) > y, x && (C.parsed = k, C.raw = c.data[j]), h && (C.options = f || this.resolveDataElementOptions(j, w.active ? "active" : r)), m || this.updateElement(w, j, C, r), b = k } this.updateSharedOptions(f, r, d) } getMaxOverflow() { const t = this._cachedMeta, n = t.data || []; if (!this.options.showLine) { let a = 0; for (let l = n.length - 1; l >= 0; --l)a = Math.max(a, n[l].size(this.resolveDataElementOptions(l)) / 2); return a > 0 && a } const i = t.dataset, r = i.options && i.options.borderWidth || 0; if (!n.length) return r; const s = n[0].size(this.resolveDataElementOptions(0)), o = n[n.length - 1].size(this.resolveDataElementOptions(n.length - 1)); return Math.max(r, s, o) / 2 } } E(Bo, "id", "scatter"), E(Bo, "defaults", { datasetElementType: !1, dataElementType: "point", showLine: !1, fill: !1 }), E(Bo, "overrides", { interaction: { mode: "point" }, scales: { x: { type: "linear" }, y: { type: "linear" } } }); var Ew = Object.freeze({ __proto__: null, BarController: Ji, BubbleController: Io, DoughnutController: ai, LineController: Fo, PieController: Ea, PolarAreaController: as, RadarController: $o, ScatterController: Bo }); function Gn() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } class uf { constructor(t) { E(this, "options"); this.options = t || {} } static override(t) { Object.assign(uf.prototype, t) } init() { } formats() { return Gn() } parse() { return Gn() } format() { return Gn() } add() { return Gn() } diff() { return Gn() } startOf() { return Gn() } endOf() { return Gn() } } var Mw = { _date: uf }; function Dw(e, t, n, i) { const { controller: r, data: s, _sorted: o } = e, a = r._cachedMeta.iScale; if (a && t === a.axis && t !== "r" && o && s.length) { const l = a._reversePixels ? e5 : on; if (i) { if (r._sharedOptions) { const c = s[0], d = typeof c.getRange == "function" && c.getRange(t); if (d) { const f = l(s, t, n - d), h = l(s, t, n + d); return { lo: f.lo, hi: h.hi } } } } else return l(s, t, n) } return { lo: 0, hi: s.length - 1 } } function Xs(e, t, n, i, r) { const s = e.getSortedVisibleDatasetMetas(), o = n[t]; for (let a = 0, l = s.length; a < l; ++a) { const { index: c, data: d } = s[a], { lo: f, hi: h } = Dw(s[a], t, o, r); for (let p = f; p <= h; ++p) { const g = d[p]; g.skip || i(g, c, p) } } } function Tw(e) { const t = e.indexOf("x") !== -1, n = e.indexOf("y") !== -1; return function (i, r) { const s = t ? Math.abs(i.x - r.x) : 0, o = n ? Math.abs(i.y - r.y) : 0; return Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) } } function Xl(e, t, n, i, r) { const s = []; return !r && !e.isPointInArea(t) || Xs(e, n, t, function (a, l, c) { !r && !an(a, e.chartArea, 0) || a.inRange(t.x, t.y, i) && s.push({ element: a, datasetIndex: l, index: c }) }, !0), s } function Nw(e, t, n, i) { let r = []; function s(o, a, l) { const { startAngle: c, endAngle: d } = o.getProps(["startAngle", "endAngle"], i), { angle: f } = g0(o, { x: t.x, y: t.y }); Ns(f, c, d) && r.push({ element: o, datasetIndex: a, index: l }) } return Xs(e, n, t, s), r } function Rw(e, t, n, i, r, s) { let o = []; const a = Tw(n); let l = Number.POSITIVE_INFINITY; function c(d, f, h) { const p = d.inRange(t.x, t.y, r); if (i && !p) return; const g = d.getCenterPoint(r); if (!(!!s || e.isPointInArea(g)) && !p) return; const x = a(t, g); x < l ? (o = [{ element: d, datasetIndex: f, index: h }], l = x) : x === l && o.push({ element: d, datasetIndex: f, index: h }) } return Xs(e, n, t, c), o } function Kl(e, t, n, i, r, s) { return !s && !e.isPointInArea(t) ? [] : n === "r" && !i ? Nw(e, t, n, r) : Rw(e, t, n, i, r, s) } function Pp(e, t, n, i, r) { const s = [], o = n === "x" ? "inXRange" : "inYRange"; let a = !1; return Xs(e, n, t, (l, c, d) => { l[o](t[n], r) && (s.push({ element: l, datasetIndex: c, index: d }), a = a || l.inRange(t.x, t.y, r)) }), i && !a ? [] : s } var zw = { evaluateInteractionItems: Xs, modes: { index(e, t, n, i) { const r = ti(t, e), s = n.axis || "x", o = n.includeInvisible || !1, a = n.intersect ? Xl(e, r, s, i, o) : Kl(e, r, s, !1, i, o), l = []; return a.length ? (e.getSortedVisibleDatasetMetas().forEach(c => { const d = a[0].index, f = c.data[d]; f && !f.skip && l.push({ element: f, datasetIndex: c.index, index: d }) }), l) : [] }, dataset(e, t, n, i) { const r = ti(t, e), s = n.axis || "xy", o = n.includeInvisible || !1; let a = n.intersect ? Xl(e, r, s, i, o) : Kl(e, r, s, !1, i, o); if (a.length > 0) { const l = a[0].datasetIndex, c = e.getDatasetMeta(l).data; a = []; for (let d = 0; d < c.length; ++d)a.push({ element: c[d], datasetIndex: l, index: d }) } return a }, point(e, t, n, i) { const r = ti(t, e), s = n.axis || "xy", o = n.includeInvisible || !1; return Xl(e, r, s, i, o) }, nearest(e, t, n, i) { const r = ti(t, e), s = n.axis || "xy", o = n.includeInvisible || !1; return Kl(e, r, s, n.intersect, i, o) }, x(e, t, n, i) { const r = ti(t, e); return Pp(e, r, "x", n.intersect, i) }, y(e, t, n, i) { const r = ti(t, e); return Pp(e, r, "y", n.intersect, i) } } }; const F0 = ["left", "top", "right", "bottom"]; function Mr(e, t) { return e.filter(n => n.pos === t) } function Ep(e, t) { return e.filter(n => F0.indexOf(n.pos) === -1 && n.box.axis === t) } function Dr(e, t) { return e.sort((n, i) => { const r = t ? i : n, s = t ? n : i; return r.weight === s.weight ? r.index - s.index : r.weight - s.weight }) } function Lw(e) { const t = []; let n, i, r, s, o, a; for (n = 0, i = (e || []).length; n < i; ++n)r = e[n], { position: s, options: { stack: o, stackWeight: a = 1 } } = r, t.push({ index: n, box: r, pos: s, horizontal: r.isHorizontal(), weight: r.weight, stack: o && s + o, stackWeight: a }); return t } function Aw(e) { const t = {}; for (const n of e) { const { stack: i, pos: r, stackWeight: s } = n; if (!i || !F0.includes(r)) continue; const o = t[i] || (t[i] = { count: 0, placed: 0, weight: 0, size: 0 }); o.count++, o.weight += s } return t } function Iw(e, t) { const n = Aw(e), { vBoxMaxWidth: i, hBoxMaxHeight: r } = t; let s, o, a; for (s = 0, o = e.length; s < o; ++s) { a = e[s]; const { fullSize: l } = a.box, c = n[a.stack], d = c && a.stackWeight / c.weight; a.horizontal ? (a.width = d ? d * i : l && t.availableWidth, a.height = r) : (a.width = i, a.height = d ? d * r : l && t.availableHeight) } return n } function Fw(e) { const t = Lw(e), n = Dr(t.filter(c => c.box.fullSize), !0), i = Dr(Mr(t, "left"), !0), r = Dr(Mr(t, "right")), s = Dr(Mr(t, "top"), !0), o = Dr(Mr(t, "bottom")), a = Ep(t, "x"), l = Ep(t, "y"); return { fullSize: n, leftAndTop: i.concat(s), rightAndBottom: r.concat(l).concat(o).concat(a), chartArea: Mr(t, "chartArea"), vertical: i.concat(r).concat(l), horizontal: s.concat(o).concat(a) } } function Mp(e, t, n, i) { return Math.max(e[n], t[n]) + Math.max(e[i], t[i]) } function $0(e, t) { e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right) } function $w(e, t, n, i) { const { pos: r, box: s } = n, o = e.maxPadding; if (!H(r)) { n.size && (e[r] -= n.size); const f = i[n.stack] || { size: 0, count: 1 }; f.size = Math.max(f.size, n.horizontal ? s.height : s.width), n.size = f.size / f.count, e[r] += n.size } s.getPadding && $0(o, s.getPadding()); const a = Math.max(0, t.outerWidth - Mp(o, e, "left", "right")), l = Math.max(0, t.outerHeight - Mp(o, e, "top", "bottom")), c = a !== e.w, d = l !== e.h; return e.w = a, e.h = l, n.horizontal ? { same: c, other: d } : { same: d, other: c } } function Bw(e) { const t = e.maxPadding; function n(i) { const r = Math.max(t[i] - e[i], 0); return e[i] += r, r } e.y += n("top"), e.x += n("left"), n("right"), n("bottom") } function Ww(e, t) { const n = t.maxPadding; function i(r) { const s = { left: 0, top: 0, right: 0, bottom: 0 }; return r.forEach(o => { s[o] = Math.max(t[o], n[o]) }), s } return i(e ? ["left", "right"] : ["top", "bottom"]) } function Vr(e, t, n, i) { const r = []; let s, o, a, l, c, d; for (s = 0, o = e.length, c = 0; s < o; ++s) { a = e[s], l = a.box, l.update(a.width || t.w, a.height || t.h, Ww(a.horizontal, t)); const { same: f, other: h } = $w(t, n, a, i); c |= f && r.length, d = d || h, l.fullSize || r.push(a) } return c && Vr(r, t, n, i) || d } function vo(e, t, n, i, r) { e.top = n, e.left = t, e.right = t + i, e.bottom = n + r, e.width = i, e.height = r } function Dp(e, t, n, i) { const r = n.padding; let { x: s, y: o } = t; for (const a of e) { const l = a.box, c = i[a.stack] || { count: 1, placed: 0, weight: 1 }, d = a.stackWeight / c.weight || 1; if (a.horizontal) { const f = t.w * d, h = c.size || l.height; Ts(c.start) && (o = c.start), l.fullSize ? vo(l, r.left, o, n.outerWidth - r.right - r.left, h) : vo(l, t.left + c.placed, o, f, h), c.start = o, c.placed += f, o = l.bottom } else { const f = t.h * d, h = c.size || l.width; Ts(c.start) && (s = c.start), l.fullSize ? vo(l, s, r.top, h, n.outerHeight - r.bottom - r.top) : vo(l, s, t.top + c.placed, h, f), c.start = s, c.placed += f, s = l.right } } t.x = s, t.y = o } var Be = { addBox(e, t) { e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function () { return [{ z: 0, draw(n) { t.draw(n) } }] }, e.boxes.push(t) }, removeBox(e, t) { const n = e.boxes ? e.boxes.indexOf(t) : -1; n !== -1 && e.boxes.splice(n, 1) }, configure(e, t, n) { t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight }, update(e, t, n, i) { if (!e) return; const r = Ve(e.options.layout.padding), s = Math.max(t - r.width, 0), o = Math.max(n - r.height, 0), a = Fw(e.boxes), l = a.vertical, c = a.horizontal; te(e.boxes, v => { typeof v.beforeLayout == "function" && v.beforeLayout() }); const d = l.reduce((v, x) => x.box.options && x.box.options.display === !1 ? v : v + 1, 0) || 1, f = Object.freeze({ outerWidth: t, outerHeight: n, padding: r, availableWidth: s, availableHeight: o, vBoxMaxWidth: s / 2 / d, hBoxMaxHeight: o / 2 }), h = Object.assign({}, r); $0(h, Ve(i)); const p = Object.assign({ maxPadding: h, w: s, h: o, x: r.left, y: r.top }, r), g = Iw(l.concat(c), f); Vr(a.fullSize, p, f, g), Vr(l, p, f, g), Vr(c, p, f, g) && Vr(l, p, f, g), Bw(p), Dp(a.leftAndTop, p, f, g), p.x += p.w, p.y += p.h, Dp(a.rightAndBottom, p, f, g), e.chartArea = { left: p.left, top: p.top, right: p.left + p.w, bottom: p.top + p.h, height: p.h, width: p.w }, te(a.chartArea, v => { const x = v.box; Object.assign(x, e.chartArea), x.update(p.w, p.h, { left: 0, top: 0, right: 0, bottom: 0 }) }) } }; class B0 { acquireContext(t, n) { } releaseContext(t) { return !1 } addEventListener(t, n, i) { } removeEventListener(t, n, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(t, n, i, r) { return n = Math.max(0, n || t.width), i = i || t.height, { width: n, height: Math.max(0, r ? Math.floor(n / r) : i) } } isAttached(t) { return !0 } updateConfig(t) { } } class Vw extends B0 { acquireContext(t) { return t && t.getContext && t.getContext("2d") || null } updateConfig(t) { t.options.animation = !1 } } const Wo = "$chartjs", Uw = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, Tp = e => e === null || e === ""; function Hw(e, t) { const n = e.style, i = e.getAttribute("height"), r = e.getAttribute("width"); if (e[Wo] = { initial: { height: i, width: r, style: { display: n.display, height: n.height, width: n.width } } }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", Tp(r)) { const s = pp(e, "width"); s !== void 0 && (e.width = s) } if (Tp(i)) if (e.style.height === "") e.height = e.width / (t || 2); else { const s = pp(e, "height"); s !== void 0 && (e.height = s) } return e } const W0 = X5 ? { passive: !0 } : !1; function Yw(e, t, n) { e && e.addEventListener(t, n, W0) } function Xw(e, t, n) { e && e.canvas && e.canvas.removeEventListener(t, n, W0) } function Kw(e, t) { const n = Uw[e.type] || e.type, { x: i, y: r } = ti(e, t); return { type: n, chart: t, native: e, x: i !== void 0 ? i : null, y: r !== void 0 ? r : null } } function Ma(e, t) { for (const n of e) if (n === t || n.contains(t)) return !0 } function Gw(e, t, n) { const i = e.canvas, r = new MutationObserver(s => { let o = !1; for (const a of s) o = o || Ma(a.addedNodes, i), o = o && !Ma(a.removedNodes, i); o && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } function Qw(e, t, n) { const i = e.canvas, r = new MutationObserver(s => { let o = !1; for (const a of s) o = o || Ma(a.removedNodes, i), o = o && !Ma(a.addedNodes, i); o && n() }); return r.observe(document, { childList: !0, subtree: !0 }), r } const zs = new Map; let Np = 0; function V0() { const e = window.devicePixelRatio; e !== Np && (Np = e, zs.forEach((t, n) => { n.currentDevicePixelRatio !== e && t() })) } function qw(e, t) { zs.size || window.addEventListener("resize", V0), zs.set(e, t) } function Jw(e) { zs.delete(e), zs.size || window.removeEventListener("resize", V0) } function Zw(e, t, n) { const i = e.canvas, r = i && cf(i); if (!r) return; const s = x0((a, l) => { const c = r.clientWidth; n(a, l), c < r.clientWidth && n() }, window), o = new ResizeObserver(a => { const l = a[0], c = l.contentRect.width, d = l.contentRect.height; c === 0 && d === 0 || s(c, d) }); return o.observe(r), qw(e, s), o } function Gl(e, t, n) { n && n.disconnect(), t === "resize" && Jw(e) } function e6(e, t, n) { const i = e.canvas, r = x0(s => { e.ctx !== null && n(Kw(s, e)) }, e); return Yw(i, t, r), r } class t6 extends B0 { acquireContext(t, n) { const i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (Hw(t, n), i) : null } releaseContext(t) { const n = t.canvas; if (!n[Wo]) return !1; const i = n[Wo].initial;["height", "width"].forEach(s => { const o = i[s]; G(o) ? n.removeAttribute(s) : n.setAttribute(s, o) }); const r = i.style || {}; return Object.keys(r).forEach(s => { n.style[s] = r[s] }), n.width = n.width, delete n[Wo], !0 } addEventListener(t, n, i) { this.removeEventListener(t, n); const r = t.$proxies || (t.$proxies = {}), o = { attach: Gw, detach: Qw, resize: Zw }[n] || e6; r[n] = o(t, n, i) } removeEventListener(t, n) { const i = t.$proxies || (t.$proxies = {}), r = i[n]; if (!r) return; ({ attach: Gl, detach: Gl, resize: Gl }[n] || Xw)(t, n, r), i[n] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(t, n, i, r) { return Y5(t, n, i, r) } isAttached(t) { const n = cf(t); return !!(n && n.isConnected) } } function n6(e) { return !lf() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? Vw : t6 } class zt { constructor() { E(this, "x"); E(this, "y"); E(this, "active", !1); E(this, "options"); E(this, "$animations") } tooltipPosition(t) { const { x: n, y: i } = this.getProps(["x", "y"], t); return { x: n, y: i } } hasValue() { return or(this.x) && or(this.y) } getProps(t, n) { const i = this.$animations; if (!n || !i) return this; const r = {}; return t.forEach(s => { r[s] = i[s] && i[s].active() ? i[s]._to : this[s] }), r } } E(zt, "defaults", {}), E(zt, "defaultRoutes"); function i6(e, t) { const n = e.options.ticks, i = r6(e), r = Math.min(n.maxTicksLimit || i, i), s = n.major.enabled ? o6(t) : [], o = s.length, a = s[0], l = s[o - 1], c = []; if (o > r) return a6(t, c, s, o / r), c; const d = s6(s, t, r); if (o > 0) { let f, h; const p = o > 1 ? Math.round((l - a) / (o - 1)) : null; for (xo(t, c, d, G(p) ? 0 : a - p, a), f = 0, h = o - 1; f < h; f++)xo(t, c, d, s[f], s[f + 1]); return xo(t, c, d, l, G(p) ? t.length : l + p), c } return xo(t, c, d), c } function r6(e) { const t = e.options.offset, n = e._tickSize(), i = e._length / n + (t ? 0 : 1), r = e._maxLength / n; return Math.floor(Math.min(i, r)) } function s6(e, t, n) { const i = l6(e), r = t.length / n; if (!i) return Math.max(r, 1); const s = Q_(i); for (let o = 0, a = s.length - 1; o < a; o++) { const l = s[o]; if (l > r) return l } return Math.max(r, 1) } function o6(e) { const t = []; let n, i; for (n = 0, i = e.length; n < i; n++)e[n].major && t.push(n); return t } function a6(e, t, n, i) { let r = 0, s = n[0], o; for (i = Math.ceil(i), o = 0; o < e.length; o++)o === s && (t.push(e[o]), r++, s = n[r * i]) } function xo(e, t, n, i, r) { const s = B(i, 0), o = Math.min(B(r, e.length), e.length); let a = 0, l, c, d; for (n = Math.ceil(n), r && (l = r - i, n = l / Math.floor(l / n)), d = s; d < 0;)a++, d = Math.round(s + a * n); for (c = Math.max(s, 0); c < o; c++)c === d && (t.push(e[c]), a++, d = Math.round(s + a * n)) } function l6(e) { const t = e.length; let n, i; if (t < 2) return !1; for (i = e[0], n = 1; n < t; ++n)if (e[n] - e[n - 1] !== i) return !1; return i } const c6 = e => e === "left" ? "right" : e === "right" ? "left" : e, Rp = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, zp = (e, t) => Math.min(t || e, e); function Lp(e, t) { const n = [], i = e.length / t, r = e.length; let s = 0; for (; s < r; s += i)n.push(e[Math.floor(s)]); return n } function u6(e, t, n) { const i = e.ticks.length, r = Math.min(t, i - 1), s = e._startPixel, o = e._endPixel, a = 1e-6; let l = e.getPixelForTick(r), c; if (!(n && (i === 1 ? c = Math.max(l - s, o - l) : t === 0 ? c = (e.getPixelForTick(1) - l) / 2 : c = (l - e.getPixelForTick(r - 1)) / 2, l += r < t ? c : -c, l < s - a || l > o + a))) return l } function d6(e, t) { te(e, n => { const i = n.gc, r = i.length / 2; let s; if (r > t) { for (s = 0; s < r; ++s)delete n.data[i[s]]; i.splice(0, r) } }) } function Tr(e) { return e.drawTicks ? e.tickLength : 0 } function Ap(e, t) { if (!e.display) return 0; const n = Pe(e.font, t), i = Ve(e.padding); return (ce(e.text) ? e.text.length : 1) * n.lineHeight + i.height } function f6(e, t) { return Hn(e, { scale: t, type: "scale" }) } function h6(e, t, n) { return Hn(e, { tick: n, index: t, type: "tick" }) } function p6(e, t, n) { let i = tf(e); return (n && t !== "right" || !n && t === "right") && (i = c6(i)), i } function g6(e, t, n, i) { const { top: r, left: s, bottom: o, right: a, chart: l } = e, { chartArea: c, scales: d } = l; let f = 0, h, p, g; const v = o - r, x = a - s; if (e.isHorizontal()) { if (p = Fe(i, s, a), H(n)) { const y = Object.keys(n)[0], m = n[y]; g = d[y].getPixelForValue(m) + v - t } else n === "center" ? g = (c.bottom + c.top) / 2 + v - t : g = Rp(e, n, t); h = a - s } else { if (H(n)) { const y = Object.keys(n)[0], m = n[y]; p = d[y].getPixelForValue(m) - x + t } else n === "center" ? p = (c.left + c.right) / 2 - x + t : p = Rp(e, n, t); g = Fe(i, o, r), f = n === "left" ? -we : we } return { titleX: p, titleY: g, maxWidth: h, rotation: f } } class _i extends zt { constructor(t) { super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(t) { this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax) } parse(t, n) { return t } getUserBounds() { let { _userMin: t, _userMax: n, _suggestedMin: i, _suggestedMax: r } = this; return t = nt(t, Number.POSITIVE_INFINITY), n = nt(n, Number.NEGATIVE_INFINITY), i = nt(i, Number.POSITIVE_INFINITY), r = nt(r, Number.NEGATIVE_INFINITY), { min: nt(t, i), max: nt(n, r), minDefined: xe(t), maxDefined: xe(n) } } getMinMax(t) { let { min: n, max: i, minDefined: r, maxDefined: s } = this.getUserBounds(), o; if (r && s) return { min: n, max: i }; const a = this.getMatchingVisibleMetas(); for (let l = 0, c = a.length; l < c; ++l)o = a[l].controller.getMinMax(this, t), r || (n = Math.min(n, o.min)), s || (i = Math.max(i, o.max)); return n = s && n > i ? i : n, i = r && n > i ? n : i, { min: nt(n, nt(i, n)), max: nt(i, nt(n, i)) } } getPadding() { return { left: this.paddingLeft || 0, top: this.paddingTop || 0, right: this.paddingRight || 0, bottom: this.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } getLabelItems(t = this.chart.chartArea) { return this._labelItems || (this._labelItems = this._computeLabelItems(t)) } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { oe(this.options.beforeUpdate, [this]) } update(t, n, i) { const { beginAtZero: r, grace: s, ticks: o } = this.options, a = o.sampleSize; this.beforeUpdate(), this.maxWidth = t, this.maxHeight = n, this._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = S5(this, s, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks(); const l = a < this.ticks.length; this._convertTicksToLabels(l ? Lp(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = i6(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate() } configure() { let t = this.options.reverse, n, i; this.isHorizontal() ? (n = this.left, i = this.right) : (n = this.top, i = this.bottom, t = !t), this._startPixel = n, this._endPixel = i, this._reversePixels = t, this._length = i - n, this._alignToPixels = this.options.alignToPixels } afterUpdate() { oe(this.options.afterUpdate, [this]) } beforeSetDimensions() { oe(this.options.beforeSetDimensions, [this]) } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0 } afterSetDimensions() { oe(this.options.afterSetDimensions, [this]) } _callHooks(t) { this.chart.notifyPlugins(t, this.getContext()), oe(this.options[t], [this]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { oe(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(t) { const n = this.options.ticks; let i, r, s; for (i = 0, r = t.length; i < r; i++)s = t[i], s.label = oe(n.callback, [s.value, i, t], this) } afterTickToLabelConversion() { oe(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { oe(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const t = this.options, n = t.ticks, i = zp(this.ticks.length, t.ticks.maxTicksLimit), r = n.minRotation || 0, s = n.maxRotation; let o = r, a, l, c; if (!this._isVisible() || !n.display || r >= s || i <= 1 || !this.isHorizontal()) { this.labelRotation = r; return } const d = this._getLabelSizes(), f = d.widest.width, h = d.highest.height, p = De(this.chart.width - f, 0, this.maxWidth); a = t.offset ? this.maxWidth / i : p / (i - 1), f + 6 > a && (a = p / (i - (t.offset ? .5 : 1)), l = this.maxHeight - Tr(t.grid) - n.padding - Ap(t.title, this.chart.options.font), c = Math.sqrt(f * f + h * h), o = Zd(Math.min(Math.asin(De((d.highest.height + 6) / a, -1, 1)), Math.asin(De(l / c, -1, 1)) - Math.asin(De(h / c, -1, 1)))), o = Math.max(r, Math.min(s, o))), this.labelRotation = o } afterCalculateLabelRotation() { oe(this.options.afterCalculateLabelRotation, [this]) } afterAutoSkip() { } beforeFit() { oe(this.options.beforeFit, [this]) } fit() { const t = { width: 0, height: 0 }, { chart: n, options: { ticks: i, title: r, grid: s } } = this, o = this._isVisible(), a = this.isHorizontal(); if (o) { const l = Ap(r, n.options.font); if (a ? (t.width = this.maxWidth, t.height = Tr(s) + l) : (t.height = this.maxHeight, t.width = Tr(s) + l), i.display && this.ticks.length) { const { first: c, last: d, widest: f, highest: h } = this._getLabelSizes(), p = i.padding * 2, g = Mt(this.labelRotation), v = Math.cos(g), x = Math.sin(g); if (a) { const y = i.mirror ? 0 : x * f.width + v * h.height; t.height = Math.min(this.maxHeight, t.height + y + p) } else { const y = i.mirror ? 0 : v * f.width + x * h.height; t.width = Math.min(this.maxWidth, t.width + y + p) } this._calculatePadding(c, d, x, v) } } this._handleMargins(), a ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom) } _calculatePadding(t, n, i, r) { const { ticks: { align: s, padding: o }, position: a } = this.options, l = this.labelRotation !== 0, c = a !== "top" && this.axis === "x"; if (this.isHorizontal()) { const d = this.getPixelForTick(0) - this.left, f = this.right - this.getPixelForTick(this.ticks.length - 1); let h = 0, p = 0; l ? c ? (h = r * t.width, p = i * n.height) : (h = i * t.height, p = r * n.width) : s === "start" ? p = n.width : s === "end" ? h = t.width : s !== "inner" && (h = t.width / 2, p = n.width / 2), this.paddingLeft = Math.max((h - d + o) * this.width / (this.width - d), 0), this.paddingRight = Math.max((p - f + o) * this.width / (this.width - f), 0) } else { let d = n.height / 2, f = t.height / 2; s === "start" ? (d = 0, f = t.height) : s === "end" && (d = n.height, f = 0), this.paddingTop = d + o, this.paddingBottom = f + o } } _handleMargins() { this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom)) } afterFit() { oe(this.options.afterFit, [this]) } isHorizontal() { const { axis: t, position: n } = this.options; return n === "top" || n === "bottom" || t === "x" } isFullSize() { return this.options.fullSize } _convertTicksToLabels(t) { this.beforeTickToLabelConversion(), this.generateTickLabels(t); let n, i; for (n = 0, i = t.length; n < i; n++)G(t[n].label) && (t.splice(n, 1), i--, n--); this.afterTickToLabelConversion() } _getLabelSizes() { let t = this._labelSizes; if (!t) { const n = this.options.ticks.sampleSize; let i = this.ticks; n < i.length && (i = Lp(i, n)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit) } return t } _computeLabelSizes(t, n, i) { const { ctx: r, _longestTextCache: s } = this, o = [], a = [], l = Math.floor(n / zp(n, i)); let c = 0, d = 0, f, h, p, g, v, x, y, m, b, j, w; for (f = 0; f < n; f += l) { if (g = t[f].label, v = this._resolveTickFontOptions(f), r.font = x = v.string, y = s[x] = s[x] || { data: {}, gc: [] }, m = v.lineHeight, b = j = 0, !G(g) && !ce(g)) b = Oa(r, y.data, y.gc, b, g), j = m; else if (ce(g)) for (h = 0, p = g.length; h < p; ++h)w = g[h], !G(w) && !ce(w) && (b = Oa(r, y.data, y.gc, b, w), j += m); o.push(b), a.push(j), c = Math.max(b, c), d = Math.max(j, d) } d6(s, n); const k = o.indexOf(c), C = a.indexOf(d), O = D => ({ width: o[D] || 0, height: a[D] || 0 }); return { first: O(0), last: O(n - 1), widest: O(k), highest: O(C), widths: o, heights: a } } getLabelForValue(t) { return t } getPixelForValue(t, n) { return NaN } getValueForPixel(t) { } getPixelForTick(t) { const n = this.ticks; return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value) } getPixelForDecimal(t) { this._reversePixels && (t = 1 - t); const n = this._startPixel + t * this._length; return Z_(this._alignToPixels ? Kn(this.chart, n, 0) : n) } getDecimalForPixel(t) { const n = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - n : n } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: t, max: n } = this; return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0 } getContext(t) { const n = this.ticks || []; if (t >= 0 && t < n.length) { const i = n[t]; return i.$context || (i.$context = h6(this.getContext(), t, i)) } return this.$context || (this.$context = f6(this.chart.getContext(), this)) } _tickSize() { const t = this.options.ticks, n = Mt(this.labelRotation), i = Math.abs(Math.cos(n)), r = Math.abs(Math.sin(n)), s = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = s ? s.widest.width + o : 0, l = s ? s.highest.height + o : 0; return this.isHorizontal() ? l * i > a * r ? a / i : l / r : l * r < a * i ? l / i : a / r } _isVisible() { const t = this.options.display; return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(t) { const n = this.axis, i = this.chart, r = this.options, { grid: s, position: o, border: a } = r, l = s.offset, c = this.isHorizontal(), f = this.ticks.length + (l ? 1 : 0), h = Tr(s), p = [], g = a.setContext(this.getContext()), v = g.display ? g.width : 0, x = v / 2, y = function (J) { return Kn(i, J, v) }; let m, b, j, w, k, C, O, D, T, A, $, se; if (o === "top") m = y(this.bottom), C = this.bottom - h, D = m - x, A = y(t.top) + x, se = t.bottom; else if (o === "bottom") m = y(this.top), A = t.top, se = y(t.bottom) - x, C = m + x, D = this.top + h; else if (o === "left") m = y(this.right), k = this.right - h, O = m - x, T = y(t.left) + x, $ = t.right; else if (o === "right") m = y(this.left), T = t.left, $ = y(t.right) - x, k = m + x, O = this.left + h; else if (n === "x") { if (o === "center") m = y((t.top + t.bottom) / 2 + .5); else if (H(o)) { const J = Object.keys(o)[0], q = o[J]; m = y(this.chart.scales[J].getPixelForValue(q)) } A = t.top, se = t.bottom, C = m + x, D = C + h } else if (n === "y") { if (o === "center") m = y((t.left + t.right) / 2); else if (H(o)) { const J = Object.keys(o)[0], q = o[J]; m = y(this.chart.scales[J].getPixelForValue(q)) } k = m - x, O = k - h, T = t.left, $ = t.right } const Ee = B(r.ticks.maxTicksLimit, f), X = Math.max(1, Math.ceil(f / Ee)); for (b = 0; b < f; b += X) { const J = this.getContext(b), q = s.setContext(J), M = a.setContext(J), z = q.lineWidth, F = q.color, ie = M.dash || [], re = M.dashOffset, pt = q.tickWidth, Ne = q.tickColor, gt = q.tickBorderDash || [], ke = q.tickBorderDashOffset; j = u6(this, b, l), j !== void 0 && (w = Kn(i, j, z), c ? k = O = T = $ = w : C = D = A = se = w, p.push({ tx1: k, ty1: C, tx2: O, ty2: D, x1: T, y1: A, x2: $, y2: se, width: z, color: F, borderDash: ie, borderDashOffset: re, tickWidth: pt, tickColor: Ne, tickBorderDash: gt, tickBorderDashOffset: ke })) } return this._ticksLength = f, this._borderValue = m, p } _computeLabelItems(t) { const n = this.axis, i = this.options, { position: r, ticks: s } = i, o = this.isHorizontal(), a = this.ticks, { align: l, crossAlign: c, padding: d, mirror: f } = s, h = Tr(i.grid), p = h + d, g = f ? -d : p, v = -Mt(this.labelRotation), x = []; let y, m, b, j, w, k, C, O, D, T, A, $, se = "middle"; if (r === "top") k = this.bottom - g, C = this._getXAxisLabelAlignment(); else if (r === "bottom") k = this.top + g, C = this._getXAxisLabelAlignment(); else if (r === "left") { const X = this._getYAxisLabelAlignment(h); C = X.textAlign, w = X.x } else if (r === "right") { const X = this._getYAxisLabelAlignment(h); C = X.textAlign, w = X.x } else if (n === "x") { if (r === "center") k = (t.top + t.bottom) / 2 + p; else if (H(r)) { const X = Object.keys(r)[0], J = r[X]; k = this.chart.scales[X].getPixelForValue(J) + p } C = this._getXAxisLabelAlignment() } else if (n === "y") { if (r === "center") w = (t.left + t.right) / 2 - p; else if (H(r)) { const X = Object.keys(r)[0], J = r[X]; w = this.chart.scales[X].getPixelForValue(J) } C = this._getYAxisLabelAlignment(h).textAlign } n === "y" && (l === "start" ? se = "top" : l === "end" && (se = "bottom")); const Ee = this._getLabelSizes(); for (y = 0, m = a.length; y < m; ++y) { b = a[y], j = b.label; const X = s.setContext(this.getContext(y)); O = this.getPixelForTick(y) + s.labelOffset, D = this._resolveTickFontOptions(y), T = D.lineHeight, A = ce(j) ? j.length : 1; const J = A / 2, q = X.color, M = X.textStrokeColor, z = X.textStrokeWidth; let F = C; o ? (w = O, C === "inner" && (y === m - 1 ? F = this.options.reverse ? "left" : "right" : y === 0 ? F = this.options.reverse ? "right" : "left" : F = "center"), r === "top" ? c === "near" || v !== 0 ? $ = -A * T + T / 2 : c === "center" ? $ = -Ee.highest.height / 2 - J * T + T : $ = -Ee.highest.height + T / 2 : c === "near" || v !== 0 ? $ = T / 2 : c === "center" ? $ = Ee.highest.height / 2 - J * T : $ = Ee.highest.height - A * T, f && ($ *= -1), v !== 0 && !X.showLabelBackdrop && (w += T / 2 * Math.sin(v))) : (k = O, $ = (1 - A) * T / 2); let ie; if (X.showLabelBackdrop) { const re = Ve(X.backdropPadding), pt = Ee.heights[y], Ne = Ee.widths[y]; let gt = $ - re.top, ke = 0 - re.left; switch (se) { case "middle": gt -= pt / 2; break; case "bottom": gt -= pt; break }switch (C) { case "center": ke -= Ne / 2; break; case "right": ke -= Ne; break; case "inner": y === m - 1 ? ke -= Ne : y > 0 && (ke -= Ne / 2); break }ie = { left: ke, top: gt, width: Ne + re.width, height: pt + re.height, color: X.backdropColor } } x.push({ label: j, font: D, textOffset: $, options: { rotation: v, color: q, strokeColor: M, strokeWidth: z, textAlign: F, textBaseline: se, translation: [w, k], backdrop: ie } }) } return x } _getXAxisLabelAlignment() { const { position: t, ticks: n } = this.options; if (-Mt(this.labelRotation)) return t === "top" ? "left" : "right"; let r = "center"; return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"), r } _getYAxisLabelAlignment(t) { const { position: n, ticks: { crossAlign: i, mirror: r, padding: s } } = this.options, o = this._getLabelSizes(), a = t + s, l = o.widest.width; let c, d; return n === "left" ? r ? (d = this.right + s, i === "near" ? c = "left" : i === "center" ? (c = "center", d += l / 2) : (c = "right", d += l)) : (d = this.right - a, i === "near" ? c = "right" : i === "center" ? (c = "center", d -= l / 2) : (c = "left", d = this.left)) : n === "right" ? r ? (d = this.left + s, i === "near" ? c = "right" : i === "center" ? (c = "center", d -= l / 2) : (c = "left", d -= l)) : (d = this.left + a, i === "near" ? c = "left" : i === "center" ? (c = "center", d += l / 2) : (c = "right", d = this.right)) : c = "right", { textAlign: c, x: d } } _computeLabelArea() { if (this.options.ticks.mirror) return; const t = this.chart, n = this.options.position; if (n === "left" || n === "right") return { top: 0, left: this.left, bottom: t.height, right: this.right }; if (n === "top" || n === "bottom") return { top: this.top, left: 0, bottom: this.bottom, right: t.width } } drawBackground() { const { ctx: t, options: { backgroundColor: n }, left: i, top: r, width: s, height: o } = this; n && (t.save(), t.fillStyle = n, t.fillRect(i, r, s, o), t.restore()) } getLineWidthForValue(t) { const n = this.options.grid; if (!this._isVisible() || !n.display) return 0; const r = this.ticks.findIndex(s => s.value === t); return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0 } drawGrid(t) { const n = this.options.grid, i = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)); let s, o; const a = (l, c, d) => { !d.width || !d.color || (i.save(), i.lineWidth = d.width, i.strokeStyle = d.color, i.setLineDash(d.borderDash || []), i.lineDashOffset = d.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(c.x, c.y), i.stroke(), i.restore()) }; if (n.display) for (s = 0, o = r.length; s < o; ++s) { const l = r[s]; n.drawOnChartArea && a({ x: l.x1, y: l.y1 }, { x: l.x2, y: l.y2 }, l), n.drawTicks && a({ x: l.tx1, y: l.ty1 }, { x: l.tx2, y: l.ty2 }, { color: l.tickColor, width: l.tickWidth, borderDash: l.tickBorderDash, borderDashOffset: l.tickBorderDashOffset }) } } drawBorder() { const { chart: t, ctx: n, options: { border: i, grid: r } } = this, s = i.setContext(this.getContext()), o = i.display ? s.width : 0; if (!o) return; const a = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue; let c, d, f, h; this.isHorizontal() ? (c = Kn(t, this.left, o) - o / 2, d = Kn(t, this.right, a) + a / 2, f = h = l) : (f = Kn(t, this.top, o) - o / 2, h = Kn(t, this.bottom, a) + a / 2, c = d = l), n.save(), n.lineWidth = s.width, n.strokeStyle = s.color, n.beginPath(), n.moveTo(c, f), n.lineTo(d, h), n.stroke(), n.restore() } drawLabels(t) { if (!this.options.ticks.display) return; const i = this.ctx, r = this._computeLabelArea(); r && sl(i, r); const s = this.getLabelItems(t); for (const o of s) { const a = o.options, l = o.font, c = o.label, d = o.textOffset; vi(i, c, 0, d, l, a) } r && ol(i) } drawTitle() { const { ctx: t, options: { position: n, title: i, reverse: r } } = this; if (!i.display) return; const s = Pe(i.font), o = Ve(i.padding), a = i.align; let l = s.lineHeight / 2; n === "bottom" || n === "center" || H(n) ? (l += o.bottom, ce(i.text) && (l += s.lineHeight * (i.text.length - 1))) : l += o.top; const { titleX: c, titleY: d, maxWidth: f, rotation: h } = g6(this, l, n, a); vi(t, i.text, 0, 0, s, { color: i.color, maxWidth: f, rotation: h, textAlign: p6(a, n, r), textBaseline: "middle", translation: [c, d] }) } draw(t) { this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t)) } _layers() { const t = this.options, n = t.ticks && t.ticks.z || 0, i = B(t.grid && t.grid.z, -1), r = B(t.border && t.border.z, 0); return !this._isVisible() || this.draw !== _i.prototype.draw ? [{ z: n, draw: s => { this.draw(s) } }] : [{ z: i, draw: s => { this.drawBackground(), this.drawGrid(s), this.drawTitle() } }, { z: r, draw: () => { this.drawBorder() } }, { z: n, draw: s => { this.drawLabels(s) } }] } getMatchingVisibleMetas(t) { const n = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", r = []; let s, o; for (s = 0, o = n.length; s < o; ++s) { const a = n[s]; a[i] === this.id && (!t || a.type === t) && r.push(a) } return r } _resolveTickFontOptions(t) { const n = this.options.ticks.setContext(this.getContext(t)); return Pe(n.font) } _maxDigits() { const t = this._resolveTickFontOptions(0).lineHeight; return (this.isHorizontal() ? this.width : this.height) / t } } class bo { constructor(t, n, i) { this.type = t, this.scope = n, this.override = i, this.items = Object.create(null) } isForType(t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } register(t) { const n = Object.getPrototypeOf(t); let i; v6(n) && (i = this.register(n)); const r = this.items, s = t.id, o = this.scope + "." + s; if (!s) throw new Error("class does not have id: " + t); return s in r || (r[s] = t, m6(t, o, i), this.override && be.override(t.id, t.overrides)), o } get(t) { return this.items[t] } unregister(t) { const n = this.items, i = t.id, r = this.scope; i in n && delete n[i], r && i in be[r] && (delete be[r][i], this.override && delete yi[i]) } } function m6(e, t, n) { const i = Ds(Object.create(null), [n ? be.get(n) : {}, be.get(t), e.defaults]); be.set(t, i), e.defaultRoutes && y6(t, e.defaultRoutes), e.descriptors && be.describe(t, e.descriptors) } function y6(e, t) { Object.keys(t).forEach(n => { const i = n.split("."), r = i.pop(), s = [e].concat(i).join("."), o = t[n].split("."), a = o.pop(), l = o.join("."); be.route(s, r, l, a) }) } function v6(e) { return "id" in e && "defaults" in e } class x6 { constructor() { this.controllers = new bo(Nt, "datasets", !0), this.elements = new bo(zt, "elements"), this.plugins = new bo(Object, "plugins"), this.scales = new bo(_i, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...t) { this._each("register", t) } remove(...t) { this._each("unregister", t) } addControllers(...t) { this._each("register", t, this.controllers) } addElements(...t) { this._each("register", t, this.elements) } addPlugins(...t) { this._each("register", t, this.plugins) } addScales(...t) { this._each("register", t, this.scales) } getController(t) { return this._get(t, this.controllers, "controller") } getElement(t) { return this._get(t, this.elements, "element") } getPlugin(t) { return this._get(t, this.plugins, "plugin") } getScale(t) { return this._get(t, this.scales, "scale") } removeControllers(...t) { this._each("unregister", t, this.controllers) } removeElements(...t) { this._each("unregister", t, this.elements) } removePlugins(...t) { this._each("unregister", t, this.plugins) } removeScales(...t) { this._each("unregister", t, this.scales) } _each(t, n, i) { [...n].forEach(r => { const s = i || this._getRegistryForType(r); i || s.isForType(r) || s === this.plugins && r.id ? this._exec(t, s, r) : te(r, o => { const a = i || this._getRegistryForType(o); this._exec(t, a, o) }) }) } _exec(t, n, i) { const r = Jd(t); oe(i["before" + r], [], i), n[t](i), oe(i["after" + r], [], i) } _getRegistryForType(t) { for (let n = 0; n < this._typedRegistries.length; n++) { const i = this._typedRegistries[n]; if (i.isForType(t)) return i } return this.plugins } _get(t, n, i) { const r = n.get(t); if (r === void 0) throw new Error('"' + t + '" is not a registered ' + i + "."); return r } } var $t = new x6; class b6 { constructor() { this._init = [] } notify(t, n, i, r) { n === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")); const s = r ? this._descriptors(t).filter(r) : this._descriptors(t), o = this._notify(s, t, n, i); return n === "afterDestroy" && (this._notify(s, t, "stop"), this._notify(this._init, t, "uninstall")), o } _notify(t, n, i, r) { r = r || {}; for (const s of t) { const o = s.plugin, a = o[i], l = [n, r, s.options]; if (oe(a, l, o) === !1 && r.cancelable) return !1 } return !0 } invalidate() { G(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(t) { if (this._cache) return this._cache; const n = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), n } _createDescriptors(t, n) { const i = t && t.config, r = B(i.options && i.options.plugins, {}), s = _6(i); return r === !1 && !n ? [] : j6(t, s, r, n) } _notifyStateChanges(t) { const n = this._oldCache || [], i = this._cache, r = (s, o) => s.filter(a => !o.some(l => a.plugin.id === l.plugin.id)); this._notify(r(n, i), t, "stop"), this._notify(r(i, n), t, "start") } } function _6(e) { const t = {}, n = [], i = Object.keys($t.plugins.items); for (let s = 0; s < i.length; s++)n.push($t.getPlugin(i[s])); const r = e.plugins || []; for (let s = 0; s < r.length; s++) { const o = r[s]; n.indexOf(o) === -1 && (n.push(o), t[o.id] = !0) } return { plugins: n, localIds: t } } function w6(e, t) { return !t && e === !1 ? null : e === !0 ? {} : e } function j6(e, { plugins: t, localIds: n }, i, r) { const s = [], o = e.getContext(); for (const a of t) { const l = a.id, c = w6(i[l], r); c !== null && s.push({ plugin: a, options: S6(e.config, { plugin: a, local: n[l] }, c, o) }) } return s } function S6(e, { plugin: t, local: n }, i, r) { const s = e.pluginScopeKeys(t), o = e.getOptionScopes(i, s); return n && t.defaults && o.push(t.defaults), e.createResolver(o, r, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function Au(e, t) { const n = be.datasets[e] || {}; return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x" } function k6(e, t) { let n = e; return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"), n } function C6(e, t) { return e === t ? "_index_" : "_value_" } function Ip(e) { if (e === "x" || e === "y" || e === "r") return e } function O6(e) { if (e === "top" || e === "bottom") return "x"; if (e === "left" || e === "right") return "y" } function Iu(e, ...t) { if (Ip(e)) return e; for (const n of t) { const i = n.axis || O6(n.position) || e.length > 1 && Ip(e[0].toLowerCase()); if (i) return i } throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`) } function Fp(e, t, n) { if (n[t + "AxisID"] === e) return { axis: t } } function P6(e, t) { if (t.data && t.data.datasets) { const n = t.data.datasets.filter(i => i.xAxisID === e || i.yAxisID === e); if (n.length) return Fp(e, "x", n[0]) || Fp(e, "y", n[0]) } return {} } function E6(e, t) { const n = yi[e.type] || { scales: {} }, i = t.scales || {}, r = Au(e.type, t), s = Object.create(null); return Object.keys(i).forEach(o => { const a = i[o]; if (!H(a)) return console.error(`Invalid scale configuration for scale: ${o}`); if (a._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${o}`); const l = Iu(o, a, P6(o, e), be.scales[a.type]), c = C6(l, r), d = n.scales || {}; s[o] = is(Object.create(null), [{ axis: l }, a, d[l], d[c]]) }), e.data.datasets.forEach(o => { const a = o.type || e.type, l = o.indexAxis || Au(a, t), d = (yi[a] || {}).scales || {}; Object.keys(d).forEach(f => { const h = k6(f, l), p = o[h + "AxisID"] || h; s[p] = s[p] || Object.create(null), is(s[p], [{ axis: h }, i[p], d[f]]) }) }), Object.keys(s).forEach(o => { const a = s[o]; is(a, [be.scales[a.type], be.scale]) }), s } function U0(e) { const t = e.options || (e.options = {}); t.plugins = B(t.plugins, {}), t.scales = E6(e, t) } function H0(e) { return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e } function M6(e) { return e = e || {}, e.data = H0(e.data), U0(e), e } const $p = new Map, Y0 = new Set; function _o(e, t) { let n = $p.get(e); return n || (n = t(), $p.set(e, n), Y0.add(n)), n } const Nr = (e, t, n) => { const i = Fn(t, n); i !== void 0 && e.add(i) }; class D6 { constructor(t) { this._config = M6(t), this._scopeCache = new Map, this._resolverCache = new Map } get platform() { return this._config.platform } get type() { return this._config.type } set type(t) { this._config.type = t } get data() { return this._config.data } set data(t) { this._config.data = H0(t) } get options() { return this._config.options } set options(t) { this._config.options = t } get plugins() { return this._config.plugins } update() { const t = this._config; this.clearCache(), U0(t) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(t) { return _o(t, () => [[`datasets.${t}`, ""]]) } datasetAnimationScopeKeys(t, n) { return _o(`${t}.transition.${n}`, () => [[`datasets.${t}.transitions.${n}`, `transitions.${n}`], [`datasets.${t}`, ""]]) } datasetElementScopeKeys(t, n) { return _o(`${t}-${n}`, () => [[`datasets.${t}.elements.${n}`, `datasets.${t}`, `elements.${n}`, ""]]) } pluginScopeKeys(t) { const n = t.id, i = this.type; return _o(`${i}-plugin-${n}`, () => [[`plugins.${n}`, ...t.additionalOptionScopes || []]]) } _cachedScopes(t, n) { const i = this._scopeCache; let r = i.get(t); return (!r || n) && (r = new Map, i.set(t, r)), r } getOptionScopes(t, n, i) { const { options: r, type: s } = this, o = this._cachedScopes(t, i), a = o.get(n); if (a) return a; const l = new Set; n.forEach(d => { t && (l.add(t), d.forEach(f => Nr(l, t, f))), d.forEach(f => Nr(l, r, f)), d.forEach(f => Nr(l, yi[s] || {}, f)), d.forEach(f => Nr(l, be, f)), d.forEach(f => Nr(l, zu, f)) }); const c = Array.from(l); return c.length === 0 && c.push(Object.create(null)), Y0.has(n) && o.set(n, c), c } chartOptionScopes() { const { options: t, type: n } = this; return [t, yi[n] || {}, be.datasets[n] || {}, { type: n }, be, zu] } resolveNamedOptions(t, n, i, r = [""]) { const s = { $shared: !0 }, { resolver: o, subPrefixes: a } = Bp(this._resolverCache, t, r); let l = o; if (N6(o, n)) { s.$shared = !1, i = $n(i) ? i() : i; const c = this.createResolver(t, i, a); l = ar(o, i, c) } for (const c of n) s[c] = l[c]; return s } createResolver(t, n, i = [""], r) { const { resolver: s } = Bp(this._resolverCache, t, i); return H(n) ? ar(s, n, void 0, r) : s } } function Bp(e, t, n) { let i = e.get(t); i || (i = new Map, e.set(t, i)); const r = n.join(); let s = i.get(r); return s || (s = { resolver: sf(t, n), subPrefixes: n.filter(a => !a.toLowerCase().includes("hover")) }, i.set(r, s)), s } const T6 = e => H(e) && Object.getOwnPropertyNames(e).some(t => $n(e[t])); function N6(e, t) { const { isScriptable: n, isIndexable: i } = k0(e); for (const r of t) { const s = n(r), o = i(r), a = (o || s) && e[r]; if (s && ($n(a) || T6(a)) || o && ce(a)) return !0 } return !1 } var R6 = "4.4.2"; const z6 = ["top", "bottom", "left", "right", "chartArea"]; function Wp(e, t) { return e === "top" || e === "bottom" || z6.indexOf(e) === -1 && t === "x" } function Vp(e, t) { return function (n, i) { return n[e] === i[e] ? n[t] - i[t] : n[e] - i[e] } } function Up(e) { const t = e.chart, n = t.options.animation; t.notifyPlugins("afterRender"), oe(n && n.onComplete, [e], t) } function L6(e) { const t = e.chart, n = t.options.animation; oe(n && n.onProgress, [e], t) } function X0(e) { return lf() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e } const Vo = {}, Hp = e => { const t = X0(e); return Object.values(Vo).filter(n => n.canvas === t).pop() }; function A6(e, t, n) { const i = Object.keys(e); for (const r of i) { const s = +r; if (s >= t) { const o = e[r]; delete e[r], (n > 0 || s > t) && (e[s + n] = o) } } } function I6(e, t, n, i) { return !n || e.type === "mouseout" ? null : i ? t : e } function wo(e, t, n) { return e.options.clip ? e[n] : t[n] } function F6(e, t) { const { xScale: n, yScale: i } = e; return n && i ? { left: wo(n, t, "left"), right: wo(n, t, "right"), top: wo(i, t, "top"), bottom: wo(i, t, "bottom") } : t } var gn; let ll = (gn = class { static register(...t) { $t.add(...t), Yp() } static unregister(...t) { $t.remove(...t), Yp() } constructor(t, n) { const i = this.config = new D6(n), r = X0(t), s = Hp(r); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas with ID '" + s.canvas.id + "' can be reused."); const o = i.createResolver(i.chartOptionScopes(), this.getContext()); this.platform = new (i.platform || n6(r)), this.platform.updateConfig(i); const a = this.platform.acquireContext(r, o.aspectRatio), l = a && a.canvas, c = l && l.height, d = l && l.width; if (this.id = B_(), this.ctx = a, this.canvas = l, this.width = d, this.height = c, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new b6, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = i5(f => this.update(f), o.resizeDelay || 0), this._dataChanges = [], Vo[this.id] = this, !a || !l) { console.error("Failed to create chart: can't acquire context from the given item"); return } Qt.listen(this, "complete", Up), Qt.listen(this, "progress", L6), this._initialize(), this.attached && this.update() } get aspectRatio() { const { options: { aspectRatio: t, maintainAspectRatio: n }, width: i, height: r, _aspectRatio: s } = this; return G(t) ? n && s ? s : r ? i / r : null : t } get data() { return this.config.data } set data(t) { this.config.data = t } get options() { return this._options } set options(t) { this.config.options = t } get registry() { return $t } _initialize() { return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : hp(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this } clear() { return up(this.canvas, this.ctx), this } stop() { return Qt.stop(this), this } resize(t, n) { Qt.running(this) ? this._resizeBeforeDraw = { width: t, height: n } : this._resize(t, n) } _resize(t, n) { const i = this.options, r = this.canvas, s = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, t, n, s), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach"; this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, hp(this, a, !0) && (this.notifyPlugins("resize", { size: o }), oe(i.onResize, [this, o], this), this.attached && this._doResize(l) && this.render()) } ensureScalesHaveIDs() { const n = this.options.scales || {}; te(n, (i, r) => { i.id = r }) } buildOrUpdateScales() { const t = this.options, n = t.scales, i = this.scales, r = Object.keys(i).reduce((o, a) => (o[a] = !1, o), {}); let s = []; n && (s = s.concat(Object.keys(n).map(o => { const a = n[o], l = Iu(o, a), c = l === "r", d = l === "x"; return { options: a, dposition: c ? "chartArea" : d ? "bottom" : "left", dtype: c ? "radialLinear" : d ? "category" : "linear" } }))), te(s, o => { const a = o.options, l = a.id, c = Iu(l, a), d = B(a.type, o.dtype); (a.position === void 0 || Wp(a.position, c) !== Wp(o.dposition)) && (a.position = o.dposition), r[l] = !0; let f = null; if (l in i && i[l].type === d) f = i[l]; else { const h = $t.getScale(d); f = new h({ id: l, type: d, ctx: this.ctx, chart: this }), i[f.id] = f } f.init(a, t) }), te(r, (o, a) => { o || delete i[a] }), te(i, o => { Be.configure(this, o, o.options), Be.addBox(this, o) }) } _updateMetasets() { const t = this._metasets, n = this.data.datasets.length, i = t.length; if (t.sort((r, s) => r.index - s.index), i > n) { for (let r = n; r < i; ++r)this._destroyDatasetMeta(r); t.splice(n, i - n) } this._sortedMetasets = t.slice(0).sort(Vp("order", "index")) } _removeUnreferencedMetasets() { const { _metasets: t, data: { datasets: n } } = this; t.length > n.length && delete this._stacks, t.forEach((i, r) => { n.filter(s => s === i._dataset).length === 0 && this._destroyDatasetMeta(r) }) } buildOrUpdateControllers() { const t = [], n = this.data.datasets; let i, r; for (this._removeUnreferencedMetasets(), i = 0, r = n.length; i < r; i++) { const s = n[i]; let o = this.getDatasetMeta(i); const a = s.type || this.config.type; if (o.type && o.type !== a && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = a, o.indexAxis = s.indexAxis || Au(a, this.options), o.order = s.order || 0, o.index = i, o.label = "" + s.label, o.visible = this.isDatasetVisible(i), o.controller) o.controller.updateIndex(i), o.controller.linkScales(); else { const l = $t.getController(a), { datasetElementType: c, dataElementType: d } = be.datasets[a]; Object.assign(l, { dataElementType: $t.getElement(d), datasetElementType: c && $t.getElement(c) }), o.controller = new l(this, i), t.push(o.controller) } } return this._updateMetasets(), t } _resetElements() { te(this.data.datasets, (t, n) => { this.getDatasetMeta(n).controller.reset() }, this) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(t) { const n = this.config; n.update(); const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !i.animation; if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 }) === !1) return; const s = this.buildOrUpdateControllers(); this.notifyPlugins("beforeElementsUpdate"); let o = 0; for (let c = 0, d = this.data.datasets.length; c < d; c++) { const { controller: f } = this.getDatasetMeta(c), h = !r && s.indexOf(f) === -1; f.buildOrUpdateElements(h), o = Math.max(+f.getMaxOverflow(), o) } o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), r || te(s, c => { c.reset() }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", { mode: t }), this._layers.sort(Vp("z", "_idx")); const { _active: a, _lastEvent: l } = this; l ? this._eventHandler(l, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render() } _updateScales() { te(this.scales, t => { Be.removeBox(this, t) }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales() } _checkEventBindings() { const t = this.options, n = new Set(Object.keys(this._listeners)), i = new Set(t.events); (!tp(n, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents()) } _updateHiddenIndices() { const { _hiddenIndices: t } = this, n = this._getUniformDataChanges() || []; for (const { method: i, start: r, count: s } of n) { const o = i === "_removeElements" ? -s : s; A6(t, r, o) } } _getUniformDataChanges() { const t = this._dataChanges; if (!t || !t.length) return; this._dataChanges = []; const n = this.data.datasets.length, i = s => new Set(t.filter(o => o[0] === s).map((o, a) => a + "," + o.splice(1).join(","))), r = i(0); for (let s = 1; s < n; s++)if (!tp(r, i(s))) return; return Array.from(r).map(s => s.split(",")).map(s => ({ method: s[1], start: +s[2], count: +s[3] })) } _updateLayout(t) { if (this.notifyPlugins("beforeLayout", { cancelable: !0 }) === !1) return; Be.update(this, this.width, this.height, t); const n = this.chartArea, i = n.width <= 0 || n.height <= 0; this._layers = [], te(this.boxes, r => { i && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers())) }, this), this._layers.forEach((r, s) => { r._idx = s }), this.notifyPlugins("afterLayout") } _updateDatasets(t) { if (this.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 }) !== !1) { for (let n = 0, i = this.data.datasets.length; n < i; ++n)this.getDatasetMeta(n).controller.configure(); for (let n = 0, i = this.data.datasets.length; n < i; ++n)this._updateDataset(n, $n(t) ? t({ datasetIndex: n }) : t); this.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset(t, n) { const i = this.getDatasetMeta(t), r = { meta: i, index: t, mode: n, cancelable: !0 }; this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(n), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r)) } render() { this.notifyPlugins("beforeRender", { cancelable: !0 }) !== !1 && (Qt.has(this) ? this.attached && !Qt.running(this) && Qt.start(this) : (this.draw(), Up({ chart: this }))) } draw() { let t; if (this._resizeBeforeDraw) { const { width: i, height: r } = this._resizeBeforeDraw; this._resize(i, r), this._resizeBeforeDraw = null } if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", { cancelable: !0 }) === !1) return; const n = this._layers; for (t = 0; t < n.length && n[t].z <= 0; ++t)n[t].draw(this.chartArea); for (this._drawDatasets(); t < n.length; ++t)n[t].draw(this.chartArea); this.notifyPlugins("afterDraw") } _getSortedDatasetMetas(t) { const n = this._sortedMetasets, i = []; let r, s; for (r = 0, s = n.length; r < s; ++r) { const o = n[r]; (!t || o.visible) && i.push(o) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { if (this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 }) === !1) return; const t = this.getSortedVisibleDatasetMetas(); for (let n = t.length - 1; n >= 0; --n)this._drawDataset(t[n]); this.notifyPlugins("afterDatasetsDraw") } _drawDataset(t) { const n = this.ctx, i = t._clip, r = !i.disabled, s = F6(t, this.chartArea), o = { meta: t, index: t.index, cancelable: !0 }; this.notifyPlugins("beforeDatasetDraw", o) !== !1 && (r && sl(n, { left: i.left === !1 ? 0 : s.left - i.left, right: i.right === !1 ? this.width : s.right + i.right, top: i.top === !1 ? 0 : s.top - i.top, bottom: i.bottom === !1 ? this.height : s.bottom + i.bottom }), t.controller.draw(), r && ol(n), o.cancelable = !1, this.notifyPlugins("afterDatasetDraw", o)) } isPointInArea(t) { return an(t, this.chartArea, this._minPadding) } getElementsAtEventForMode(t, n, i, r) { const s = zw.modes[n]; return typeof s == "function" ? s(this, t, i, r) : [] } getDatasetMeta(t) { const n = this.data.datasets[t], i = this._metasets; let r = i.filter(s => s && s._dataset === n).pop(); return r || (r = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: n && n.order || 0, index: t, _dataset: n, _parsed: [], _sorted: !1 }, i.push(r)), r } getContext() { return this.$context || (this.$context = Hn(null, { chart: this, type: "chart" })) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(t) { const n = this.data.datasets[t]; if (!n) return !1; const i = this.getDatasetMeta(t); return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden } setDatasetVisibility(t, n) { const i = this.getDatasetMeta(t); i.hidden = !n } toggleDataVisibility(t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility(t) { return !this._hiddenIndices[t] } _updateVisibility(t, n, i) { const r = i ? "show" : "hide", s = this.getDatasetMeta(t), o = s.controller._resolveAnimations(void 0, r); Ts(n) ? (s.data[n].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(s, { visible: i }), this.update(a => a.datasetIndex === t ? r : void 0)) } hide(t, n) { this._updateVisibility(t, n, !1) } show(t, n) { this._updateVisibility(t, n, !0) } _destroyDatasetMeta(t) { const n = this._metasets[t]; n && n.controller && n.controller._destroy(), delete this._metasets[t] } _stop() { let t, n; for (this.stop(), Qt.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)this._destroyDatasetMeta(t) } destroy() { this.notifyPlugins("beforeDestroy"); const { canvas: t, ctx: n } = this; this._stop(), this.config.clearCache(), t && (this.unbindEvents(), up(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete Vo[this.id], this.notifyPlugins("afterDestroy") } toBase64Image(...t) { return this.canvas.toDataURL(...t) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const t = this._listeners, n = this.platform, i = (s, o) => { n.addEventListener(this, s, o), t[s] = o }, r = (s, o, a) => { s.offsetX = o, s.offsetY = a, this._eventHandler(s) }; te(this.options.events, s => i(s, r)) } bindResponsiveEvents() { this._responsiveListeners || (this._responsiveListeners = {}); const t = this._responsiveListeners, n = this.platform, i = (l, c) => { n.addEventListener(this, l, c), t[l] = c }, r = (l, c) => { t[l] && (n.removeEventListener(this, l, c), delete t[l]) }, s = (l, c) => { this.canvas && this.resize(l, c) }; let o; const a = () => { r("attach", a), this.attached = !0, this.resize(), i("resize", s), i("detach", o) }; o = () => { this.attached = !1, r("resize", s), this._stop(), this._resize(0, 0), i("attach", a) }, n.isAttached(this.canvas) ? a() : o() } unbindEvents() { te(this._listeners, (t, n) => { this.platform.removeEventListener(this, n, t) }), this._listeners = {}, te(this._responsiveListeners, (t, n) => { this.platform.removeEventListener(this, n, t) }), this._responsiveListeners = void 0 } updateHoverStyle(t, n, i) { const r = i ? "set" : "remove"; let s, o, a, l; for (n === "dataset" && (s = this.getDatasetMeta(t[0].datasetIndex), s.controller["_" + r + "DatasetHoverStyle"]()), a = 0, l = t.length; a < l; ++a) { o = t[a]; const c = o && this.getDatasetMeta(o.datasetIndex).controller; c && c[r + "HoverStyle"](o.element, o.datasetIndex, o.index) } } getActiveElements() { return this._active || [] } setActiveElements(t) { const n = this._active || [], i = t.map(({ datasetIndex: s, index: o }) => { const a = this.getDatasetMeta(s); if (!a) throw new Error("No dataset found at index " + s); return { datasetIndex: s, element: a.data[o], index: o } }); !Sa(i, n) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, n)) } notifyPlugins(t, n, i) { return this._plugins.notify(this, t, n, i) } isPluginEnabled(t) { return this._plugins._cache.filter(n => n.plugin.id === t).length === 1 } _updateHoverStyles(t, n, i) { const r = this.options.hover, s = (l, c) => l.filter(d => !c.some(f => d.datasetIndex === f.datasetIndex && d.index === f.index)), o = s(n, t), a = i ? t : s(t, n); o.length && this.updateHoverStyle(o, r.mode, !1), a.length && r.mode && this.updateHoverStyle(a, r.mode, !0) } _eventHandler(t, n) { const i = { event: t, replay: n, cancelable: !0, inChartArea: this.isPointInArea(t) }, r = o => (o.options.events || this.options.events).includes(t.native.type); if (this.notifyPlugins("beforeEvent", i, r) === !1) return; const s = this._handleEvent(t, n, i.inChartArea); return i.cancelable = !1, this.notifyPlugins("afterEvent", i, r), (s || i.changed) && this.render(), this } _handleEvent(t, n, i) { const { _active: r = [], options: s } = this, o = n, a = this._getActiveElements(t, r, i, o), l = X_(t), c = I6(t, this._lastEvent, i, l); i && (this._lastEvent = null, oe(s.onHover, [t, a, this], this), l && oe(s.onClick, [t, a, this], this)); const d = !Sa(a, r); return (d || n) && (this._active = a, this._updateHoverStyles(a, r, n)), this._lastEvent = c, d } _getActiveElements(t, n, i, r) { if (t.type === "mouseout") return []; if (!i) return n; const s = this.options.hover; return this.getElementsAtEventForMode(t, s.mode, s, r) } }, E(gn, "defaults", be), E(gn, "instances", Vo), E(gn, "overrides", yi), E(gn, "registry", $t), E(gn, "version", R6), E(gn, "getChart", Hp), gn); function Yp() { return te(ll.instances, e => e._plugins.invalidate()) } function $6(e, t, n) { const { startAngle: i, pixelMargin: r, x: s, y: o, outerRadius: a, innerRadius: l } = t; let c = r / a; e.beginPath(), e.arc(s, o, a, i - c, n + c), l > r ? (c = r / l, e.arc(s, o, l, n + c, i - c, !0)) : e.arc(s, o, r, n + we, i - we), e.closePath(), e.clip() } function B6(e) { return rf(e, ["outerStart", "outerEnd", "innerStart", "innerEnd"]) } function W6(e, t, n, i) { const r = B6(e.options.borderRadius), s = (n - t) / 2, o = Math.min(s, i * t / 2), a = l => { const c = (n - Math.min(s, l)) * i / 2; return De(l, 0, Math.min(s, c)) }; return { outerStart: a(r.outerStart), outerEnd: a(r.outerEnd), innerStart: De(r.innerStart, 0, o), innerEnd: De(r.innerEnd, 0, o) } } function Ei(e, t, n, i) { return { x: n + e * Math.cos(t), y: i + e * Math.sin(t) } } function Da(e, t, n, i, r, s) { const { x: o, y: a, startAngle: l, pixelMargin: c, innerRadius: d } = t, f = Math.max(t.outerRadius + i + n - c, 0), h = d > 0 ? d + i + n + c : 0; let p = 0; const g = r - l; if (i) { const X = d > 0 ? d - i : 0, J = f > 0 ? f - i : 0, q = (X + J) / 2, M = q !== 0 ? g * q / (q + i) : g; p = (g - M) / 2 } const v = Math.max(.001, g * f - n / fe) / f, x = (g - v) / 2, y = l + x + p, m = r - x - p, { outerStart: b, outerEnd: j, innerStart: w, innerEnd: k } = W6(t, h, f, m - y), C = f - b, O = f - j, D = y + b / C, T = m - j / O, A = h + w, $ = h + k, se = y + w / A, Ee = m - k / $; if (e.beginPath(), s) { const X = (D + T) / 2; if (e.arc(o, a, f, D, X), e.arc(o, a, f, X, T), j > 0) { const z = Ei(O, T, o, a); e.arc(z.x, z.y, j, T, m + we) } const J = Ei($, m, o, a); if (e.lineTo(J.x, J.y), k > 0) { const z = Ei($, Ee, o, a); e.arc(z.x, z.y, k, m + we, Ee + Math.PI) } const q = (m - k / h + (y + w / h)) / 2; if (e.arc(o, a, h, m - k / h, q, !0), e.arc(o, a, h, q, y + w / h, !0), w > 0) { const z = Ei(A, se, o, a); e.arc(z.x, z.y, w, se + Math.PI, y - we) } const M = Ei(C, y, o, a); if (e.lineTo(M.x, M.y), b > 0) { const z = Ei(C, D, o, a); e.arc(z.x, z.y, b, y - we, D) } } else { e.moveTo(o, a); const X = Math.cos(D) * f + o, J = Math.sin(D) * f + a; e.lineTo(X, J); const q = Math.cos(T) * f + o, M = Math.sin(T) * f + a; e.lineTo(q, M) } e.closePath() } function V6(e, t, n, i, r) { const { fullCircles: s, startAngle: o, circumference: a } = t; let l = t.endAngle; if (s) { Da(e, t, n, i, l, r); for (let c = 0; c < s; ++c)e.fill(); isNaN(a) || (l = o + (a % de || de)) } return Da(e, t, n, i, l, r), e.fill(), l } function U6(e, t, n, i, r) { const { fullCircles: s, startAngle: o, circumference: a, options: l } = t, { borderWidth: c, borderJoinStyle: d, borderDash: f, borderDashOffset: h } = l, p = l.borderAlign === "inner"; if (!c) return; e.setLineDash(f || []), e.lineDashOffset = h, p ? (e.lineWidth = c * 2, e.lineJoin = d || "round") : (e.lineWidth = c, e.lineJoin = d || "bevel"); let g = t.endAngle; if (s) { Da(e, t, n, i, g, r); for (let v = 0; v < s; ++v)e.stroke(); isNaN(a) || (g = o + (a % de || de)) } p && $6(e, t, g), s || (Da(e, t, n, i, g, r), e.stroke()) } class Ur extends zt { constructor(n) { super(); E(this, "circumference"); E(this, "endAngle"); E(this, "fullCircles"); E(this, "innerRadius"); E(this, "outerRadius"); E(this, "pixelMargin"); E(this, "startAngle"); this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, n && Object.assign(this, n) } inRange(n, i, r) { const s = this.getProps(["x", "y"], r), { angle: o, distance: a } = g0(s, { x: n, y: i }), { startAngle: l, endAngle: c, innerRadius: d, outerRadius: f, circumference: h } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], r), p = (this.options.spacing + this.options.borderWidth) / 2, v = B(h, c - l) >= de || Ns(o, l, c), x = sn(a, d + p, f + p); return v && x } getCenterPoint(n) { const { x: i, y: r, startAngle: s, endAngle: o, innerRadius: a, outerRadius: l } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], n), { offset: c, spacing: d } = this.options, f = (s + o) / 2, h = (a + l + d + c) / 2; return { x: i + Math.cos(f) * h, y: r + Math.sin(f) * h } } tooltipPosition(n) { return this.getCenterPoint(n) } draw(n) { const { options: i, circumference: r } = this, s = (i.offset || 0) / 4, o = (i.spacing || 0) / 2, a = i.circular; if (this.pixelMargin = i.borderAlign === "inner" ? .33 : 0, this.fullCircles = r > de ? Math.floor(r / de) : 0, r === 0 || this.innerRadius < 0 || this.outerRadius < 0) return; n.save(); const l = (this.startAngle + this.endAngle) / 2; n.translate(Math.cos(l) * s, Math.sin(l) * s); const c = 1 - Math.sin(Math.min(fe, r || 0)), d = s * c; n.fillStyle = i.backgroundColor, n.strokeStyle = i.borderColor, V6(n, this, d, o, a), U6(n, this, d, o, a), n.restore() } } E(Ur, "id", "arc"), E(Ur, "defaults", { borderAlign: "center", borderColor: "#fff", borderDash: [], borderDashOffset: 0, borderJoinStyle: void 0, borderRadius: 0, borderWidth: 2, offset: 0, spacing: 0, angle: void 0, circular: !0 }), E(Ur, "defaultRoutes", { backgroundColor: "backgroundColor" }), E(Ur, "descriptors", { _scriptable: !0, _indexable: n => n !== "borderDash" }); function K0(e, t, n = t) { e.lineCap = B(n.borderCapStyle, t.borderCapStyle), e.setLineDash(B(n.borderDash, t.borderDash)), e.lineDashOffset = B(n.borderDashOffset, t.borderDashOffset), e.lineJoin = B(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = B(n.borderWidth, t.borderWidth), e.strokeStyle = B(n.borderColor, t.borderColor) } function H6(e, t, n) { e.lineTo(n.x, n.y) } function Y6(e) { return e.stepped ? g5 : e.tension || e.cubicInterpolationMode === "monotone" ? m5 : H6 } function G0(e, t, n = {}) { const i = e.length, { start: r = 0, end: s = i - 1 } = n, { start: o, end: a } = t, l = Math.max(r, o), c = Math.min(s, a), d = r < o && s < o || r > a && s > a; return { count: i, start: l, loop: t.loop, ilen: c < l && !d ? i + c - l : c - l } } function X6(e, t, n, i) { const { points: r, options: s } = t, { count: o, start: a, loop: l, ilen: c } = G0(r, n, i), d = Y6(s); let { move: f = !0, reverse: h } = i || {}, p, g, v; for (p = 0; p <= c; ++p)g = r[(a + (h ? c - p : p)) % o], !g.skip && (f ? (e.moveTo(g.x, g.y), f = !1) : d(e, v, g, h, s.stepped), v = g); return l && (g = r[(a + (h ? c : 0)) % o], d(e, v, g, h, s.stepped)), !!l } function K6(e, t, n, i) { const r = t.points, { count: s, start: o, ilen: a } = G0(r, n, i), { move: l = !0, reverse: c } = i || {}; let d = 0, f = 0, h, p, g, v, x, y; const m = j => (o + (c ? a - j : j)) % s, b = () => { v !== x && (e.lineTo(d, x), e.lineTo(d, v), e.lineTo(d, y)) }; for (l && (p = r[m(0)], e.moveTo(p.x, p.y)), h = 0; h <= a; ++h) { if (p = r[m(h)], p.skip) continue; const j = p.x, w = p.y, k = j | 0; k === g ? (w < v ? v = w : w > x && (x = w), d = (f * d + j) / ++f) : (b(), e.lineTo(j, w), g = k, f = 0, v = x = w), y = w } b() } function Fu(e) { const t = e.options, n = t.borderDash && t.borderDash.length; return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? K6 : X6 } function G6(e) { return e.stepped ? K5 : e.tension || e.cubicInterpolationMode === "monotone" ? G5 : ni } function Q6(e, t, n, i) { let r = t._path; r || (r = t._path = new Path2D, t.path(r, n, i) && r.closePath()), K0(e, t.options), e.stroke(r) } function q6(e, t, n, i) { const { segments: r, options: s } = t, o = Fu(t); for (const a of r) K0(e, s, a.style), e.beginPath(), o(e, t, a, { start: n, end: n + i - 1 }) && e.closePath(), e.stroke() } const J6 = typeof Path2D == "function"; function Z6(e, t, n, i) { J6 && !t.options.segment ? Q6(e, t, n, i) : q6(e, t, n, i) } class kn extends zt { constructor(t) { super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t) } updateControlPoints(t, n) { const i = this.options; if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) { const r = i.spanGaps ? this._loop : this._fullLoop; $5(this._points, i, t, r, n), this._pointsUpdated = !0 } } set points(t) { this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = tw(this, this.options.segment)) } first() { const t = this.segments, n = this.points; return t.length && n[t[0].start] } last() { const t = this.segments, n = this.points, i = t.length; return i && n[t[i - 1].end] } interpolate(t, n) { const i = this.options, r = t[n], s = this.points, o = z0(this, { property: n, start: r, end: r }); if (!o.length) return; const a = [], l = G6(i); let c, d; for (c = 0, d = o.length; c < d; ++c) { const { start: f, end: h } = o[c], p = s[f], g = s[h]; if (p === g) { a.push(p); continue } const v = Math.abs((r - p[n]) / (g[n] - p[n])), x = l(p, g, v, i.stepped); x[n] = t[n], a.push(x) } return a.length === 1 ? a[0] : a } pathSegment(t, n, i) { return Fu(this)(t, this, n, i) } path(t, n, i) { const r = this.segments, s = Fu(this); let o = this._loop; n = n || 0, i = i || this.points.length - n; for (const a of r) o &= s(t, this, a, { start: n, end: n + i - 1 }); return !!o } draw(t, n, i, r) { const s = this.options || {}; (this.points || []).length && s.borderWidth && (t.save(), Z6(t, this, i, r), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0) } } E(kn, "id", "line"), E(kn, "defaults", { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }), E(kn, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }), E(kn, "descriptors", { _scriptable: !0, _indexable: t => t !== "borderDash" && t !== "fill" }); function Xp(e, t, n, i) { const r = e.options, { [n]: s } = e.getProps([n], i); return Math.abs(t - s) < r.radius + r.hitRadius } class Uo extends zt { constructor(n) { super(); E(this, "parsed"); E(this, "skip"); E(this, "stop"); this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, n && Object.assign(this, n) } inRange(n, i, r) { const s = this.options, { x: o, y: a } = this.getProps(["x", "y"], r); return Math.pow(n - o, 2) + Math.pow(i - a, 2) < Math.pow(s.hitRadius + s.radius, 2) } inXRange(n, i) { return Xp(this, n, "x", i) } inYRange(n, i) { return Xp(this, n, "y", i) } getCenterPoint(n) { const { x: i, y: r } = this.getProps(["x", "y"], n); return { x: i, y: r } } size(n) { n = n || this.options || {}; let i = n.radius || 0; i = Math.max(i, i && n.hoverRadius || 0); const r = i && n.borderWidth || 0; return (i + r) * 2 } draw(n, i) { const r = this.options; this.skip || r.radius < .1 || !an(this, i, this.size(r) / 2) || (n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.fillStyle = r.backgroundColor, Lu(n, r, this.x, this.y)) } getRange() { const n = this.options || {}; return n.radius + n.hitRadius } } E(Uo, "id", "point"), E(Uo, "defaults", { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }), E(Uo, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); function Q0(e, t) { const { x: n, y: i, base: r, width: s, height: o } = e.getProps(["x", "y", "base", "width", "height"], t); let a, l, c, d, f; return e.horizontal ? (f = o / 2, a = Math.min(n, r), l = Math.max(n, r), c = i - f, d = i + f) : (f = s / 2, a = n - f, l = n + f, c = Math.min(i, r), d = Math.max(i, r)), { left: a, top: c, right: l, bottom: d } } function Cn(e, t, n, i) { return e ? 0 : De(t, n, i) } function ej(e, t, n) { const i = e.options.borderWidth, r = e.borderSkipped, s = S0(i); return { t: Cn(r.top, s.top, 0, n), r: Cn(r.right, s.right, 0, t), b: Cn(r.bottom, s.bottom, 0, n), l: Cn(r.left, s.left, 0, t) } } function tj(e, t, n) { const { enableBorderRadius: i } = e.getProps(["enableBorderRadius"]), r = e.options.borderRadius, s = ui(r), o = Math.min(t, n), a = e.borderSkipped, l = i || H(r); return { topLeft: Cn(!l || a.top || a.left, s.topLeft, 0, o), topRight: Cn(!l || a.top || a.right, s.topRight, 0, o), bottomLeft: Cn(!l || a.bottom || a.left, s.bottomLeft, 0, o), bottomRight: Cn(!l || a.bottom || a.right, s.bottomRight, 0, o) } } function nj(e) { const t = Q0(e), n = t.right - t.left, i = t.bottom - t.top, r = ej(e, n / 2, i / 2), s = tj(e, n / 2, i / 2); return { outer: { x: t.left, y: t.top, w: n, h: i, radius: s }, inner: { x: t.left + r.l, y: t.top + r.t, w: n - r.l - r.r, h: i - r.t - r.b, radius: { topLeft: Math.max(0, s.topLeft - Math.max(r.t, r.l)), topRight: Math.max(0, s.topRight - Math.max(r.t, r.r)), bottomLeft: Math.max(0, s.bottomLeft - Math.max(r.b, r.l)), bottomRight: Math.max(0, s.bottomRight - Math.max(r.b, r.r)) } } } } function Ql(e, t, n, i) { const r = t === null, s = n === null, a = e && !(r && s) && Q0(e, i); return a && (r || sn(t, a.left, a.right)) && (s || sn(n, a.top, a.bottom)) } function ij(e) { return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight } function rj(e, t) { e.rect(t.x, t.y, t.w, t.h) } function ql(e, t, n = {}) { const i = e.x !== n.x ? -t : 0, r = e.y !== n.y ? -t : 0, s = (e.x + e.w !== n.x + n.w ? t : 0) - i, o = (e.y + e.h !== n.y + n.h ? t : 0) - r; return { x: e.x + i, y: e.y + r, w: e.w + s, h: e.h + o, radius: e.radius } } class ls extends zt { constructor(t) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t) } draw(t) { const { inflateAmount: n, options: { borderColor: i, backgroundColor: r } } = this, { inner: s, outer: o } = nj(this), a = ij(o.radius) ? Rs : rj; t.save(), (o.w !== s.w || o.h !== s.h) && (t.beginPath(), a(t, ql(o, n, s)), t.clip(), a(t, ql(s, -n, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), a(t, ql(s, n)), t.fillStyle = r, t.fill(), t.restore() } inRange(t, n, i) { return Ql(this, t, n, i) } inXRange(t, n) { return Ql(this, t, null, n) } inYRange(t, n) { return Ql(this, null, t, n) } getCenterPoint(t) { const { x: n, y: i, base: r, horizontal: s } = this.getProps(["x", "y", "base", "horizontal"], t); return { x: s ? (n + r) / 2 : n, y: s ? i : (i + r) / 2 } } getRange(t) { return t === "x" ? this.width / 2 : this.height / 2 } } E(ls, "id", "bar"), E(ls, "defaults", { borderSkipped: "start", borderWidth: 0, borderRadius: 0, inflateAmount: "auto", pointStyle: void 0 }), E(ls, "defaultRoutes", { backgroundColor: "backgroundColor", borderColor: "borderColor" }); var sj = Object.freeze({ __proto__: null, ArcElement: Ur, BarElement: ls, LineElement: kn, PointElement: Uo }); const $u = ["rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)"], Kp = $u.map(e => e.replace("rgb(", "rgba(").replace(")", ", 0.5)")); function q0(e) { return $u[e % $u.length] } function J0(e) { return Kp[e % Kp.length] } function oj(e, t) { return e.borderColor = q0(t), e.backgroundColor = J0(t), ++t } function aj(e, t) { return e.backgroundColor = e.data.map(() => q0(t++)), t } function lj(e, t) { return e.backgroundColor = e.data.map(() => J0(t++)), t } function cj(e) { let t = 0; return (n, i) => { const r = e.getDatasetMeta(i).controller; r instanceof ai ? t = aj(n, t) : r instanceof as ? t = lj(n, t) : r && (t = oj(n, t)) } } function Gp(e) { let t; for (t in e) if (e[t].borderColor || e[t].backgroundColor) return !0; return !1 } function uj(e) { return e && (e.borderColor || e.backgroundColor) } var dj = { id: "colors", defaults: { enabled: !0, forceOverride: !1 }, beforeLayout(e, t, n) { if (!n.enabled) return; const { data: { datasets: i }, options: r } = e.config, { elements: s } = r; if (!n.forceOverride && (Gp(i) || uj(r) || s && Gp(s))) return; const o = cj(e); i.forEach(o) } }; function fj(e, t, n, i, r) { const s = r.samples || i; if (s >= n) return e.slice(t, t + n); const o = [], a = (n - 2) / (s - 2); let l = 0; const c = t + n - 1; let d = t, f, h, p, g, v; for (o[l++] = e[d], f = 0; f < s - 2; f++) { let x = 0, y = 0, m; const b = Math.floor((f + 1) * a) + 1 + t, j = Math.min(Math.floor((f + 2) * a) + 1, n) + t, w = j - b; for (m = b; m < j; m++)x += e[m].x, y += e[m].y; x /= w, y /= w; const k = Math.floor(f * a) + 1 + t, C = Math.min(Math.floor((f + 1) * a) + 1, n) + t, { x: O, y: D } = e[d]; for (p = g = -1, m = k; m < C; m++)g = .5 * Math.abs((O - x) * (e[m].y - D) - (O - e[m].x) * (y - D)), g > p && (p = g, h = e[m], v = m); o[l++] = h, d = v } return o[l++] = e[c], o } function hj(e, t, n, i) { let r = 0, s = 0, o, a, l, c, d, f, h, p, g, v; const x = [], y = t + n - 1, m = e[t].x, j = e[y].x - m; for (o = t; o < t + n; ++o) { a = e[o], l = (a.x - m) / j * i, c = a.y; const w = l | 0; if (w === d) c < g ? (g = c, f = o) : c > v && (v = c, h = o), r = (s * r + a.x) / ++s; else { const k = o - 1; if (!G(f) && !G(h)) { const C = Math.min(f, h), O = Math.max(f, h); C !== p && C !== k && x.push({ ...e[C], x: r }), O !== p && O !== k && x.push({ ...e[O], x: r }) } o > 0 && k !== p && x.push(e[k]), x.push(a), d = w, s = 0, g = v = c, f = h = p = o } } return x } function Z0(e) { if (e._decimated) { const t = e._data; delete e._decimated, delete e._data, Object.defineProperty(e, "data", { configurable: !0, enumerable: !0, writable: !0, value: t }) } } function Qp(e) { e.data.datasets.forEach(t => { Z0(t) }) } function pj(e, t) { const n = t.length; let i = 0, r; const { iScale: s } = e, { min: o, max: a, minDefined: l, maxDefined: c } = s.getUserBounds(); return l && (i = De(on(t, s.axis, o).lo, 0, n - 1)), c ? r = De(on(t, s.axis, a).hi + 1, i, n) - i : r = n - i, { start: i, count: r } } var gj = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (e, t, n) => { if (!n.enabled) { Qp(e); return } const i = e.width; e.data.datasets.forEach((r, s) => { const { _data: o, indexAxis: a } = r, l = e.getDatasetMeta(s), c = o || r.data; if (Wr([a, e.options.indexAxis]) === "y" || !l.controller.supportsDecimation) return; const d = e.scales[l.xAxisID]; if (d.type !== "linear" && d.type !== "time" || e.options.parsing) return; let { start: f, count: h } = pj(l, c); const p = n.threshold || 4 * i; if (h <= p) { Z0(r); return } G(o) && (r._data = c, delete r.data, Object.defineProperty(r, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (v) { this._data = v } })); let g; switch (n.algorithm) { case "lttb": g = fj(c, f, h, i, n); break; case "min-max": g = hj(c, f, h, i); break; default: throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`) }r._decimated = g }) }, destroy(e) { Qp(e) } }; function mj(e, t, n) { const i = e.segments, r = e.points, s = t.points, o = []; for (const a of i) { let { start: l, end: c } = a; c = df(l, c, r); const d = Bu(n, r[l], r[c], a.loop); if (!t.segments) { o.push({ source: a, target: d, start: r[l], end: r[c] }); continue } const f = z0(t, d); for (const h of f) { const p = Bu(n, s[h.start], s[h.end], h.loop), g = R0(a, r, p); for (const v of g) o.push({ source: v, target: h, start: { [n]: qp(d, p, "start", Math.max) }, end: { [n]: qp(d, p, "end", Math.min) } }) } } return o } function Bu(e, t, n, i) { if (i) return; let r = t[e], s = n[e]; return e === "angle" && (r = rt(r), s = rt(s)), { property: e, start: r, end: s } } function yj(e, t) { const { x: n = null, y: i = null } = e || {}, r = t.points, s = []; return t.segments.forEach(({ start: o, end: a }) => { a = df(o, a, r); const l = r[o], c = r[a]; i !== null ? (s.push({ x: l.x, y: i }), s.push({ x: c.x, y: i })) : n !== null && (s.push({ x: n, y: l.y }), s.push({ x: n, y: c.y })) }), s } function df(e, t, n) { for (; t > e; t--) { const i = n[t]; if (!isNaN(i.x) && !isNaN(i.y)) break } return t } function qp(e, t, n, i) { return e && t ? i(e[n], t[n]) : e ? e[n] : t ? t[n] : 0 } function e2(e, t) { let n = [], i = !1; return ce(e) ? (i = !0, n = e) : n = yj(e, t), n.length ? new kn({ points: n, options: { tension: 0 }, _loop: i, _fullLoop: i }) : null } function Jp(e) { return e && e.fill !== !1 } function vj(e, t, n) { let r = e[t].fill; const s = [t]; let o; if (!n) return r; for (; r !== !1 && s.indexOf(r) === -1;) { if (!xe(r)) return r; if (o = e[r], !o) return !1; if (o.visible) return r; s.push(r), r = o.fill } return !1 } function xj(e, t, n) { const i = jj(e); if (H(i)) return isNaN(i.value) ? !1 : i; let r = parseFloat(i); return xe(r) && Math.floor(r) === r ? bj(i[0], t, r, n) : ["origin", "start", "end", "stack", "shape"].indexOf(i) >= 0 && i } function bj(e, t, n, i) { return (e === "-" || e === "+") && (n = t + n), n === t || n < 0 || n >= i ? !1 : n } function _j(e, t) { let n = null; return e === "start" ? n = t.bottom : e === "end" ? n = t.top : H(e) ? n = t.getPixelForValue(e.value) : t.getBasePixel && (n = t.getBasePixel()), n } function wj(e, t, n) { let i; return e === "start" ? i = n : e === "end" ? i = t.options.reverse ? t.min : t.max : H(e) ? i = e.value : i = t.getBaseValue(), i } function jj(e) { const t = e.options, n = t.fill; let i = B(n && n.target, n); return i === void 0 && (i = !!t.backgroundColor), i === !1 || i === null ? !1 : i === !0 ? "origin" : i } function Sj(e) { const { scale: t, index: n, line: i } = e, r = [], s = i.segments, o = i.points, a = kj(t, n); a.push(e2({ x: null, y: t.bottom }, i)); for (let l = 0; l < s.length; l++) { const c = s[l]; for (let d = c.start; d <= c.end; d++)Cj(r, o[d], a) } return new kn({ points: r, options: {} }) } function kj(e, t) { const n = [], i = e.getMatchingVisibleMetas("line"); for (let r = 0; r < i.length; r++) { const s = i[r]; if (s.index === t) break; s.hidden || n.unshift(s.dataset) } return n } function Cj(e, t, n) { const i = []; for (let r = 0; r < n.length; r++) { const s = n[r], { first: o, last: a, point: l } = Oj(s, t, "x"); if (!(!l || o && a)) { if (o) i.unshift(l); else if (e.push(l), !a) break } } e.push(...i) } function Oj(e, t, n) { const i = e.interpolate(t, n); if (!i) return {}; const r = i[n], s = e.segments, o = e.points; let a = !1, l = !1; for (let c = 0; c < s.length; c++) { const d = s[c], f = o[d.start][n], h = o[d.end][n]; if (sn(r, f, h)) { a = r === f, l = r === h; break } } return { first: a, last: l, point: i } } class t2 { constructor(t) { this.x = t.x, this.y = t.y, this.radius = t.radius } pathSegment(t, n, i) { const { x: r, y: s, radius: o } = this; return n = n || { start: 0, end: de }, t.arc(r, s, o, n.end, n.start, !0), !i.bounds } interpolate(t) { const { x: n, y: i, radius: r } = this, s = t.angle; return { x: n + Math.cos(s) * r, y: i + Math.sin(s) * r, angle: s } } } function Pj(e) { const { chart: t, fill: n, line: i } = e; if (xe(n)) return Ej(t, n); if (n === "stack") return Sj(e); if (n === "shape") return !0; const r = Mj(e); return r instanceof t2 ? r : e2(r, i) } function Ej(e, t) { const n = e.getDatasetMeta(t); return n && e.isDatasetVisible(t) ? n.dataset : null } function Mj(e) { return (e.scale || {}).getPointPositionForValue ? Tj(e) : Dj(e) } function Dj(e) { const { scale: t = {}, fill: n } = e, i = _j(n, t); if (xe(i)) { const r = t.isHorizontal(); return { x: r ? i : null, y: r ? null : i } } return null } function Tj(e) { const { scale: t, fill: n } = e, i = t.options, r = t.getLabels().length, s = i.reverse ? t.max : t.min, o = wj(n, t, s), a = []; if (i.grid.circular) { const l = t.getPointPositionForValue(0, s); return new t2({ x: l.x, y: l.y, radius: t.getDistanceFromCenterForValue(o) }) } for (let l = 0; l < r; ++l)a.push(t.getPointPositionForValue(l, o)); return a } function Jl(e, t, n) { const i = Pj(t), { line: r, scale: s, axis: o } = t, a = r.options, l = a.fill, c = a.backgroundColor, { above: d = c, below: f = c } = l || {}; i && r.points.length && (sl(e, n), Nj(e, { line: r, target: i, above: d, below: f, area: n, scale: s, axis: o }), ol(e)) } function Nj(e, t) { const { line: n, target: i, above: r, below: s, area: o, scale: a } = t, l = n._loop ? "angle" : t.axis; e.save(), l === "x" && s !== r && (Zp(e, i, o.top), eg(e, { line: n, target: i, color: r, scale: a, property: l }), e.restore(), e.save(), Zp(e, i, o.bottom)), eg(e, { line: n, target: i, color: s, scale: a, property: l }), e.restore() } function Zp(e, t, n) { const { segments: i, points: r } = t; let s = !0, o = !1; e.beginPath(); for (const a of i) { const { start: l, end: c } = a, d = r[l], f = r[df(l, c, r)]; s ? (e.moveTo(d.x, d.y), s = !1) : (e.lineTo(d.x, n), e.lineTo(d.x, d.y)), o = !!t.pathSegment(e, a, { move: o }), o ? e.closePath() : e.lineTo(f.x, n) } e.lineTo(t.first().x, n), e.closePath(), e.clip() } function eg(e, t) { const { line: n, target: i, property: r, color: s, scale: o } = t, a = mj(n, i, r); for (const { source: l, target: c, start: d, end: f } of a) { const { style: { backgroundColor: h = s } = {} } = l, p = i !== !0; e.save(), e.fillStyle = h, Rj(e, o, p && Bu(r, d, f)), e.beginPath(); const g = !!n.pathSegment(e, l); let v; if (p) { g ? e.closePath() : tg(e, i, f, r); const x = !!i.pathSegment(e, c, { move: g, reverse: !0 }); v = g && x, v || tg(e, i, d, r) } e.closePath(), e.fill(v ? "evenodd" : "nonzero"), e.restore() } } function Rj(e, t, n) { const { top: i, bottom: r } = t.chart.chartArea, { property: s, start: o, end: a } = n || {}; s === "x" && (e.beginPath(), e.rect(o, i, a - o, r - i), e.clip()) } function tg(e, t, n, i) { const r = t.interpolate(n, i); r && e.lineTo(r.x, r.y) } var zj = { id: "filler", afterDatasetsUpdate(e, t, n) { const i = (e.data.datasets || []).length, r = []; let s, o, a, l; for (o = 0; o < i; ++o)s = e.getDatasetMeta(o), a = s.dataset, l = null, a && a.options && a instanceof kn && (l = { visible: e.isDatasetVisible(o), index: o, fill: xj(a, o, i), chart: e, axis: s.controller.options.indexAxis, scale: s.vScale, line: a }), s.$filler = l, r.push(l); for (o = 0; o < i; ++o)l = r[o], !(!l || l.fill === !1) && (l.fill = vj(r, o, n.propagate)) }, beforeDraw(e, t, n) { const i = n.drawTime === "beforeDraw", r = e.getSortedVisibleDatasetMetas(), s = e.chartArea; for (let o = r.length - 1; o >= 0; --o) { const a = r[o].$filler; a && (a.line.updateControlPoints(s, a.axis), i && a.fill && Jl(e.ctx, a, s)) } }, beforeDatasetsDraw(e, t, n) { if (n.drawTime !== "beforeDatasetsDraw") return; const i = e.getSortedVisibleDatasetMetas(); for (let r = i.length - 1; r >= 0; --r) { const s = i[r].$filler; Jp(s) && Jl(e.ctx, s, e.chartArea) } }, beforeDatasetDraw(e, t, n) { const i = t.meta.$filler; !Jp(i) || n.drawTime !== "beforeDatasetDraw" || Jl(e.ctx, i, e.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const ng = (e, t) => { let { boxHeight: n = t, boxWidth: i = t } = e; return e.usePointStyle && (n = Math.min(n, t), i = e.pointStyleWidth || Math.min(i, t)), { boxWidth: i, boxHeight: n, itemHeight: Math.max(t, n) } }, Lj = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index; class ig extends zt { constructor(t) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, n, i) { this.maxWidth = t, this.maxHeight = n, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit() } setDimensions() { this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height) } buildLabels() { const t = this.options.labels || {}; let n = oe(t.generateLabels, [this.chart], this) || []; t.filter && (n = n.filter(i => t.filter(i, this.chart.data))), t.sort && (n = n.sort((i, r) => t.sort(i, r, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n } fit() { const { options: t, ctx: n } = this; if (!t.display) { this.width = this.height = 0; return } const i = t.labels, r = Pe(i.font), s = r.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: l } = ng(i, s); let c, d; n.font = r.string, this.isHorizontal() ? (c = this.maxWidth, d = this._fitRows(o, s, a, l) + 10) : (d = this.maxHeight, c = this._fitCols(o, r, a, l) + 10), this.width = Math.min(c, t.maxWidth || this.maxWidth), this.height = Math.min(d, t.maxHeight || this.maxHeight) } _fitRows(t, n, i, r) { const { ctx: s, maxWidth: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], d = r + a; let f = t; s.textAlign = "left", s.textBaseline = "middle"; let h = -1, p = -d; return this.legendItems.forEach((g, v) => { const x = i + n / 2 + s.measureText(g.text).width; (v === 0 || c[c.length - 1] + x + 2 * a > o) && (f += d, c[c.length - (v > 0 ? 0 : 1)] = 0, p += d, h++), l[v] = { left: 0, top: p, row: h, width: x, height: r }, c[c.length - 1] += x + a }), f } _fitCols(t, n, i, r) { const { ctx: s, maxHeight: o, options: { labels: { padding: a } } } = this, l = this.legendHitBoxes = [], c = this.columnSizes = [], d = o - t; let f = a, h = 0, p = 0, g = 0, v = 0; return this.legendItems.forEach((x, y) => { const { itemWidth: m, itemHeight: b } = Aj(i, n, s, x, r); y > 0 && p + b + 2 * a > d && (f += h + a, c.push({ width: h, height: p }), g += h + a, v++, h = p = 0), l[y] = { left: g, top: p, col: v, width: m, height: b }, h = Math.max(h, m), p += b + a }), f += h, c.push({ width: h, height: p }), f } adjustHitBoxes() { if (!this.options.display) return; const t = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: i, labels: { padding: r }, rtl: s } } = this, o = qi(s, this.left, this.width); if (this.isHorizontal()) { let a = 0, l = Fe(i, this.left + r, this.right - this.lineWidths[a]); for (const c of n) a !== c.row && (a = c.row, l = Fe(i, this.left + r, this.right - this.lineWidths[a])), c.top += this.top + t + r, c.left = o.leftForLtr(o.x(l), c.width), l += c.width + r } else { let a = 0, l = Fe(i, this.top + t + r, this.bottom - this.columnSizes[a].height); for (const c of n) c.col !== a && (a = c.col, l = Fe(i, this.top + t + r, this.bottom - this.columnSizes[a].height)), c.top = l, c.left += this.left + r, c.left = o.leftForLtr(o.x(c.left), c.width), l += c.height + r } } isHorizontal() { return this.options.position === "top" || this.options.position === "bottom" } draw() { if (this.options.display) { const t = this.ctx; sl(t, this), this._draw(), ol(t) } } _draw() { const { options: t, columnSizes: n, lineWidths: i, ctx: r } = this, { align: s, labels: o } = t, a = be.color, l = qi(t.rtl, this.left, this.width), c = Pe(o.font), { padding: d } = o, f = c.size, h = f / 2; let p; this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = .5, r.font = c.string; const { boxWidth: g, boxHeight: v, itemHeight: x } = ng(o, f), y = function (k, C, O) { if (isNaN(g) || g <= 0 || isNaN(v) || v < 0) return; r.save(); const D = B(O.lineWidth, 1); if (r.fillStyle = B(O.fillStyle, a), r.lineCap = B(O.lineCap, "butt"), r.lineDashOffset = B(O.lineDashOffset, 0), r.lineJoin = B(O.lineJoin, "miter"), r.lineWidth = D, r.strokeStyle = B(O.strokeStyle, a), r.setLineDash(B(O.lineDash, [])), o.usePointStyle) { const T = { radius: v * Math.SQRT2 / 2, pointStyle: O.pointStyle, rotation: O.rotation, borderWidth: D }, A = l.xPlus(k, g / 2), $ = C + h; j0(r, T, A, $, o.pointStyleWidth && g) } else { const T = C + Math.max((f - v) / 2, 0), A = l.leftForLtr(k, g), $ = ui(O.borderRadius); r.beginPath(), Object.values($).some(se => se !== 0) ? Rs(r, { x: A, y: T, w: g, h: v, radius: $ }) : r.rect(A, T, g, v), r.fill(), D !== 0 && r.stroke() } r.restore() }, m = function (k, C, O) { vi(r, O.text, k, C + x / 2, c, { strikethrough: O.hidden, textAlign: l.textAlign(O.textAlign) }) }, b = this.isHorizontal(), j = this._computeTitleHeight(); b ? p = { x: Fe(s, this.left + d, this.right - i[0]), y: this.top + d + j, line: 0 } : p = { x: this.left + d, y: Fe(s, this.top + j + d, this.bottom - n[0].height), line: 0 }, D0(this.ctx, t.textDirection); const w = x + d; this.legendItems.forEach((k, C) => { r.strokeStyle = k.fontColor, r.fillStyle = k.fontColor; const O = r.measureText(k.text).width, D = l.textAlign(k.textAlign || (k.textAlign = o.textAlign)), T = g + h + O; let A = p.x, $ = p.y; l.setWidth(this.width), b ? C > 0 && A + T + d > this.right && ($ = p.y += w, p.line++, A = p.x = Fe(s, this.left + d, this.right - i[p.line])) : C > 0 && $ + w > this.bottom && (A = p.x = A + n[p.line].width + d, p.line++, $ = p.y = Fe(s, this.top + j + d, this.bottom - n[p.line].height)); const se = l.x(A); if (y(se, $, k), A = r5(D, A + g + h, b ? A + T : this.right, t.rtl), m(l.x(A), $, k), b) p.x += T + d; else if (typeof k.text != "string") { const Ee = c.lineHeight; p.y += n2(k, Ee) + d } else p.y += w }), T0(this.ctx, t.textDirection) } drawTitle() { const t = this.options, n = t.title, i = Pe(n.font), r = Ve(n.padding); if (!n.display) return; const s = qi(t.rtl, this.left, this.width), o = this.ctx, a = n.position, l = i.size / 2, c = r.top + l; let d, f = this.left, h = this.width; if (this.isHorizontal()) h = Math.max(...this.lineWidths), d = this.top + c, f = Fe(t.align, f, this.right - h); else { const g = this.columnSizes.reduce((v, x) => Math.max(v, x.height), 0); d = c + Fe(t.align, this.top, this.bottom - g - t.labels.padding - this._computeTitleHeight()) } const p = Fe(a, f, f + h); o.textAlign = s.textAlign(tf(a)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = i.string, vi(o, n.text, p, d, i) } _computeTitleHeight() { const t = this.options.title, n = Pe(t.font), i = Ve(t.padding); return t.display ? n.lineHeight + i.height : 0 } _getLegendItemAt(t, n) { let i, r, s; if (sn(t, this.left, this.right) && sn(n, this.top, this.bottom)) { for (s = this.legendHitBoxes, i = 0; i < s.length; ++i)if (r = s[i], sn(t, r.left, r.left + r.width) && sn(n, r.top, r.top + r.height)) return this.legendItems[i] } return null } handleEvent(t) { const n = this.options; if (!$j(t.type, n)) return; const i = this._getLegendItemAt(t.x, t.y); if (t.type === "mousemove" || t.type === "mouseout") { const r = this._hoveredItem, s = Lj(r, i); r && !s && oe(n.onLeave, [t, r, this], this), this._hoveredItem = i, i && !s && oe(n.onHover, [t, i, this], this) } else i && oe(n.onClick, [t, i, this], this) } } function Aj(e, t, n, i, r) { const s = Ij(i, e, t, n), o = Fj(r, i, t.lineHeight); return { itemWidth: s, itemHeight: o } } function Ij(e, t, n, i) { let r = e.text; return r && typeof r != "string" && (r = r.reduce((s, o) => s.length > o.length ? s : o)), t + n.size / 2 + i.measureText(r).width } function Fj(e, t, n) { let i = e; return typeof t.text != "string" && (i = n2(t, n)), i } function n2(e, t) { const n = e.text ? e.text.length : 0; return t * n } function $j(e, t) { return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup")) } var Bj = { id: "legend", _element: ig, start(e, t, n) { const i = e.legend = new ig({ ctx: e.ctx, options: n, chart: e }); Be.configure(e, i, n), Be.addBox(e, i) }, stop(e) { Be.removeBox(e, e.legend), delete e.legend }, beforeUpdate(e, t, n) { const i = e.legend; Be.configure(e, i, n), i.options = n }, afterUpdate(e) { const t = e.legend; t.buildLabels(), t.adjustHitBoxes() }, afterEvent(e, t) { t.replay || e.legend.handleEvent(t.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(e, t, n) { const i = t.datasetIndex, r = n.chart; r.isDatasetVisible(i) ? (r.hide(i), t.hidden = !0) : (r.show(i), t.hidden = !1) }, onHover: null, onLeave: null, labels: { color: e => e.chart.options.color, boxWidth: 40, padding: 10, generateLabels(e) { const t = e.data.datasets, { labels: { usePointStyle: n, pointStyle: i, textAlign: r, color: s, useBorderRadius: o, borderRadius: a } } = e.legend.options; return e._getSortedDatasetMetas().map(l => { const c = l.controller.getStyle(n ? 0 : void 0), d = Ve(c.borderWidth); return { text: t[l.index].label, fillStyle: c.backgroundColor, fontColor: s, hidden: !l.visible, lineCap: c.borderCapStyle, lineDash: c.borderDash, lineDashOffset: c.borderDashOffset, lineJoin: c.borderJoinStyle, lineWidth: (d.width + d.height) / 4, strokeStyle: c.borderColor, pointStyle: i || c.pointStyle, rotation: c.rotation, textAlign: r || c.textAlign, borderRadius: o && (a || c.borderRadius), datasetIndex: l.index } }, this) } }, title: { color: e => e.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: e => !e.startsWith("on"), labels: { _scriptable: e => !["generateLabels", "filter", "sort"].includes(e) } } }; class ff extends zt { constructor(t) { super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, n) { const i = this.options; if (this.left = 0, this.top = 0, !i.display) { this.width = this.height = this.right = this.bottom = 0; return } this.width = this.right = t, this.height = this.bottom = n; const r = ce(i.text) ? i.text.length : 1; this._padding = Ve(i.padding); const s = r * Pe(i.font).lineHeight + this._padding.height; this.isHorizontal() ? this.height = s : this.width = s } isHorizontal() { const t = this.options.position; return t === "top" || t === "bottom" } _drawArgs(t) { const { top: n, left: i, bottom: r, right: s, options: o } = this, a = o.align; let l = 0, c, d, f; return this.isHorizontal() ? (d = Fe(a, i, s), f = n + t, c = s - i) : (o.position === "left" ? (d = i + t, f = Fe(a, r, n), l = fe * -.5) : (d = s - t, f = Fe(a, n, r), l = fe * .5), c = r - n), { titleX: d, titleY: f, maxWidth: c, rotation: l } } draw() { const t = this.ctx, n = this.options; if (!n.display) return; const i = Pe(n.font), s = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: a, maxWidth: l, rotation: c } = this._drawArgs(s); vi(t, n.text, 0, 0, i, { color: n.color, maxWidth: l, rotation: c, textAlign: tf(n.align), textBaseline: "middle", translation: [o, a] }) } } function Wj(e, t) { const n = new ff({ ctx: e.ctx, options: t, chart: e }); Be.configure(e, n, t), Be.addBox(e, n), e.titleBlock = n } var Vj = { id: "title", _element: ff, start(e, t, n) { Wj(e, n) }, stop(e) { const t = e.titleBlock; Be.removeBox(e, t), delete e.titleBlock }, beforeUpdate(e, t, n) { const i = e.titleBlock; Be.configure(e, i, n), i.options = n }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const jo = new WeakMap; var Uj = { id: "subtitle", start(e, t, n) { const i = new ff({ ctx: e.ctx, options: n, chart: e }); Be.configure(e, i, n), Be.addBox(e, i), jo.set(e, i) }, stop(e) { Be.removeBox(e, jo.get(e)), jo.delete(e) }, beforeUpdate(e, t, n) { const i = jo.get(e); Be.configure(e, i, n), i.options = n }, defaults: { align: "center", display: !1, font: { weight: "normal" }, fullSize: !0, padding: 0, position: "top", text: "", weight: 1500 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const Hr = { average(e) { if (!e.length) return !1; let t, n, i = new Set, r = 0, s = 0; for (t = 0, n = e.length; t < n; ++t) { const a = e[t].element; if (a && a.hasValue()) { const l = a.tooltipPosition(); i.add(l.x), r += l.y, ++s } } return { x: [...i].reduce((a, l) => a + l) / i.size, y: r / s } }, nearest(e, t) { if (!e.length) return !1; let n = t.x, i = t.y, r = Number.POSITIVE_INFINITY, s, o, a; for (s = 0, o = e.length; s < o; ++s) { const l = e[s].element; if (l && l.hasValue()) { const c = l.getCenterPoint(), d = Ru(t, c); d < r && (r = d, a = l) } } if (a) { const l = a.tooltipPosition(); n = l.x, i = l.y } return { x: n, y: i } } }; function It(e, t) { return t && (ce(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e } function qt(e) {
    return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e
} function Hj(e, t) { const { element: n, datasetIndex: i, index: r } = t, s = e.getDatasetMeta(i).controller, { label: o, value: a } = s.getLabelAndValue(r); return { chart: e, label: o, parsed: s.getParsed(r), raw: e.data.datasets[i].data[r], formattedValue: a, dataset: s.getDataset(), dataIndex: r, datasetIndex: i, element: n } } function rg(e, t) { const n = e.chart.ctx, { body: i, footer: r, title: s } = e, { boxWidth: o, boxHeight: a } = t, l = Pe(t.bodyFont), c = Pe(t.titleFont), d = Pe(t.footerFont), f = s.length, h = r.length, p = i.length, g = Ve(t.padding); let v = g.height, x = 0, y = i.reduce((j, w) => j + w.before.length + w.lines.length + w.after.length, 0); if (y += e.beforeBody.length + e.afterBody.length, f && (v += f * c.lineHeight + (f - 1) * t.titleSpacing + t.titleMarginBottom), y) { const j = t.displayColors ? Math.max(a, l.lineHeight) : l.lineHeight; v += p * j + (y - p) * l.lineHeight + (y - 1) * t.bodySpacing } h && (v += t.footerMarginTop + h * d.lineHeight + (h - 1) * t.footerSpacing); let m = 0; const b = function (j) { x = Math.max(x, n.measureText(j).width + m) }; return n.save(), n.font = c.string, te(e.title, b), n.font = l.string, te(e.beforeBody.concat(e.afterBody), b), m = t.displayColors ? o + 2 + t.boxPadding : 0, te(i, j => { te(j.before, b), te(j.lines, b), te(j.after, b) }), m = 0, n.font = d.string, te(e.footer, b), n.restore(), x += g.width, { width: x, height: v } } function Yj(e, t) { const { y: n, height: i } = t; return n < i / 2 ? "top" : n > e.height - i / 2 ? "bottom" : "center" } function Xj(e, t, n, i) { const { x: r, width: s } = i, o = n.caretSize + n.caretPadding; if (e === "left" && r + s + o > t.width || e === "right" && r - s - o < 0) return !0 } function Kj(e, t, n, i) { const { x: r, width: s } = n, { width: o, chartArea: { left: a, right: l } } = e; let c = "center"; return i === "center" ? c = r <= (a + l) / 2 ? "left" : "right" : r <= s / 2 ? c = "left" : r >= o - s / 2 && (c = "right"), Xj(c, e, t, n) && (c = "center"), c } function sg(e, t, n) { const i = n.yAlign || t.yAlign || Yj(e, n); return { xAlign: n.xAlign || t.xAlign || Kj(e, t, n, i), yAlign: i } } function Gj(e, t) { let { x: n, width: i } = e; return t === "right" ? n -= i : t === "center" && (n -= i / 2), n } function Qj(e, t, n) { let { y: i, height: r } = e; return t === "top" ? i += n : t === "bottom" ? i -= r + n : i -= r / 2, i } function og(e, t, n, i) { const { caretSize: r, caretPadding: s, cornerRadius: o } = e, { xAlign: a, yAlign: l } = n, c = r + s, { topLeft: d, topRight: f, bottomLeft: h, bottomRight: p } = ui(o); let g = Gj(t, a); const v = Qj(t, l, c); return l === "center" ? a === "left" ? g += c : a === "right" && (g -= c) : a === "left" ? g -= Math.max(d, h) + r : a === "right" && (g += Math.max(f, p) + r), { x: De(g, 0, i.width - t.width), y: De(v, 0, i.height - t.height) } } function So(e, t, n) { const i = Ve(n.padding); return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - i.right : e.x + i.left } function ag(e) { return It([], qt(e)) } function qj(e, t, n) { return Hn(e, { tooltip: t, tooltipItems: n, type: "tooltip" }) } function lg(e, t) { const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks; return n ? e.override(n) : e } const i2 = { beforeTitle: Gt, title(e) { if (e.length > 0) { const t = e[0], n = t.chart.data.labels, i = n ? n.length : 0; if (this && this.options && this.options.mode === "dataset") return t.dataset.label || ""; if (t.label) return t.label; if (i > 0 && t.dataIndex < i) return n[t.dataIndex] } return "" }, afterTitle: Gt, beforeBody: Gt, beforeLabel: Gt, label(e) { if (this && this.options && this.options.mode === "dataset") return e.label + ": " + e.formattedValue || e.formattedValue; let t = e.dataset.label || ""; t && (t += ": "); const n = e.formattedValue; return G(n) || (t += n), t }, labelColor(e) { const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex); return { borderColor: n.borderColor, backgroundColor: n.backgroundColor, borderWidth: n.borderWidth, borderDash: n.borderDash, borderDashOffset: n.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(e) { const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex); return { pointStyle: n.pointStyle, rotation: n.rotation } }, afterLabel: Gt, afterBody: Gt, beforeFooter: Gt, footer: Gt, afterFooter: Gt }; function Ke(e, t, n, i) { const r = e[t].call(n, i); return typeof r > "u" ? i2[t].call(n, i) : r } class Wu extends zt { constructor(t) { super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(t) { this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const t = this._cachedAnimations; if (t) return t; const n = this.chart, i = this.options.setContext(this.getContext()), r = i.enabled && n.options.animation && i.animations, s = new L0(this.chart, r); return r._cacheable && (this._cachedAnimations = Object.freeze(s)), s } getContext() { return this.$context || (this.$context = qj(this.chart.getContext(), this, this._tooltipItems)) } getTitle(t, n) { const { callbacks: i } = n, r = Ke(i, "beforeTitle", this, t), s = Ke(i, "title", this, t), o = Ke(i, "afterTitle", this, t); let a = []; return a = It(a, qt(r)), a = It(a, qt(s)), a = It(a, qt(o)), a } getBeforeBody(t, n) { return ag(Ke(n.callbacks, "beforeBody", this, t)) } getBody(t, n) { const { callbacks: i } = n, r = []; return te(t, s => { const o = { before: [], lines: [], after: [] }, a = lg(i, s); It(o.before, qt(Ke(a, "beforeLabel", this, s))), It(o.lines, Ke(a, "label", this, s)), It(o.after, qt(Ke(a, "afterLabel", this, s))), r.push(o) }), r } getAfterBody(t, n) { return ag(Ke(n.callbacks, "afterBody", this, t)) } getFooter(t, n) { const { callbacks: i } = n, r = Ke(i, "beforeFooter", this, t), s = Ke(i, "footer", this, t), o = Ke(i, "afterFooter", this, t); let a = []; return a = It(a, qt(r)), a = It(a, qt(s)), a = It(a, qt(o)), a } _createItems(t) { const n = this._active, i = this.chart.data, r = [], s = [], o = []; let a = [], l, c; for (l = 0, c = n.length; l < c; ++l)a.push(Hj(this.chart, n[l])); return t.filter && (a = a.filter((d, f, h) => t.filter(d, f, h, i))), t.itemSort && (a = a.sort((d, f) => t.itemSort(d, f, i))), te(a, d => { const f = lg(t.callbacks, d); r.push(Ke(f, "labelColor", this, d)), s.push(Ke(f, "labelPointStyle", this, d)), o.push(Ke(f, "labelTextColor", this, d)) }), this.labelColors = r, this.labelPointStyles = s, this.labelTextColors = o, this.dataPoints = a, a } update(t, n) { const i = this.options.setContext(this.getContext()), r = this._active; let s, o = []; if (!r.length) this.opacity !== 0 && (s = { opacity: 0 }); else { const a = Hr[i.position].call(this, r, this._eventPosition); o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i); const l = this._size = rg(this, i), c = Object.assign({}, a, l), d = sg(this.chart, i, c), f = og(i, c, d, this.chart); this.xAlign = d.xAlign, this.yAlign = d.yAlign, s = { opacity: 1, x: f.x, y: f.y, width: l.width, height: l.height, caretX: a.x, caretY: a.y } } this._tooltipItems = o, this.$context = void 0, s && this._resolveAnimations().update(this, s), t && i.external && i.external.call(this, { chart: this.chart, tooltip: this, replay: n }) } drawCaret(t, n, i, r) { const s = this.getCaretPosition(t, i, r); n.lineTo(s.x1, s.y1), n.lineTo(s.x2, s.y2), n.lineTo(s.x3, s.y3) } getCaretPosition(t, n, i) { const { xAlign: r, yAlign: s } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: l, topRight: c, bottomLeft: d, bottomRight: f } = ui(a), { x: h, y: p } = t, { width: g, height: v } = n; let x, y, m, b, j, w; return s === "center" ? (j = p + v / 2, r === "left" ? (x = h, y = x - o, b = j + o, w = j - o) : (x = h + g, y = x + o, b = j - o, w = j + o), m = x) : (r === "left" ? y = h + Math.max(l, d) + o : r === "right" ? y = h + g - Math.max(c, f) - o : y = this.caretX, s === "top" ? (b = p, j = b - o, x = y - o, m = y + o) : (b = p + v, j = b + o, x = y + o, m = y - o), w = b), { x1: x, x2: y, x3: m, y1: b, y2: j, y3: w } } drawTitle(t, n, i) { const r = this.title, s = r.length; let o, a, l; if (s) { const c = qi(i.rtl, this.x, this.width); for (t.x = So(this, i.titleAlign, i), n.textAlign = c.textAlign(i.titleAlign), n.textBaseline = "middle", o = Pe(i.titleFont), a = i.titleSpacing, n.fillStyle = i.titleColor, n.font = o.string, l = 0; l < s; ++l)n.fillText(r[l], c.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, l + 1 === s && (t.y += i.titleMarginBottom - a) } } _drawColorBox(t, n, i, r, s) { const o = this.labelColors[i], a = this.labelPointStyles[i], { boxHeight: l, boxWidth: c } = s, d = Pe(s.bodyFont), f = So(this, "left", s), h = r.x(f), p = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0, g = n.y + p; if (s.usePointStyle) { const v = { radius: Math.min(c, l) / 2, pointStyle: a.pointStyle, rotation: a.rotation, borderWidth: 1 }, x = r.leftForLtr(h, c) + c / 2, y = g + l / 2; t.strokeStyle = s.multiKeyBackground, t.fillStyle = s.multiKeyBackground, Lu(t, v, x, y), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, Lu(t, v, x, y) } else { t.lineWidth = H(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0; const v = r.leftForLtr(h, c), x = r.leftForLtr(r.xPlus(h, 1), c - 2), y = ui(o.borderRadius); Object.values(y).some(m => m !== 0) ? (t.beginPath(), t.fillStyle = s.multiKeyBackground, Rs(t, { x: v, y: g, w: c, h: l, radius: y }), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), Rs(t, { x, y: g + 1, w: c - 2, h: l - 2, radius: y }), t.fill()) : (t.fillStyle = s.multiKeyBackground, t.fillRect(v, g, c, l), t.strokeRect(v, g, c, l), t.fillStyle = o.backgroundColor, t.fillRect(x, g + 1, c - 2, l - 2)) } t.fillStyle = this.labelTextColors[i] } drawBody(t, n, i) { const { body: r } = this, { bodySpacing: s, bodyAlign: o, displayColors: a, boxHeight: l, boxWidth: c, boxPadding: d } = i, f = Pe(i.bodyFont); let h = f.lineHeight, p = 0; const g = qi(i.rtl, this.x, this.width), v = function (O) { n.fillText(O, g.x(t.x + p), t.y + h / 2), t.y += h + s }, x = g.textAlign(o); let y, m, b, j, w, k, C; for (n.textAlign = o, n.textBaseline = "middle", n.font = f.string, t.x = So(this, x, i), n.fillStyle = i.bodyColor, te(this.beforeBody, v), p = a && x !== "right" ? o === "center" ? c / 2 + d : c + 2 + d : 0, j = 0, k = r.length; j < k; ++j) { for (y = r[j], m = this.labelTextColors[j], n.fillStyle = m, te(y.before, v), b = y.lines, a && b.length && (this._drawColorBox(n, t, j, g, i), h = Math.max(f.lineHeight, l)), w = 0, C = b.length; w < C; ++w)v(b[w]), h = f.lineHeight; te(y.after, v) } p = 0, h = f.lineHeight, te(this.afterBody, v), t.y -= s } drawFooter(t, n, i) { const r = this.footer, s = r.length; let o, a; if (s) { const l = qi(i.rtl, this.x, this.width); for (t.x = So(this, i.footerAlign, i), t.y += i.footerMarginTop, n.textAlign = l.textAlign(i.footerAlign), n.textBaseline = "middle", o = Pe(i.footerFont), n.fillStyle = i.footerColor, n.font = o.string, a = 0; a < s; ++a)n.fillText(r[a], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing } } drawBackground(t, n, i, r) { const { xAlign: s, yAlign: o } = this, { x: a, y: l } = t, { width: c, height: d } = i, { topLeft: f, topRight: h, bottomLeft: p, bottomRight: g } = ui(r.cornerRadius); n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.beginPath(), n.moveTo(a + f, l), o === "top" && this.drawCaret(t, n, i, r), n.lineTo(a + c - h, l), n.quadraticCurveTo(a + c, l, a + c, l + h), o === "center" && s === "right" && this.drawCaret(t, n, i, r), n.lineTo(a + c, l + d - g), n.quadraticCurveTo(a + c, l + d, a + c - g, l + d), o === "bottom" && this.drawCaret(t, n, i, r), n.lineTo(a + p, l + d), n.quadraticCurveTo(a, l + d, a, l + d - p), o === "center" && s === "left" && this.drawCaret(t, n, i, r), n.lineTo(a, l + f), n.quadraticCurveTo(a, l, a + f, l), n.closePath(), n.fill(), r.borderWidth > 0 && n.stroke() } _updateAnimationTarget(t) { const n = this.chart, i = this.$animations, r = i && i.x, s = i && i.y; if (r || s) { const o = Hr[t.position].call(this, this._active, this._eventPosition); if (!o) return; const a = this._size = rg(this, t), l = Object.assign({}, o, this._size), c = sg(n, t, l), d = og(t, l, c, n); (r._to !== d.x || s._to !== d.y) && (this.xAlign = c.xAlign, this.yAlign = c.yAlign, this.width = a.width, this.height = a.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, d)) } } _willRender() { return !!this.opacity } draw(t) { const n = this.options.setContext(this.getContext()); let i = this.opacity; if (!i) return; this._updateAnimationTarget(n); const r = { width: this.width, height: this.height }, s = { x: this.x, y: this.y }; i = Math.abs(i) < .001 ? 0 : i; const o = Ve(n.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length; n.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(s, t, r, n), D0(t, n.textDirection), s.y += o.top, this.drawTitle(s, t, n), this.drawBody(s, t, n), this.drawFooter(s, t, n), T0(t, n.textDirection), t.restore()) } getActiveElements() { return this._active || [] } setActiveElements(t, n) { const i = this._active, r = t.map(({ datasetIndex: a, index: l }) => { const c = this.chart.getDatasetMeta(a); if (!c) throw new Error("Cannot find a dataset at index " + a); return { datasetIndex: a, element: c.data[l], index: l } }), s = !Sa(i, r), o = this._positionChanged(r, n); (s || o) && (this._active = r, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0)) } handleEvent(t, n, i = !0) { if (n && this._ignoreReplayEvents) return !1; this._ignoreReplayEvents = !1; const r = this.options, s = this._active || [], o = this._getActiveElements(t, s, n, i), a = this._positionChanged(o, t), l = n || !Sa(o, s) || a; return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = { x: t.x, y: t.y }, this.update(!0, n))), l } _getActiveElements(t, n, i, r) { const s = this.options; if (t.type === "mouseout") return []; if (!r) return n.filter(a => this.chart.data.datasets[a.datasetIndex] && this.chart.getDatasetMeta(a.datasetIndex).controller.getParsed(a.index) !== void 0); const o = this.chart.getElementsAtEventForMode(t, s.mode, s, i); return s.reverse && o.reverse(), o } _positionChanged(t, n) { const { caretX: i, caretY: r, options: s } = this, o = Hr[s.position].call(this, t, n); return o !== !1 && (i !== o.x || r !== o.y) } } E(Wu, "positioners", Hr); var Jj = { id: "tooltip", _element: Wu, positioners: Hr, afterInit(e, t, n) { n && (e.tooltip = new Wu({ chart: e, options: n })) }, beforeUpdate(e, t, n) { e.tooltip && e.tooltip.initialize(n) }, reset(e, t, n) { e.tooltip && e.tooltip.initialize(n) }, afterDraw(e) { const t = e.tooltip; if (t && t._willRender()) { const n = { tooltip: t }; if (e.notifyPlugins("beforeTooltipDraw", { ...n, cancelable: !0 }) === !1) return; t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n) } }, afterEvent(e, t) { if (e.tooltip) { const n = t.replay; e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (e, t) => t.bodyFont.size, boxWidth: (e, t) => t.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, boxPadding: 0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: i2 }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: e => e !== "filter" && e !== "itemSort" && e !== "external", _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, Zj = Object.freeze({ __proto__: null, Colors: dj, Decimation: gj, Filler: zj, Legend: Bj, SubTitle: Uj, Title: Vj, Tooltip: Jj }); const eS = (e, t, n, i) => (typeof t == "string" ? (n = e.push(t) - 1, i.unshift({ index: n, label: t })) : isNaN(t) && (n = null), n); function tS(e, t, n, i) { const r = e.indexOf(t); if (r === -1) return eS(e, t, n, i); const s = e.lastIndexOf(t); return r !== s ? n : r } const nS = (e, t) => e === null ? null : De(Math.round(e), 0, t); function cg(e) { const t = this.getLabels(); return e >= 0 && e < t.length ? t[e] : e } class Ta extends _i { constructor(t) { super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [] } init(t) { const n = this._addedLabels; if (n.length) { const i = this.getLabels(); for (const { index: r, label: s } of n) i[r] === s && i.splice(r, 1); this._addedLabels = [] } super.init(t) } parse(t, n) { if (G(t)) return null; const i = this.getLabels(); return n = isFinite(n) && i[n] === t ? n : tS(i, t, B(n, t), this._addedLabels), nS(n, i.length - 1) } determineDataLimits() { const { minDefined: t, maxDefined: n } = this.getUserBounds(); let { min: i, max: r } = this.getMinMax(!0); this.options.bounds === "ticks" && (t || (i = 0), n || (r = this.getLabels().length - 1)), this.min = i, this.max = r } buildTicks() { const t = this.min, n = this.max, i = this.options.offset, r = []; let s = this.getLabels(); s = t === 0 && n === s.length - 1 ? s : s.slice(t, n + 1), this._valueRange = Math.max(s.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0); for (let o = t; o <= n; o++)r.push({ value: o }); return r } getLabelForValue(t) { return cg.call(this, t) } configure() { super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels) } getPixelForValue(t) { return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getPixelForTick(t) { const n = this.ticks; return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value) } getValueForPixel(t) { return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange) } getBasePixel() { return this.bottom } } E(Ta, "id", "category"), E(Ta, "defaults", { ticks: { callback: cg } }); function iS(e, t) { const n = [], { bounds: r, step: s, min: o, max: a, precision: l, count: c, maxTicks: d, maxDigits: f, includeBounds: h } = e, p = s || 1, g = d - 1, { min: v, max: x } = t, y = !G(o), m = !G(a), b = !G(c), j = (x - v) / (f + 1); let w = ip((x - v) / g / p) * p, k, C, O, D; if (w < 1e-14 && !y && !m) return [{ value: v }, { value: x }]; D = Math.ceil(x / w) - Math.floor(v / w), D > g && (w = ip(D * w / g / p) * p), G(l) || (k = Math.pow(10, l), w = Math.ceil(w * k) / k), r === "ticks" ? (C = Math.floor(v / w) * w, O = Math.ceil(x / w) * w) : (C = v, O = x), y && m && s && q_((a - o) / s, w / 1e3) ? (D = Math.round(Math.min((a - o) / w, d)), w = (a - o) / D, C = o, O = a) : b ? (C = y ? o : C, O = m ? a : O, D = c - 1, w = (O - C) / D) : (D = (O - C) / w, rs(D, Math.round(D), w / 1e3) ? D = Math.round(D) : D = Math.ceil(D)); const T = Math.max(rp(w), rp(C)); k = Math.pow(10, G(l) ? T : l), C = Math.round(C * k) / k, O = Math.round(O * k) / k; let A = 0; for (y && (h && C !== o ? (n.push({ value: o }), C < o && A++, rs(Math.round((C + A * w) * k) / k, o, ug(o, j, e)) && A++) : C < o && A++); A < D; ++A) { const $ = Math.round((C + A * w) * k) / k; if (m && $ > a) break; n.push({ value: $ }) } return m && h && O !== a ? n.length && rs(n[n.length - 1].value, a, ug(a, j, e)) ? n[n.length - 1].value = a : n.push({ value: a }) : (!m || O === a) && n.push({ value: O }), n } function ug(e, t, { horizontal: n, minRotation: i }) { const r = Mt(i), s = (n ? Math.sin(r) : Math.cos(r)) || .001, o = .75 * t * ("" + e).length; return Math.min(t / s, o) } class Na extends _i { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(t, n) { return G(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions() { const { beginAtZero: t } = this.options, { minDefined: n, maxDefined: i } = this.getUserBounds(); let { min: r, max: s } = this; const o = l => r = n ? r : l, a = l => s = i ? s : l; if (t) { const l = Yt(r), c = Yt(s); l < 0 && c < 0 ? a(0) : l > 0 && c > 0 && o(0) } if (r === s) { let l = s === 0 ? 1 : Math.abs(s * .05); a(s + l), t || o(r - l) } this.min = r, this.max = s } getTickLimit() { const t = this.options.ticks; let { maxTicksLimit: n, stepSize: i } = t, r; return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), n = n || 11), n && (r = Math.min(n, r)), r } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const t = this.options, n = t.ticks; let i = this.getTickLimit(); i = Math.max(2, i); const r = { maxTicks: i, bounds: t.bounds, min: t.min, max: t.max, precision: n.precision, step: n.stepSize, count: n.count, maxDigits: this._maxDigits(), horizontal: this.isHorizontal(), minRotation: n.minRotation || 0, includeBounds: n.includeBounds !== !1 }, s = this._range || this, o = iS(r, s); return t.bounds === "ticks" && p0(o, this, "value"), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o } configure() { const t = this.ticks; let n = this.min, i = this.max; if (super.configure(), this.options.offset && t.length) { const r = (i - n) / Math.max(t.length - 1, 1) / 2; n -= r, i += r } this._startValue = n, this._endValue = i, this._valueRange = i - n } getLabelForValue(t) { return Ys(t, this.chart.options.locale, this.options.ticks.format) } } class Ra extends Na { determineDataLimits() { const { min: t, max: n } = this.getMinMax(!0); this.min = xe(t) ? t : 0, this.max = xe(n) ? n : 1, this.handleTickRangeOptions() } computeTickLimit() { const t = this.isHorizontal(), n = t ? this.width : this.height, i = Mt(this.options.ticks.minRotation), r = (t ? Math.sin(i) : Math.cos(i)) || .001, s = this._resolveTickFontOptions(0); return Math.ceil(n / Math.min(40, s.lineHeight / r)) } getPixelForValue(t) { return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel(t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } } E(Ra, "id", "linear"), E(Ra, "defaults", { ticks: { callback: rl.formatters.numeric } }); const Ls = e => Math.floor(Sn(e)), Qn = (e, t) => Math.pow(10, Ls(e) + t); function dg(e) { return e / Math.pow(10, Ls(e)) === 1 } function fg(e, t, n) { const i = Math.pow(10, n), r = Math.floor(e / i); return Math.ceil(t / i) - r } function rS(e, t) { const n = t - e; let i = Ls(n); for (; fg(e, t, i) > 10;)i++; for (; fg(e, t, i) < 10;)i--; return Math.min(i, Ls(e)) } function sS(e, { min: t, max: n }) { t = nt(e.min, t); const i = [], r = Ls(t); let s = rS(t, n), o = s < 0 ? Math.pow(10, Math.abs(s)) : 1; const a = Math.pow(10, s), l = r > s ? Math.pow(10, r) : 0, c = Math.round((t - l) * o) / o, d = Math.floor((t - l) / a / 10) * a * 10; let f = Math.floor((c - d) / Math.pow(10, s)), h = nt(e.min, Math.round((l + d + f * Math.pow(10, s)) * o) / o); for (; h < n;)i.push({ value: h, major: dg(h), significand: f }), f >= 10 ? f = f < 15 ? 15 : 20 : f++, f >= 20 && (s++, f = 2, o = s >= 0 ? 1 : o), h = Math.round((l + d + f * Math.pow(10, s)) * o) / o; const p = nt(e.max, h); return i.push({ value: p, major: dg(p), significand: f }), i } class Vu extends _i { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(t, n) { const i = Na.prototype.parse.apply(this, [t, n]); if (i === 0) { this._zero = !0; return } return xe(i) && i > 0 ? i : null } determineDataLimits() { const { min: t, max: n } = this.getMinMax(!0); this.min = xe(t) ? Math.max(0, t) : null, this.max = xe(n) ? Math.max(0, n) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !xe(this._userMin) && (this.min = t === Qn(this.min, 0) ? Qn(this.min, -1) : Qn(this.min, 0)), this.handleTickRangeOptions() } handleTickRangeOptions() { const { minDefined: t, maxDefined: n } = this.getUserBounds(); let i = this.min, r = this.max; const s = a => i = t ? i : a, o = a => r = n ? r : a; i === r && (i <= 0 ? (s(1), o(10)) : (s(Qn(i, -1)), o(Qn(r, 1)))), i <= 0 && s(Qn(r, -1)), r <= 0 && o(Qn(i, 1)), this.min = i, this.max = r } buildTicks() { const t = this.options, n = { min: this._userMin, max: this._userMax }, i = sS(n, this); return t.bounds === "ticks" && p0(i, this, "value"), t.reverse ? (i.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), i } getLabelForValue(t) { return t === void 0 ? "0" : Ys(t, this.chart.options.locale, this.options.ticks.format) } configure() { const t = this.min; super.configure(), this._startValue = Sn(t), this._valueRange = Sn(this.max) - Sn(t) } getPixelForValue(t) { return (t === void 0 || t === 0) && (t = this.min), t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (Sn(t) - this._startValue) / this._valueRange) } getValueForPixel(t) { const n = this.getDecimalForPixel(t); return Math.pow(10, this._startValue + n * this._valueRange) } } E(Vu, "id", "logarithmic"), E(Vu, "defaults", { ticks: { callback: rl.formatters.logarithmic, major: { enabled: !0 } } }); function Uu(e) { const t = e.ticks; if (t.display && e.display) { const n = Ve(t.backdropPadding); return B(t.font && t.font.size, be.font.size) + n.height } return 0 } function oS(e, t, n) { return n = ce(n) ? n : [n], { w: p5(e, t.string, n), h: n.length * t.lineHeight } } function hg(e, t, n, i, r) { return e === i || e === r ? { start: t - n / 2, end: t + n / 2 } : e < i || e > r ? { start: t - n, end: t } : { start: t, end: t + n } } function aS(e) { const t = { l: e.left + e._padding.left, r: e.right - e._padding.right, t: e.top + e._padding.top, b: e.bottom - e._padding.bottom }, n = Object.assign({}, t), i = [], r = [], s = e._pointLabels.length, o = e.options.pointLabels, a = o.centerPointLabels ? fe / s : 0; for (let l = 0; l < s; l++) { const c = o.setContext(e.getPointLabelContext(l)); r[l] = c.padding; const d = e.getPointPosition(l, e.drawingArea + r[l], a), f = Pe(c.font), h = oS(e.ctx, f, e._pointLabels[l]); i[l] = h; const p = rt(e.getIndexAngle(l) + a), g = Math.round(Zd(p)), v = hg(g, d.x, h.w, 0, 180), x = hg(g, d.y, h.h, 90, 270); lS(n, t, p, v, x) } e.setCenterPoint(t.l - n.l, n.r - t.r, t.t - n.t, n.b - t.b), e._pointLabelItems = dS(e, i, r) } function lS(e, t, n, i, r) { const s = Math.abs(Math.sin(n)), o = Math.abs(Math.cos(n)); let a = 0, l = 0; i.start < t.l ? (a = (t.l - i.start) / s, e.l = Math.min(e.l, t.l - a)) : i.end > t.r && (a = (i.end - t.r) / s, e.r = Math.max(e.r, t.r + a)), r.start < t.t ? (l = (t.t - r.start) / o, e.t = Math.min(e.t, t.t - l)) : r.end > t.b && (l = (r.end - t.b) / o, e.b = Math.max(e.b, t.b + l)) } function cS(e, t, n) { const i = e.drawingArea, { extra: r, additionalAngle: s, padding: o, size: a } = n, l = e.getPointPosition(t, i + r + o, s), c = Math.round(Zd(rt(l.angle + we))), d = pS(l.y, a.h, c), f = fS(c), h = hS(l.x, a.w, f); return { visible: !0, x: l.x, y: d, textAlign: f, left: h, top: d, right: h + a.w, bottom: d + a.h } } function uS(e, t) { if (!t) return !0; const { left: n, top: i, right: r, bottom: s } = e; return !(an({ x: n, y: i }, t) || an({ x: n, y: s }, t) || an({ x: r, y: i }, t) || an({ x: r, y: s }, t)) } function dS(e, t, n) { const i = [], r = e._pointLabels.length, s = e.options, { centerPointLabels: o, display: a } = s.pointLabels, l = { extra: Uu(s) / 2, additionalAngle: o ? fe / r : 0 }; let c; for (let d = 0; d < r; d++) { l.padding = n[d], l.size = t[d]; const f = cS(e, d, l); i.push(f), a === "auto" && (f.visible = uS(f, c), f.visible && (c = f)) } return i } function fS(e) { return e === 0 || e === 180 ? "center" : e < 180 ? "left" : "right" } function hS(e, t, n) { return n === "right" ? e -= t : n === "center" && (e -= t / 2), e } function pS(e, t, n) { return n === 90 || n === 270 ? e -= t / 2 : (n > 270 || n < 90) && (e -= t), e } function gS(e, t, n) { const { left: i, top: r, right: s, bottom: o } = n, { backdropColor: a } = t; if (!G(a)) { const l = ui(t.borderRadius), c = Ve(t.backdropPadding); e.fillStyle = a; const d = i - c.left, f = r - c.top, h = s - i + c.width, p = o - r + c.height; Object.values(l).some(g => g !== 0) ? (e.beginPath(), Rs(e, { x: d, y: f, w: h, h: p, radius: l }), e.fill()) : e.fillRect(d, f, h, p) } } function mS(e, t) { const { ctx: n, options: { pointLabels: i } } = e; for (let r = t - 1; r >= 0; r--) { const s = e._pointLabelItems[r]; if (!s.visible) continue; const o = i.setContext(e.getPointLabelContext(r)); gS(n, o, s); const a = Pe(o.font), { x: l, y: c, textAlign: d } = s; vi(n, e._pointLabels[r], l, c + a.lineHeight / 2, a, { color: o.color, textAlign: d, textBaseline: "middle" }) } } function r2(e, t, n, i) { const { ctx: r } = e; if (n) r.arc(e.xCenter, e.yCenter, t, 0, de); else { let s = e.getPointPosition(0, t); r.moveTo(s.x, s.y); for (let o = 1; o < i; o++)s = e.getPointPosition(o, t), r.lineTo(s.x, s.y) } } function yS(e, t, n, i, r) { const s = e.ctx, o = t.circular, { color: a, lineWidth: l } = t; !o && !i || !a || !l || n < 0 || (s.save(), s.strokeStyle = a, s.lineWidth = l, s.setLineDash(r.dash), s.lineDashOffset = r.dashOffset, s.beginPath(), r2(e, n, o, i), s.closePath(), s.stroke(), s.restore()) } function vS(e, t, n) { return Hn(e, { label: n, index: t, type: "pointLabel" }) } class Yr extends Na { constructor(t) { super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const t = this._padding = Ve(Uu(this.options) / 2), n = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height; this.xCenter = Math.floor(this.left + n / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(n, i) / 2) } determineDataLimits() { const { min: t, max: n } = this.getMinMax(!1); this.min = xe(t) && !isNaN(t) ? t : 0, this.max = xe(n) && !isNaN(n) ? n : 0, this.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Uu(this.options)) } generateTickLabels(t) { Na.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((n, i) => { const r = oe(this.options.pointLabels.callback, [n, i], this); return r || r === 0 ? r : "" }).filter((n, i) => this.chart.getDataVisibility(i)) } fit() { const t = this.options; t.display && t.pointLabels.display ? aS(this) : this.setCenterPoint(0, 0, 0, 0) } setCenterPoint(t, n, i, r) { this.xCenter += Math.floor((t - n) / 2), this.yCenter += Math.floor((i - r) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, n, i, r)) } getIndexAngle(t) { const n = de / (this._pointLabels.length || 1), i = this.options.startAngle || 0; return rt(t * n + Mt(i)) } getDistanceFromCenterForValue(t) { if (G(t)) return NaN; const n = this.drawingArea / (this.max - this.min); return this.options.reverse ? (this.max - t) * n : (t - this.min) * n } getValueForDistanceFromCenter(t) { if (G(t)) return NaN; const n = t / (this.drawingArea / (this.max - this.min)); return this.options.reverse ? this.max - n : this.min + n } getPointLabelContext(t) { const n = this._pointLabels || []; if (t >= 0 && t < n.length) { const i = n[t]; return vS(this.getContext(), t, i) } } getPointPosition(t, n, i = 0) { const r = this.getIndexAngle(t) - we + i; return { x: Math.cos(r) * n + this.xCenter, y: Math.sin(r) * n + this.yCenter, angle: r } } getPointPositionForValue(t, n) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(n)) } getBasePosition(t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition(t) { const { left: n, top: i, right: r, bottom: s } = this._pointLabelItems[t]; return { left: n, top: i, right: r, bottom: s } } drawBackground() { const { backgroundColor: t, grid: { circular: n } } = this.options; if (t) { const i = this.ctx; i.save(), i.beginPath(), r2(this, this.getDistanceFromCenterForValue(this._endValue), n, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore() } } drawGrid() { const t = this.ctx, n = this.options, { angleLines: i, grid: r, border: s } = n, o = this._pointLabels.length; let a, l, c; if (n.pointLabels.display && mS(this, o), r.display && this.ticks.forEach((d, f) => { if (f !== 0 || f === 0 && this.min < 0) { l = this.getDistanceFromCenterForValue(d.value); const h = this.getContext(f), p = r.setContext(h), g = s.setContext(h); yS(this, p, l, o, g) } }), i.display) { for (t.save(), a = o - 1; a >= 0; a--) { const d = i.setContext(this.getPointLabelContext(a)), { color: f, lineWidth: h } = d; !h || !f || (t.lineWidth = h, t.strokeStyle = f, t.setLineDash(d.borderDash), t.lineDashOffset = d.borderDashOffset, l = this.getDistanceFromCenterForValue(n.ticks.reverse ? this.min : this.max), c = this.getPointPosition(a, l), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(c.x, c.y), t.stroke()) } t.restore() } } drawBorder() { } drawLabels() { const t = this.ctx, n = this.options, i = n.ticks; if (!i.display) return; const r = this.getIndexAngle(0); let s, o; t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(r), t.textAlign = "center", t.textBaseline = "middle", this.ticks.forEach((a, l) => { if (l === 0 && this.min >= 0 && !n.reverse) return; const c = i.setContext(this.getContext(l)), d = Pe(c.font); if (s = this.getDistanceFromCenterForValue(this.ticks[l].value), c.showLabelBackdrop) { t.font = d.string, o = t.measureText(a.label).width, t.fillStyle = c.backdropColor; const f = Ve(c.backdropPadding); t.fillRect(-o / 2 - f.left, -s - d.size / 2 - f.top, o + f.width, d.size + f.height) } vi(t, a.label, 0, -s, d, { color: c.color, strokeColor: c.textStrokeColor, strokeWidth: c.textStrokeWidth }) }), t.restore() } drawTitle() { } } E(Yr, "id", "radialLinear"), E(Yr, "defaults", { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: rl.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback(t) { return t }, padding: 5, centerPointLabels: !1 } }), E(Yr, "defaultRoutes", { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }), E(Yr, "descriptors", { angleLines: { _fallback: "grid" } }); const cl = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Qe = Object.keys(cl); function pg(e, t) { return e - t } function gg(e, t) { if (G(t)) return null; const n = e._adapter, { parser: i, round: r, isoWeekday: s } = e._parseOpts; let o = t; return typeof i == "function" && (o = i(o)), xe(o) || (o = typeof i == "string" ? n.parse(o, i) : n.parse(o)), o === null ? null : (r && (o = r === "week" && (or(s) || s === !0) ? n.startOf(o, "isoWeek", s) : n.startOf(o, r)), +o) } function mg(e, t, n, i) { const r = Qe.length; for (let s = Qe.indexOf(e); s < r - 1; ++s) { const o = cl[Qe[s]], a = o.steps ? o.steps : Number.MAX_SAFE_INTEGER; if (o.common && Math.ceil((n - t) / (a * o.size)) <= i) return Qe[s] } return Qe[r - 1] } function xS(e, t, n, i, r) { for (let s = Qe.length - 1; s >= Qe.indexOf(n); s--) { const o = Qe[s]; if (cl[o].common && e._adapter.diff(r, i, o) >= t - 1) return o } return Qe[n ? Qe.indexOf(n) : 0] } function bS(e) { for (let t = Qe.indexOf(e) + 1, n = Qe.length; t < n; ++t)if (cl[Qe[t]].common) return Qe[t] } function yg(e, t, n) { if (!n) e[t] = !0; else if (n.length) { const { lo: i, hi: r } = ef(n, t), s = n[i] >= t ? n[i] : n[r]; e[s] = !0 } } function _S(e, t, n, i) { const r = e._adapter, s = +r.startOf(t[0].value, i), o = t[t.length - 1].value; let a, l; for (a = s; a <= o; a = +r.add(a, 1, i))l = n[a], l >= 0 && (t[l].major = !0); return t } function vg(e, t, n) { const i = [], r = {}, s = t.length; let o, a; for (o = 0; o < s; ++o)a = t[o], r[a] = o, i.push({ value: a, major: !1 }); return s === 0 || !n ? i : _S(e, i, r, n) } class As extends _i { constructor(t) { super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(t, n = {}) { const i = t.time || (t.time = {}), r = this._adapter = new Mw._date(t.adapters.date); r.init(n), is(i.displayFormats, r.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(t), this._normalized = n.normalized } parse(t, n) { return t === void 0 ? null : gg(this, t) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const t = this.options, n = this._adapter, i = t.time.unit || "day"; let { min: r, max: s, minDefined: o, maxDefined: a } = this.getUserBounds(); function l(c) { !o && !isNaN(c.min) && (r = Math.min(r, c.min)), !a && !isNaN(c.max) && (s = Math.max(s, c.max)) } (!o || !a) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), r = xe(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i), s = xe(s) && !isNaN(s) ? s : +n.endOf(Date.now(), i) + 1, this.min = Math.min(r, s - 1), this.max = Math.max(r + 1, s) } _getLabelBounds() { const t = this.getLabelTimestamps(); let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return t.length && (n = t[0], i = t[t.length - 1]), { min: n, max: i } } buildTicks() { const t = this.options, n = t.time, i = t.ticks, r = i.source === "labels" ? this.getLabelTimestamps() : this._generate(); t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]); const s = this.min, o = this.max, a = t5(r, s, o); return this._unit = n.unit || (i.autoSkip ? mg(n.minUnit, this.min, this.max, this._getLabelCapacity(s)) : xS(this, a.length, n.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : bS(this._unit), this.initOffsets(r), t.reverse && a.reverse(), vg(this, a, this._majorUnit) } afterAutoSkip() { this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value)) } initOffsets(t = []) { let n = 0, i = 0, r, s; this.options.offset && t.length && (r = this.getDecimalForValue(t[0]), t.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(t[1]) - r) / 2, s = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? i = s : i = (s - this.getDecimalForValue(t[t.length - 2])) / 2); const o = t.length < 3 ? .5 : .25; n = De(n, 0, o), i = De(i, 0, o), this._offsets = { start: n, end: i, factor: 1 / (n + 1 + i) } } _generate() { const t = this._adapter, n = this.min, i = this.max, r = this.options, s = r.time, o = s.unit || mg(s.minUnit, n, i, this._getLabelCapacity(n)), a = B(r.ticks.stepSize, 1), l = o === "week" ? s.isoWeekday : !1, c = or(l) || l === !0, d = {}; let f = n, h, p; if (c && (f = +t.startOf(f, "isoWeek", l)), f = +t.startOf(f, c ? "day" : o), t.diff(i, n, o) > 1e5 * a) throw new Error(n + " and " + i + " are too far apart with stepSize of " + a + " " + o); const g = r.ticks.source === "data" && this.getDataTimestamps(); for (h = f, p = 0; h < i; h = +t.add(h, a, o), p++)yg(d, h, g); return (h === i || r.bounds === "ticks" || p === 1) && yg(d, h, g), Object.keys(d).sort(pg).map(v => +v) } getLabelForValue(t) { const n = this._adapter, i = this.options.time; return i.tooltipFormat ? n.format(t, i.tooltipFormat) : n.format(t, i.displayFormats.datetime) } format(t, n) { const r = this.options.time.displayFormats, s = this._unit, o = n || r[s]; return this._adapter.format(t, o) } _tickFormatFunction(t, n, i, r) { const s = this.options, o = s.ticks.callback; if (o) return oe(o, [t, n, i], this); const a = s.time.displayFormats, l = this._unit, c = this._majorUnit, d = l && a[l], f = c && a[c], h = i[n], p = c && f && h && h.major; return this._adapter.format(t, r || (p ? f : d)) } generateTickLabels(t) { let n, i, r; for (n = 0, i = t.length; n < i; ++n)r = t[n], r.label = this._tickFormatFunction(r.value, n, t) } getDecimalForValue(t) { return t === null ? NaN : (t - this.min) / (this.max - this.min) } getPixelForValue(t) { const n = this._offsets, i = this.getDecimalForValue(t); return this.getPixelForDecimal((n.start + i) * n.factor) } getValueForPixel(t) { const n = this._offsets, i = this.getDecimalForPixel(t) / n.factor - n.end; return this.min + i * (this.max - this.min) } _getLabelSize(t) { const n = this.options.ticks, i = this.ctx.measureText(t).width, r = Mt(this.isHorizontal() ? n.maxRotation : n.minRotation), s = Math.cos(r), o = Math.sin(r), a = this._resolveTickFontOptions(0).size; return { w: i * s + a * o, h: i * o + a * s } } _getLabelCapacity(t) { const n = this.options.time, i = n.displayFormats, r = i[n.unit] || i.millisecond, s = this._tickFormatFunction(t, 0, vg(this, [t], this._majorUnit), r), o = this._getLabelSize(s), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1; return a > 0 ? a : 1 } getDataTimestamps() { let t = this._cache.data || [], n, i; if (t.length) return t; const r = this.getMatchingVisibleMetas(); if (this._normalized && r.length) return this._cache.data = r[0].controller.getAllParsedValues(this); for (n = 0, i = r.length; n < i; ++n)t = t.concat(r[n].controller.getAllParsedValues(this)); return this._cache.data = this.normalize(t) } getLabelTimestamps() { const t = this._cache.labels || []; let n, i; if (t.length) return t; const r = this.getLabels(); for (n = 0, i = r.length; n < i; ++n)t.push(gg(this, r[n])); return this._cache.labels = this._normalized ? t : this.normalize(t) } normalize(t) { return y0(t.sort(pg)) } } E(As, "id", "time"), E(As, "defaults", { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", callback: !1, major: { enabled: !1 } } }); function ko(e, t, n) { let i = 0, r = e.length - 1, s, o, a, l; n ? (t >= e[i].pos && t <= e[r].pos && ({ lo: i, hi: r } = on(e, "pos", t)), { pos: s, time: a } = e[i], { pos: o, time: l } = e[r]) : (t >= e[i].time && t <= e[r].time && ({ lo: i, hi: r } = on(e, "time", t)), { time: s, pos: a } = e[i], { time: o, pos: l } = e[r]); const c = o - s; return c ? a + (l - a) * (t - s) / c : a } class Hu extends As { constructor(t) { super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0 } initOffsets() { const t = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(t); this._minPos = ko(n, this.min), this._tableRange = ko(n, this.max) - this._minPos, super.initOffsets(t) } buildLookupTable(t) { const { min: n, max: i } = this, r = [], s = []; let o, a, l, c, d; for (o = 0, a = t.length; o < a; ++o)c = t[o], c >= n && c <= i && r.push(c); if (r.length < 2) return [{ time: n, pos: 0 }, { time: i, pos: 1 }]; for (o = 0, a = r.length; o < a; ++o)d = r[o + 1], l = r[o - 1], c = r[o], Math.round((d + l) / 2) !== c && s.push({ time: c, pos: o / (a - 1) }); return s } _generate() { const t = this.min, n = this.max; let i = super.getDataTimestamps(); return (!i.includes(t) || !i.length) && i.splice(0, 0, t), (!i.includes(n) || i.length === 1) && i.push(n), i.sort((r, s) => r - s) } _getTimestampsForTable() { let t = this._cache.all || []; if (t.length) return t; const n = this.getDataTimestamps(), i = this.getLabelTimestamps(); return n.length && i.length ? t = this.normalize(n.concat(i)) : t = n.length ? n : i, t = this._cache.all = t, t } getDecimalForValue(t) { return (ko(this._table, t) - this._minPos) / this._tableRange } getValueForPixel(t) { const n = this._offsets, i = this.getDecimalForPixel(t) / n.factor - n.end; return ko(this._table, i * this._tableRange + this._minPos, !0) } } E(Hu, "id", "timeseries"), E(Hu, "defaults", As.defaults); var wS = Object.freeze({ __proto__: null, CategoryScale: Ta, LinearScale: Ra, LogarithmicScale: Vu, RadialLinearScale: Yr, TimeScale: As, TimeSeriesScale: Hu }); const jS = [Ew, sj, Zj, wS], s2 = "label"; function xg(e, t) { typeof e == "function" ? e(t) : e && (e.current = t) } function SS(e, t) { const n = e.options; n && t && Object.assign(n, t) } function o2(e, t) { e.labels = t } function a2(e, t) { let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : s2; const i = []; e.datasets = t.map(r => { const s = e.datasets.find(o => o[n] === r[n]); return !s || !r.data || i.includes(s) ? { ...r } : (i.push(s), Object.assign(s, r), s) }) } function kS(e) { let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s2; const n = { labels: [], datasets: [] }; return o2(n, e.labels), a2(n, e.datasets, t), n } function CS(e, t) { const { height: n = 150, width: i = 300, redraw: r = !1, datasetIdKey: s, type: o, data: a, options: l, plugins: c = [], fallbackContent: d, updateMode: f, ...h } = e, p = S.useRef(null), g = S.useRef(), v = () => { p.current && (g.current = new ll(p.current, { type: o, data: kS(a, s), options: l && { ...l }, plugins: c }), xg(t, g.current)) }, x = () => { xg(t, null), g.current && (g.current.destroy(), g.current = null) }; return S.useEffect(() => { !r && g.current && l && SS(g.current, l) }, [r, l]), S.useEffect(() => { !r && g.current && o2(g.current.config.data, a.labels) }, [r, a.labels]), S.useEffect(() => { !r && g.current && a.datasets && a2(g.current.config.data, a.datasets, s) }, [r, a.datasets]), S.useEffect(() => { g.current && (r ? (x(), setTimeout(v)) : g.current.update(f)) }, [r, l, a.labels, a.datasets, f]), S.useEffect(() => { g.current && (x(), setTimeout(v)) }, [o]), S.useEffect(() => (v(), () => x()), []), I.createElement("canvas", Object.assign({ ref: p, role: "img", height: n, width: i }, h), d) } const OS = S.forwardRef(CS); function l2(e, t) { return ll.register(t), S.forwardRef((n, i) => I.createElement(OS, Object.assign({}, n, { ref: i, type: e }))) } const PS = l2("bar", Ji), bg = l2("pie", Ea); ll.register(...jS, Ta, Ra, Ji, ls); const ES = () => { const [e, t] = S.useState({ coordinators: 0, classes: 0, courses: 0 }), [n, i] = S.useState(!0), [r, s] = S.useState({ coordinatorData: {}, classData: { labels: [], datasets: [{ data: [] }] }, courseData: { labels: [], datasets: [{ data: [] }] } }); return S.useEffect(() => { (() => { const a = { labels: ["North", "South", "East", "West"], datasets: [{ label: "Coordinators by Region", data: [12, 19, 3, 5], backgroundColor: ["rgba(255, 99, 132, 0.5)", "rgba(54, 162, 235, 0.5)", "rgba(255, 206, 86, 0.5)", "rgba(75, 192, 192, 0.5)"] }] }, l = { labels: ["Jan", "Feb", "Mar", "Apr", "May", "Jun"], datasets: [{ label: "Classes per Month", data: [12, 19, 3, 5, 2, 3], backgroundColor: "rgba(255, 159, 64, 0.5)" }] }, c = { labels: ["Computer Science", "Mathematics", "Physics", "Biology"], datasets: [{ label: "Courses by Department", data: [15, 10, 8, 5], backgroundColor: ["rgba(255, 99, 132, 0.5)", "rgba(54, 162, 235, 0.5)", "rgba(255, 206, 86, 0.5)", "rgba(75, 192, 192, 0.5)"] }] }; s({ coordinatorData: a, classData: l, courseData: c }), t({ coordinators: a.datasets[0].data.reduce((d, f) => d + f, 0), classes: l.datasets[0].data.reduce((d, f) => d + f, 0), courses: c.datasets[0].data.reduce((d, f) => d + f, 0) }), i(!1) })() }, []), n ? u.jsx("p", { children: "Loading..." }) : u.jsxs("div", { className: "dashboard-container", children: [u.jsx("h2", { children: "Manager Dashboard" }), u.jsxs("div", { className: "overview", children: [u.jsxs("div", { className: "info-box", children: [u.jsx("h3", { children: "Directors" }), u.jsxs("p", { children: ["Total: ", e.coordinators] })] }), u.jsxs("div", { className: "info-box", children: [u.jsx("h3", { children: "Classes" }), u.jsxs("p", { children: ["Total: ", e.classes] })] }), u.jsxs("div", { className: "info-box", children: [u.jsx("h3", { children: "Courses" }), u.jsxs("p", { children: ["Total: ", e.courses] })] })] }), u.jsxs("div", { className: "charts", children: [u.jsxs("div", { className: "chart", children: [u.jsx("h3", { children: "Coordinators by Region" }), u.jsx(bg, { data: r.coordinatorData })] }), u.jsxs("div", { className: "chart", children: [u.jsx("h3", { children: "Classes per Month" }), u.jsx(PS, { data: r.classData })] }), u.jsxs("div", { className: "chart", children: [u.jsx("h3", { children: "Courses by Department" }), u.jsx(bg, { data: r.courseData })] })] })] }) }; function MS() { const [e, t] = S.useState([]), [n, i] = S.useState([]), r = a => { t([...e, ...a.target.files]) }, s = () => { e.length > 0 ? (i([...n, ...e]), t([]), console.log("Choose file:", e)) : console.log("Choose at least one file") }, o = a => { const l = [...n]; l.splice(a, 1), i(l), console.log("New files:", l) }; return u.jsx("div", { children: u.jsxs("div", { className: "class-documents", children: [u.jsx("h3", { children: " Class Document here " }), u.jsx(V, { className: "upload-document", type: "file", multiple: !0, onChange: r }), u.jsx(L, { onClick: s, children: "Upload File" }), n.length > 0 && u.jsxs("div", { children: [u.jsx("h4", { children: "Uploaded Files:" }), u.jsx("ul", { children: n.map((a, l) => u.jsxs("li", { className: "file-information", children: [a.name, u.jsxs("div", { className: "function-button", children: [u.jsx("a", { href: URL.createObjectURL(a), download: !0, children: "Download" }), u.jsx(L, { onClick: () => o(l), children: "Delete" })] })] }, l)) })] })] }) }) } const c2 = ({ student: e }) => { const [t, n] = S.useState(!1), i = () => { n(!t) }; return u.jsxs(u.Fragment, { children: [u.jsx(L, { color: "primary", onClick: i, children: "Detail" }), u.jsxs(wt, { isOpen: t, toggle: i, children: [u.jsx(at, { toggle: i, children: "Student Details" }), u.jsxs(lt, { children: [u.jsxs("p", { children: [u.jsx("strong", { children: "ID:" }), " ", e.id] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Name:" }), " ", e.name] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Email:" }), " ", e.email] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Academic Year:" }), " ", e.academicYear] })] }), u.jsx(ct, { children: u.jsx(L, { color: "secondary", onClick: i, children: "Close" }) })] })] }) }; c2.propTypes = { student: _.shape({ id: _.string.isRequired, name: _.string.isRequired, email: _.string.isRequired, academicYear: _.string.isRequired }) }; function DS() { const e = "http://localhost:3001/students", [t, n] = S.useState([]), [i, r] = S.useState([]), [s, o] = S.useState(!1), [a, l] = S.useState(null), [c, d] = S.useState(!1), [f, h] = S.useState(null), [p, g] = S.useState(""); S.useEffect(() => { v() }, []), S.useEffect(() => { j() }, [p, t]); const v = async () => { d(!0); try { const w = await fetch(e); if (!w.ok) throw new Error("Failed to fetch students"); const k = await w.json(); n(k) } catch (w) { h(w.message) } finally { d(!1) } }, x = () => { o(!s) }, y = async () => { try { if (!(await fetch(`${e}/${a}`, { method: "DELETE" })).ok) throw new Error("Failed to delete student"); n(k => k.filter(C => C.id !== a)), o(!1) } catch (w) { h(w.message) } }, m = w => { l(w), o(!0) }, b = w => { g(w.target.value) }, j = S.useCallback(() => { const w = t.filter(k => k.id.toString().includes(p) || k.name.toLowerCase().includes(p.toLowerCase())); r(w) }, [p, t]); return u.jsxs("div", { className: "class-members", children: [u.jsx("h3", { children: "Class Members here" }), u.jsxs("div", { className: "search", children: [u.jsx(V, { className: "custom-input", type: "text", placeholder: "Search by ID or Name", value: p, onChange: b }), u.jsx("box-icon", { name: "search" })] }), c ? u.jsx("p", { children: "Loading..." }) : f ? u.jsxs("p", { children: ["Error: ", f] }) : u.jsxs(tt, { bordered: !0, responsive: !0, striped: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "ID" }), u.jsx("th", { children: "Name" }), u.jsx("th", { children: "Email" }), u.jsx("th", { children: "Academic Year" }), u.jsx("th", { children: "Actions" })] }) }), u.jsx("tbody", { children: i.map(w => u.jsxs("tr", { children: [u.jsx("td", { children: w.id }), u.jsx("td", { children: w.name }), u.jsx("td", { children: w.email }), u.jsx("td", { children: w.academicYear }), u.jsxs("td", { children: [u.jsx(c2, { student: w }), u.jsx(L, { color: "danger", onClick: () => m(w.id), children: "Delete" })] })] }, w.id)) })] }), u.jsxs(wt, { isOpen: s, toggle: x, children: [u.jsx(at, { toggle: x, children: "Confirm Delete" }), u.jsx(lt, { children: "Are you sure you want to delete this student?" }), u.jsxs(ct, { children: [u.jsx(L, { color: "danger", onClick: y, children: "Delete" }), " ", u.jsx(L, { color: "secondary", onClick: x, children: "Cancel" })] })] })] }) } const u2 = ({ submission: e, onSaveGrade: t }) => { const [n, i] = S.useState(e.grade), [r, s] = S.useState(e.comment), [o, a] = S.useState(!1), l = () => { a(!o) }, c = async () => { try { if (n && r) { const d = { ...e, grade: n, comment: r, graded: "Graded" }; await t(e.id, n, r, d), l() } else alert("Please fill in both grade and comment before saving.") } catch (d) { console.error("Failed to save grade:", d) } }; return u.jsxs(u.Fragment, { children: [u.jsx(L, { color: "primary", onClick: l, disabled: e.graded === "Graded", children: "Grade" }), u.jsxs(wt, { isOpen: o, toggle: l, children: [u.jsx(at, { toggle: l, children: "Grade Submission" }), u.jsxs(lt, { children: [u.jsx(V, { type: "text", value: n, onChange: d => i(d.target.value), placeholder: "Enter grade...", disabled: e.graded === "Graded" }), u.jsx(V, { type: "textarea", value: r, onChange: d => s(d.target.value), placeholder: "Enter comment...", disabled: e.graded === "Graded" })] }), u.jsxs(ct, { children: [u.jsx(L, { color: "primary", onClick: c, disabled: e.graded === "Graded", children: "Save" }), " ", u.jsx(L, { color: "secondary", onClick: l, children: "Cancel" })] })] })] }) }; u2.propTypes = { submission: _.shape({ id: _.string.isRequired, grade: _.string.isRequired, comment: _.string.isRequired, graded: _.string.isRequired }).isRequired, onSaveGrade: _.func.isRequired }; const d2 = ({ submission: e, onSaveGrade: t }) => { const [n, i] = S.useState(!1), [r, s] = S.useState(e.grade), [o, a] = S.useState(e.comment), l = () => { i(!n) }, c = h => { s(h.target.value) }, d = h => { a(h.target.value) }, f = () => { try { if (r && o) { const h = { ...e, grade: r, comment: o, graded: "Graded" }; t(e.id, r, o, h), l() } else alert("Please fill in all fields") } catch { alert("Failed to save submission") } }; return u.jsxs(u.Fragment, { children: [u.jsx(L, { color: "primary", onClick: l, disabled: e.graded !== "Graded", children: "Edit" }), u.jsxs(wt, { isOpen: n, toggle: l, children: [u.jsx(at, { toggle: l, children: "Edit Grade" }), u.jsxs(lt, { children: [u.jsx(V, { type: "text", value: r, onChange: c }), u.jsx(V, { required: !0, type: "textarea", value: o, onChange: d, placeholder: "Enter comment..." })] }), u.jsxs(ct, { children: [u.jsx(L, { color: "primary", onClick: f, children: "Save" }), " ", u.jsx(L, { color: "secondary", onClick: l, children: "Cancel" })] })] })] }) }; d2.propTypes = { submission: _.object.isRequired, onSaveGrade: _.func.isRequired }; const hf = ({ submission: e }) => { const [t, n] = S.useState(!1), i = () => { n(!t) }; function r(s) { switch (s) { case "text/plain": case "application/vnd.openxmlformats-officedocument.wordprocessingml.document": return u.jsx("img", { width: "64", height: "64", src: "https://img.icons8.com/external-creatype-filed-outline-colourcreatype/64/000000/external-docx-text-file-extension-creatype-filed-outline-colourcreatype.png", alt: "docx" }); case "application/pdf": return u.jsx("img", { width: "48", height: "48", src: "https://img.icons8.com/color/48/pdf.png", alt: "pdf" }); case "image/jpeg": case "image/png": return u.jsx("img", { width: "48", height: "48", src: "https://img.icons8.com/color/48/image-file.png", alt: "image" }); default: return u.jsx("img", { width: "50", height: "50", src: "https://img.icons8.com/ios/50/file--v1.png", alt: "file" }) } } return u.jsxs(u.Fragment, { children: [u.jsx(L, { color: "info", onClick: i, children: "Detail" }), u.jsxs(wt, { isOpen: t, toggle: i, children: [u.jsx(at, { toggle: i, children: "Submission Detail" }), u.jsxs(lt, { children: [u.jsxs("p", { children: [u.jsx("strong", { children: "Author ID:" }), " ", e.studentID] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Author name:" }), " ", e.studentName] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Submission Title:" }), " ", e.submissionTitle] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Date:" }), " ", e.date] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Comment:" }), " ", e.comment] }), e.files && e.files.length > 0 ? u.jsxs(u.Fragment, { children: [u.jsx("h4", { children: "Files:" }), u.jsx("ul", { children: e.files.map((s, o) => u.jsxs("li", { children: [u.jsx("a", { href: s.fileUrl, target: "_blank", rel: "noopener noreferrer", children: s.fileName }), r(s.fileType)] }, o)) })] }) : u.jsx("p", { children: "No files uploaded" })] }), u.jsx(ct, { children: u.jsx(L, { color: "secondary", onClick: i, children: "Close" }) })] })] }) }; hf.propTypes = { submission: _.shape({ studentID: _.string.isRequired, studentName: _.string.isRequired, submissionTitle: _.string.isRequired, date: _.string.isRequired, comment: _.string.isRequired, files: _.arrayOf(_.shape({ fileName: _.string.isRequired })) }) }; function TS() { const [e, t] = S.useState([]), [n, i] = S.useState([]), [r, s] = S.useState(""), [o, a] = S.useState(!1), l = "http://localhost:3001/submissions"; S.useEffect(() => { d() }, []), S.useEffect(() => { f() }, [r, e]); const c = () => { a(!o) }, d = async () => { try { const p = await fetch(l); if (!p.ok) throw new Error("Failed to fetch data"); const g = await p.json(); t(g) } catch (p) { console.error(p) } }, f = () => { const p = e.filter(g => r === "" || g.graded === r); i(p) }, h = async (p, g, v, x) => { try { if (!(await fetch(`${l}/${p}`, { method: "PUT", headers: { "Content-Type": "application/json" }, body: JSON.stringify(x) })).ok) throw new Error("Failed to update grade"); const m = e.map(b => b.id === p ? x : b); t(m), c() } catch (y) { console.error(y) } }; return u.jsxs("div", { children: [u.jsx("h2", { children: "Submission List" }), u.jsx("div", { className: "search-submissions", children: u.jsxs(V, { type: "select", value: r, onChange: p => s(p.target.value), children: [u.jsx("option", { value: "", children: "All" }), u.jsx("option", { value: "Graded", children: "Graded" }), u.jsx("option", { value: "Ungraded", children: "Ungraded" })] }) }), u.jsxs(tt, { striped: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Submission Date" }), u.jsx("th", { children: "Title" }), u.jsx("th", { children: "Student ID" }), u.jsx("th", { children: "Grade" }), u.jsx("th", { className: "action-column", children: "Actions" })] }) }), u.jsx("tbody", { children: n.map(p => u.jsxs("tr", { children: [u.jsx("td", { children: p.date }), u.jsx("td", { children: p.submissionTitle }), u.jsx("td", { children: p.studentID }), u.jsx("td", { children: p.grade }), u.jsxs("td", { className: "action-column", children: [u.jsx(u2, { submission: p, onSaveGrade: h }), u.jsx(d2, { submission: p, onSaveGrade: h }), u.jsx(hf, { submission: p })] })] }, p.id)) })] })] }) } function NS() { const [e, t] = S.useState(), n = r => { const s = r.target.value; t(s) }, i = async () => { try { if (!(await fetch("API_URL", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ dueDate: e }) })).ok) throw new Error("Failed to set due date"); console.log("Due date set successfully:", e) } catch (r) { console.error(r) } }; return u.jsxs("div", { children: [u.jsx("h2", { children: "Set Due Date for Assignment" }), u.jsxs("div", { className: "set-due-date", children: [u.jsx(V, { type: "date", value: e, onChange: n }), u.jsx(L, { onClick: i, children: "Set Due Date" })] })] }) } const RS = () => u.jsxs("div", { children: [u.jsx("div", { className: "class-information", children: u.jsx("h2", { children: " Class name and ID here" }) }), u.jsx(NS, {}), u.jsx(MS, {}), u.jsx(DS, {}), u.jsx(TS, {})] }); function zS() { return u.jsx("div", { children: "Navbar" }) } function LS() { return u.jsxs("div", { className: "landing-page-container", children: [u.jsx("div", { className: "navbar", children: u.jsx(zS, {}) }), u.jsx("div", { className: "content", children: u.jsx(pr, {}) })] }) } function AS() { return u.jsx("div", { children: "AdminDashBoard" }) } function IS() { return u.jsx("div", { children: "Navbar" }) } function FS() { return u.jsxs("div", { className: "landing-page-container", children: [u.jsx("div", { className: "navbar", children: u.jsx(IS, {}) }), u.jsx("div", { className: "content", children: u.jsx(pr, {}) })] }) } function $S() { return u.jsx("div", { children: "GuestDashBoard" }) } const BS = e => u.jsx(u.Fragment, {
    children: u.jsx("svg", {
        version: "1.0", xmlns: "http://www.w3.org/2000/svg", width: "50px", height: "50px", viewBox: "0 0 658.000000 658.000000", preserveAspectRatio: "xMidYMid meet", ...e, children: u.jsxs("g", {
            transform: "translate(0.000000,658.000000) scale(0.100000,-0.100000)", fill: "#000000", stroke: "none", children: [u.jsx("path", {
                d: `M3222 6418 c-28 -68 -90 -215 -138 -328 -47 -113 -111 -263 -140\r
    -334 l-54 -128 19 -27 c11 -14 51 -66 90 -116 l71 -90 -24 -20 c-13 -11 -26\r
    -29 -28 -40 -3 -20 -3 -20 -158 -45 -714 -114 -1369 -549 -1766 -1172 -205\r
    -321 -336 -684 -390 -1078 -24 -172 -24 -512 0 -674 71 -486 231 -879 507\r
    -1247 632 -839 1695 -1215 2710 -959 415 105 817 325 1133 621 739 691 1012\r
    1747 706 2726 -91 291 -264 613 -463 858 -407 502 -1000 840 -1639 932 -110\r
    16 -121 20 -129 41 -5 13 -19 32 -30 41 -21 16 -20 18 71 131 71 90 90 120 87\r
    140 -3 14 -59 153 -126 310 -67 157 -147 346 -178 420 -30 74 -60 141 -67 148\r
    -10 10 -23 -13 -64 -110z m83 40 c3 -13 48 -195 100 -406 52 -210 95 -392 95\r
    -405 0 -23 -182 -239 -206 -245 -12 -3 -14 87 -14 537 0 347 4 541 10 541 5 0\r
    12 -10 15 -22z m-80 -145 c-12 -49 -55 -220 -94 -381 l-72 -293 101 -114 c55\r
    -63 100 -118 100 -123 0 -5 -33 -12 -72 -14 -56 -4 -77 -1 -91 10 -9 9 -55 64\r
    -102 124 -71 92 -83 112 -76 131 5 12 73 175 151 362 78 187 146 350 151 363\r
    5 12 13 22 18 22 5 0 -1 -39 -14 -87z m270 -959 c9 -9 15 -23 13 -32 -3 -13\r
    -36 -15 -235 -16 l-233 -2 0 23 c0 12 8 27 18 32 10 6 100 11 219 11 173 0\r
    204 -2 218 -16z m-126 -203 c30 -11 60 -17 68 -14 10 4 13 -9 13 -56 0 -67\r
    -11 -78 -30 -31 -31 75 -113 109 -183 75 -99 -47 -96 -256 4 -308 39 -20 93\r
    -15 122 11 28 25 19 83 -15 100 -16 7 -28 17 -28 23 0 11 157 12 164 1 3 -5\r
    -4 -16 -15 -25 -13 -12 -19 -30 -19 -61 0 -43 -1 -44 -51 -65 -143 -62 -267\r
    -19 -300 102 -15 55 -5 120 26 174 26 43 45 58 100 80 43 17 82 15 144 -6z\r
    m511 -60 c84 -24 110 -36 133 -61 48 -54 33 -115 -38 -156 -19 -11 -19 -12 -1\r
    -87 12 -53 24 -82 39 -92 30 -21 9 -39 -36 -31 -41 8 -61 41 -78 129 -10 55\r
    -36 97 -59 97 -11 0 -40 -92 -40 -126 0 -13 8 -27 17 -33 35 -19 5 -21 -66 -4\r
    -73 17 -87 31 -49 48 18 8 29 33 54 121 48 169 49 170 25 191 -21 18 -27 33\r
    -13 33 4 0 54 -13 112 -29z m-1335 -51 c0 -21 -5 -25 -29 -25 -38 -1 -41 -14\r
    -21 -75 17 -50 17 -50 51 -44 45 8 47 -18 4 -36 -21 -9 -29 -18 -26 -29 3 -9\r
    17 -65 32 -125 32 -135 23 -186 -33 -186 -27 0 -42 25 -24 43 16 16 13 60 -13\r
    162 -22 87 -24 90 -51 90 -37 0 -44 22 -11 34 23 9 24 13 19 64 -7 64 10 121\r
    40 142 32 23 62 15 62 -15z m1922 -180 c141 -77 137 -73 112 -115 -25 -42 -43\r
    -46 -34 -7 4 21 0 33 -17 49 -25 23 -61 43 -76 43 -12 0 -62 -83 -62 -103 0\r
    -24 56 -42 87 -28 14 6 28 10 30 7 8 -8 -58 -127 -67 -121 -6 4 -7 17 -4 29 4\r
    18 -1 29 -22 45 -41 32 -56 26 -89 -34 -35 -65 -30 -81 31 -102 37 -13 52 -13\r
    102 2 28 9 29 -8 1 -34 -38 -36 -62 -32 -171 28 -105 59 -128 81 -84 81 21 0\r
    34 17 95 125 39 68 71 131 71 138 0 8 -7 20 -15 27 -17 14 -20 30 -6 30 6 0\r
    58 -27 118 -60z m-2073 -75 c73 -67 57 -195 -29 -231 -19 -8 -46 -12 -59 -8\r
    -35 8 -76 56 -86 98 -26 115 96 214 174 141z m716 -175 c0 -32 -6 -35 -87 -45\r
    -49 -6 -53 -5 -54 14 -1 12 -2 27 -3 34 -1 12 120 38 137 30 4 -2 7 -17 7 -33z\r
    m160 10 c0 -35 -21 -43 -91 -38 -33 2 -45 8 -47 21 -8 39 5 47 73 47 l65 0 0\r
    -30z m163 22 c3 -4 3 -20 0 -35 -6 -28 -7 -29 -62 -26 -65 4 -81 12 -81 45 0\r
    23 3 24 69 24 39 0 72 -3 74 -8z m169 -20 c6 -6 8 -22 4 -36 -6 -24 -10 -26\r
    -49 -21 -111 15 -107 13 -107 47 l0 31 71 -5 c39 -3 75 -10 81 -16z m-657 -36\r
    c0 -27 -4 -31 -50 -43 -72 -18 -92 -17 -99 9 -7 30 3 38 66 54 72 17 83 15 83\r
    -20z m760 20 c55 -11 60 -15 57 -36 -4 -38 -14 -41 -78 -27 -59 14 -73 28 -60\r
    63 6 17 5 17 81 0z m1233 -78 c42 -40 86 -83 99 -95 l24 -23 -23 -30 c-31 -42\r
    -47 -39 -41 8 5 34 1 41 -31 70 -20 18 -40 32 -45 32 -5 0 -25 -21 -46 -46\r
    l-37 -45 23 -25 c19 -21 30 -24 56 -19 45 8 43 -9 -8 -62 -41 -45 -66 -56 -54\r
    -25 4 9 9 22 12 29 2 6 -9 26 -26 45 l-31 33 -50 -53 c-41 -44 -48 -57 -40\r
    -72 16 -31 74 -60 119 -60 61 0 50 -30 -16 -45 -28 -6 -38 -1 -80 37 -150 135\r
    -162 151 -110 141 20 -4 41 14 126 104 61 64 100 114 98 123 -3 8 -8 23 -12\r
    33 -15 36 19 15 93 -55z m-3232 30 c-3 -13 6 -66 20 -118 23 -83 32 -101 72\r
    -142 47 -48 69 -57 89 -37 6 6 17 9 23 7 11 -3 -109 -129 -131 -136 -12 -5\r
    -12 15 1 23 20 13 9 42 -32 82 -34 33 -62 48 -138 73 -66 21 -105 29 -127 25\r
    -18 -3 -33 -2 -33 2 0 9 105 103 115 103 4 0 5 -6 2 -14 -3 -8 0 -19 6 -24 14\r
    -10 139 -53 143 -49 6 6 -37 136 -46 142 -5 3 -19 1 -31 -5 -38 -21 -33 0 11\r
    45 49 50 65 56 56 23z m1075 -12 c8 -30 0 -35 -87 -57 -51 -13 -50 -13 -59 23\r
    -7 26 -4 28 57 47 34 11 67 19 72 17 6 -1 13 -15 17 -30z m1094 15 c51 -18 65\r
    -40 46 -70 -7 -11 -20 -10 -75 9 -55 18 -66 25 -66 44 0 42 16 44 95 17z\r
    m-615 -13 c0 -28 -71 -522 -75 -527 -2 -1 -8 0 -14 4 -14 8 -349 449 -357 468\r
    -6 16 70 38 196 56 41 6 86 13 100 15 14 2 53 4 88 5 58 1 62 0 62 -21z m275\r
    7 c136 -19 210 -38 210 -53 0 -6 -81 -117 -180 -247 -141 -185 -181 -232 -187\r
    -218 -5 14 -78 503 -78 527 0 11 125 6 235 -9z m-915 -51 c14 -35 4 -45 -65\r
    -69 -48 -16 -58 -17 -66 -4 -19 30 -9 46 49 72 72 32 71 32 82 1z m1408 0 c64\r
    -28 71 -38 48 -69 -13 -18 -15 -18 -70 5 -31 12 -59 27 -62 32 -7 11 4 58 14\r
    58 4 0 35 -12 70 -26z m-1233 -36 c-3 -18 -23 -154 -45 -302 -21 -147 -41\r
    -270 -43 -273 -9 -8 -349 408 -344 421 13 32 351 181 420 185 15 1 17 -5 12\r
    -31z m1112 -7 c123 -43 296 -127 291 -141 -2 -5 -79 -104 -173 -221 -164 -206\r
    -169 -211 -177 -183 -8 32 -78 535 -78 565 0 26 14 24 137 -20z m-603 -43 c7\r
    -51 34 -239 112 -756 20 -134 34 -245 32 -247 -2 -3 -40 -1 -84 3 l-79 7 -3\r
    528 c-2 487 4 608 22 465z m-834 16 c6 -14 10 -27 10 -29 0 -2 -29 -19 -65\r
    -38 l-66 -35 -16 24 c-9 15 -12 29 -7 34 12 12 117 70 127 70 4 0 12 -12 17\r
    -26z m1707 0 c66 -37 68 -39 49 -69 l-17 -25 -52 26 c-75 38 -78 41 -65 70 14\r
    30 26 30 85 -2z m-388 -264 c17 -129 34 -253 37 -275 5 -39 2 -44 -162 -248\r
    -92 -114 -169 -206 -171 -203 -2 2 28 127 67 277 39 151 93 362 121 469 62\r
    243 59 234 69 224 4 -5 22 -115 39 -244z m-882 160 c32 -41 107 -137 167 -213\r
    l108 -139 -37 -246 c-39 -268 -49 -316 -58 -292 -4 8 -60 222 -127 475 -66\r
    253 -123 468 -126 479 -11 33 12 13 73 -64z m1413 18 c53 -35 57 -43 35 -72\r
    -14 -18 -16 -17 -67 15 -29 18 -55 34 -57 36 -8 5 18 53 29 53 6 0 33 -15 60\r
    -32z m-2000 3 c15 -28 15 -28 -47 -68 l-57 -36 -18 23 c-10 12 -18 25 -18 29\r
    1 9 102 70 117 71 7 0 17 -9 23 -19z m60 -123 c104 -262 169 -432 165 -436 -8\r
    -8 -555 223 -555 234 0 14 86 95 170 159 66 51 172 124 181 124 3 1 21 -36 39\r
    -81z m1925 32 c147 -98 277 -213 259 -229 -5 -4 -81 -38 -169 -76 -88 -37\r
    -207 -87 -264 -111 -57 -24 -107 -44 -112 -44 -9 0 0 26 112 317 45 116 79\r
    193 87 193 8 0 47 -22 87 -50z m154 -10 c28 -22 51 -44 51 -49 0 -4 -9 -16\r
    -20 -26 -20 -18 -28 -14 -122 65 -9 7 19 50 32 50 4 0 31 -18 59 -40z m-2275\r
    6 c15 -24 15 -25 -33 -60 -56 -42 -62 -43 -85 -17 -17 19 -16 21 34 60 29 23\r
    55 41 60 41 4 0 15 -11 24 -24z m2401 -110 c50 -44 50 -44 31 -65 -11 -12 -24\r
    -21 -30 -21 -7 0 -32 20 -56 45 -43 44 -43 45 -25 65 10 11 21 20 24 20 3 0\r
    29 -20 56 -44z m-2526 13 c12 -20 9 -26 -38 -72 -49 -50 -50 -51 -71 -32 -11\r
    10 -20 22 -20 26 0 11 93 98 105 99 6 0 16 -10 24 -21z m578 -226 c278 -343\r
    296 -365 367 -452 l68 -84 -73 -34 c-58 -27 -75 -31 -85 -21 -6 7 -89 148\r
    -184 313 -94 165 -196 341 -226 392 -94 159 -77 144 133 -114z m1312 -234\r
    c-94 -244 -174 -448 -179 -452 -9 -10 -120 71 -120 88 0 7 97 183 216 391 242\r
    424 244 427 250 421 2 -2 -73 -204 -167 -448z m1364 408 l26 -43 -50 -164\r
    c-27 -89 -48 -167 -47 -171 2 -4 41 16 88 45 79 50 85 56 85 87 0 39 15 50 30\r
    23 5 -11 20 -33 32 -51 13 -17 23 -36 23 -42 0 -14 -17 -14 -25 -1 -13 21 -44\r
    8 -183 -76 -79 -47 -146 -83 -149 -80 -6 6 19 101 71 274 19 61 29 112 24 112\r
    -12 0 -153 -85 -181 -109 -14 -12 -17 -24 -13 -49 7 -45 -11 -38 -46 19 -50\r
    79 -50 85 -1 67 29 -11 37 -8 130 47 122 72 143 91 143 127 0 40 14 35 43 -15z\r
    m-3993 -46 l25 -16 -38 -3 c-32 -3 -42 -10 -63 -44 -14 -22 -22 -44 -17 -48\r
    21 -20 240 -140 254 -140 9 0 22 7 29 15 13 16 40 21 40 8 0 -5 -9 -21 -21\r
    -38 -11 -16 -31 -51 -45 -77 -29 -57 -44 -61 -44 -13 0 33 -3 36 -119 105 -66\r
    38 -126 70 -134 70 -8 0 -22 -16 -33 -35 -18 -34 -18 -36 0 -70 11 -19 17 -38\r
    13 -41 -3 -3 -24 9 -46 27 l-41 32 28 47 c15 25 54 92 87 148 64 110 67 112\r
    125 73z m3384 -37 l49 -56 -22 -21 -21 -21 -50 49 c-27 27 -50 54 -50 59 0 11\r
    30 46 40 46 3 0 28 -25 54 -56z m-2761 15 c8 -13 1 -27 -34 -68 -24 -28 -49\r
    -51 -55 -51 -6 0 -19 9 -29 20 -17 19 -17 21 26 69 45 51 73 60 92 30z m2706\r
    -75 c93 -101 231 -297 218 -310 -6 -6 -467 -191 -487 -196 -9 -2 -14 3 -12 12\r
    5 29 217 550 223 550 4 0 30 -25 58 -56z m-2656 9 c9 -21 47 -114 85 -208 39\r
    -93 84 -203 101 -244 16 -41 28 -78 26 -82 -3 -4 -73 20 -157 53 -84 33 -188\r
    73 -231 89 -43 16 -87 34 -99 40 -50 27 0 -19 180 -165 105 -87 192 -161 192\r
    -166 0 -10 -2 -11 -297 -60 -278 -46 -283 -46 -283 -22 0 60 138 374 222 507\r
    66 104 220 295 239 295 4 0 14 -17 22 -37z m284 -97 c304 -122 284 -111 312\r
    -181 108 -269 180 -459 178 -462 -5 -4 -721 715 -726 729 -2 6 2 9 10 6 8 -3\r
    109 -44 226 -92z m2260 82 c-77 -191 -197 -498 -197 -505 0 -12 -12 -18 -279\r
    -124 -226 -90 -245 -96 -239 -80 6 16 700 721 710 721 6 0 8 -6 5 -12z m273\r
    -61 c22 -30 40 -56 40 -59 0 -3 -11 -13 -24 -21 -24 -16 -25 -15 -66 39 -40\r
    53 -41 56 -24 75 9 10 21 19 25 19 5 0 26 -24 49 -53z m-2986 24 c21 -23 21\r
    -23 -24 -83 -39 -52 -49 -56 -73 -30 -16 18 -15 22 24 75 22 31 44 57 48 57 4\r
    0 16 -9 25 -19z m3075 -149 c36 -57 38 -73 11 -90 -18 -11 -23 -7 -55 35 -19\r
    27 -35 53 -35 60 0 9 36 43 46 43 1 0 16 -22 33 -48z m-3178 18 c10 -6 19 -16\r
    19 -22 0 -14 -62 -118 -70 -118 -3 0 -16 9 -28 19 l-24 18 36 56 c40 62 39 62\r
    67 47z m3267 -173 l32 -62 -21 -17 c-12 -10 -24 -18 -28 -18 -3 0 -21 30 -40\r
    66 -33 64 -34 67 -16 80 30 22 38 17 73 -49z m-3344 28 c19 -14 19 -16 -9 -67\r
    -36 -68 -39 -71 -64 -63 -28 8 -27 23 6 90 29 58 37 63 67 40z m3278 -81 c66\r
    -123 146 -341 130 -355 -8 -8 -587 72 -597 82 -8 9 406 350 419 346 6 -2 28\r
    -34 48 -73z m687 -22 c5 -26 13 -55 17 -66 6 -16 3 -17 -22 -12 -24 5 -46 -5\r
    -131 -61 -57 -36 -101 -68 -99 -70 2 -2 35 -10 75 -17 l71 -14 46 31 c25 16\r
    50 41 55 55 13 33 23 21 43 -52 18 -62 16 -77 -9 -56 -12 10 -33 0 -122 -56\r
    l-107 -69 54 -8 c30 -4 87 -6 125 -5 69 3 70 4 73 31 5 43 23 27 39 -32 14\r
    -57 12 -71 -10 -53 -10 9 -315 42 -383 42 -22 0 -17 28 9 42 63 35 146 103\r
    135 109 -7 4 -44 12 -83 18 -112 18 -125 22 -125 34 1 7 70 59 155 117 84 57\r
    156 112 158 122 9 33 25 19 36 -30z m-3647 -36 c92 -38 643 -256 725 -288 29\r
    -10 55 -23 58 -28 7 -11 -71 -120 -85 -120 -6 0 -70 35 -143 79 -72 43 -247\r
    145 -387 226 -140 81 -259 151 -264 156 -19 17 12 9 96 -25z m2708 2 c-14 -11\r
    -110 -93 -214 -182 -229 -194 -477 -396 -489 -396 -7 0 -31 49 -58 118 -10 26\r
    -48 2 436 289 307 182 397 229 325 171z m386 -33 c30 -69 30 -91 2 -99 -28 -7\r
    -41 9 -64 77 -16 48 -16 51 2 64 28 20 33 17 60 -42z m-3484 21 c17 -12 16\r
    -16 -6 -72 -25 -62 -51 -79 -75 -50 -10 12 -8 26 15 75 28 63 37 70 66 47z\r
    m1703 -116 c0 -23 -5 -26 -50 -31 l-50 -6 48 -1 47 -2 0 -172 c0 -132 -3 -169\r
    -12 -160 -8 8 -15 8 -24 1 -7 -5 -14 -6 -17 -2 -6 10 -87 294 -87 306 0 4 10\r
    12 23 17 20 8 19 9 -10 9 -28 1 -33 5 -33 25 0 22 6 26 53 34 28 6 66 9 82 9\r
    25 -2 30 -6 30 -27z m-2322 -2 c5 -20 25 -28 149 -61 79 -20 146 -37 150 -37\r
    4 0 16 10 28 22 28 30 32 20 16 -38 -8 -27 -17 -62 -21 -78 l-6 -30 -22 27\r
    c-18 23 -46 34 -161 64 l-139 36 -18 -21 c-17 -22 -39 -29 -39 -14 0 5 6 28\r
    14 53 8 24 17 56 20 72 8 33 22 35 29 5z m2602 -27 c63 -29 74 -42 56 -70 -7\r
    -11 -12 -11 -32 2 -13 8 -44 21 -68 28 -44 13 -57 28 -47 54 8 21 17 19 91\r
    -14z m1562 -47 l22 -65 -25 -10 c-39 -14 -40 -13 -59 53 -16 59 -16 62 1 75\r
    31 22 39 15 61 -53z m-3590 22 c-2 -6 -12 -37 -21 -68 -17 -59 -32 -70 -65\r
    -49 -12 8 -12 19 4 73 9 34 19 66 21 70 7 11 66 -13 61 -26z m1866 8 c26 -5\r
    37 -12 37 -24 0 -23 -67 -300 -74 -307 -3 -3 -12 -1 -19 6 -8 6 -22 9 -31 5\r
    -14 -6 -16 11 -16 160 l0 166 33 0 c17 0 49 -3 70 -6z m-279 -41 c18 -60 86\r
    -303 86 -308 0 -3 -9 -3 -20 0 -14 5 -20 2 -20 -9 0 -36 -22 -9 -93 112 -112\r
    191 -107 168 -45 197 63 29 85 31 92 8z m420 -3 c25 -12 46 -25 46 -31 0 -12\r
    -39 -90 -102 -202 -38 -68 -53 -86 -63 -77 -7 6 -20 8 -29 4 -9 -3 -16 -1 -16\r
    4 0 9 38 161 71 285 12 44 26 46 93 17z m-588 -16 c4 -15 47 -94 95 -176 49\r
    -82 89 -151 89 -154 0 -3 -9 -2 -20 1 -16 5 -20 2 -20 -14 0 -12 -4 -21 -8\r
    -21 -5 0 -62 58 -128 129 -65 71 -127 131 -136 134 -31 9 -20 34 34 81 60 53\r
    85 58 94 20z m-750 -62 c189 -152 359 -296 363 -304 2 -6 -5 -8 -15 -4 -11 3\r
    -80 22 -154 41 -339 91 -594 159 -694 185 -59 16 -111 31 -114 34 -8 9 10 12\r
    268 56 135 23 247 44 249 46 11 11 32 -1 97 -54z m1468 3 c25 -20 46 -42 46\r
    -48 0 -7 -52 -67 -114 -132 -92 -96 -115 -115 -115 -97 -1 13 -7 22 -17 22 -9\r
    0 -14 4 -12 8 16 39 152 282 158 282 4 0 28 -16 54 -35z m1496 -62 c6 -32 12\r
    -64 13 -72 2 -14 -50 -35 -57 -23 -2 4 -10 36 -17 70 -10 54 -10 65 2 73 34\r
    21 47 10 59 -48z m-1297 -63 c17 -28 17 -29 -1 -39 -17 -9 -26 -2 -66 49 -50\r
    65 -52 70 -33 89 10 10 19 4 47 -29 20 -22 44 -54 53 -70z m-2395 91 c11 -7\r
    11 -19 2 -68 -16 -80 -20 -86 -53 -74 -15 6 -27 15 -27 21 0 11 18 91 26 118\r
    4 14 33 16 52 3z m3611 -38 c19 -85 39 -216 46 -310 l7 -93 -24 0 c-33 0 -522\r
    71 -527 76 -3 2 2 11 10 19 34 33 455 354 466 354 6 1 16 -20 22 -46z m-3323\r
    -155 c129 -100 231 -184 227 -188 -12 -11 -532 -85 -540 -77 -10 11 15 281 33\r
    357 21 87 22 90 34 90 6 0 116 -82 246 -182z m3210 173 c-6 -10 -80 -70 -285\r
    -230 l-144 -113 -226 33 c-356 50 -320 43 -291 57 14 6 126 39 250 73 124 34\r
    326 89 450 124 237 66 254 70 246 56z m-1182 -58 c20 -25 36 -51 36 -57 -1\r
    -12 -270 -176 -289 -176 -6 0 -8 7 -5 15 4 8 1 15 -6 15 -6 0 -10 7 -8 15 3\r
    15 216 235 228 235 4 0 24 -21 44 -47z m-839 -82 c63 -63 115 -116 115 -118 0\r
    -1 -7 -3 -16 -3 -11 0 -14 -6 -9 -20 9 -29 -4 -25 -86 24 -41 24 -107 62 -147\r
    85 -50 29 -70 46 -65 55 30 49 70 96 80 93 7 -1 64 -53 128 -116z m-238 9 c3\r
    -11 10 -20 17 -20 10 0 283 -154 296 -167 3 -2 -3 -9 -12 -14 -10 -5 -15 -16\r
    -12 -24 8 -20 7 -20 -126 16 -63 16 -132 35 -154 40 -37 10 -38 11 -33 47 l5\r
    37 -16 -32 c-15 -32 -44 -44 -57 -24 -8 13 61 161 75 161 7 0 14 -9 17 -20z\r
    m2476 3 c3 -5 8 -38 12 -75 l7 -68 -30 0 c-21 0 -32 6 -35 18 -11 37 -18 112\r
    -12 122 7 12 52 14 58 3z m-3741 -68 c-5 -76 -10 -85 -43 -85 -32 0 -34 8 -23\r
    94 7 45 8 47 38 44 31 -3 31 -4 28 -53z m2413 5 c29 -58 32 -87 8 -94 -10 -3\r
    -74 -21 -143 -40 -69 -19 -133 -38 -143 -42 -15 -6 -17 -3 -11 20 5 20 2 26\r
    -10 26 -9 0 -16 3 -16 8 1 5 273 168 287 171 2 1 14 -21 28 -49z m109 -117\r
    c22 -119 17 -153 -22 -138 -9 4 -95 6 -190 5 -170 -1 -173 0 -167 20 4 11 2\r
    20 -4 20 -6 0 -11 4 -11 8 0 9 38 21 220 72 77 21 107 25 112 17 5 -8 8 -6 8\r
    6 0 11 8 17 24 17 19 0 26 -7 30 -27z m-2534 -53 c0 -73 -6 -90 -34 -90 -19\r
    -1 -18 -2 7 -16 27 -15 28 -17 25 -87 l-3 -72 -30 0 -30 0 -2 159 c-2 104 1\r
    162 8 166 6 4 21 5 35 2 22 -4 24 -9 24 -62z m3774 54 c3 -9 6 -40 6 -70 0\r
    -53 -1 -54 -29 -54 -33 0 -41 17 -41 93 0 45 1 47 29 47 17 0 31 -6 35 -16z\r
    m-4048 -10 c58 -28 77 -91 54 -176 -9 -31 -17 -39 -48 -48 -81 -22 -110 -6\r
    -42 25 22 10 46 28 55 41 33 51 5 124 -49 124 -29 0 -37 -9 -81 -98 -43 -88\r
    -77 -111 -136 -93 -58 18 -82 54 -75 116 3 27 7 61 8 75 3 33 14 40 65 40 54\r
    0 63 -16 19 -34 -44 -18 -68 -55 -64 -98 2 -23 10 -36 28 -45 32 -16 51 1 85\r
    76 14 30 34 64 43 74 35 39 85 46 138 21z m1421 -55 c-3 -39 -8 -73 -10 -75\r
    -8 -9 -987 -16 -987 -8 0 5 105 25 233 43 127 19 347 51 487 71 140 21 261 38\r
    269 39 11 1 13 -13 8 -70z m259 27 c179 -47 173 -45 151 -57 -14 -8 -16 -14\r
    -6 -25 6 -8 9 -14 5 -14 -3 0 -79 -1 -168 -1 l-163 0 0 53 c1 63 10 92 28 85\r
    8 -3 76 -21 153 -41z m2913 -114 c-1 -89 -6 -103 -28 -74 -15 20 -27 21 -163\r
    23 -150 2 -178 -4 -178 -37 0 -8 -4 -14 -10 -14 -6 0 -10 33 -10 80 0 80 6 93\r
    30 65 10 -12 42 -15 167 -15 l154 0 10 30 c17 48 28 25 28 -58z m-752 2 c-2\r
    -2 -64 -13 -138 -23 -74 -11 -293 -45 -488 -76 -194 -30 -362 -55 -372 -55\r
    -17 0 -19 6 -13 58 3 31 7 67 10 79 l4 23 483 2 c446 3 524 2 514 -8z m-2355\r
    -74 c8 -87 6 -100 -21 -100 -23 0 -27 12 -36 97 -8 70 -2 85 28 81 20 -3 23\r
    -11 29 -78z m2566 3 l-3 -78 -30 0 -30 0 0 60 c0 77 8 95 40 95 26 0 26 0 23\r
    -77z m-2218 58 c0 -6 -5 -13 -11 -17 -8 -4 -7 -9 2 -15 11 -7 11 -11 1 -17\r
    -17 -11 -313 -95 -318 -90 -2 2 -7 37 -10 76 l-7 72 172 0 c100 0 171 -4 171\r
    -9z m929 -23 c-1 -63 -14 -113 -29 -112 -15 2 -282 71 -310 80 -13 5 -12 8 3\r
    19 12 8 14 15 8 20 -32 19 3 25 159 25 l170 0 -1 -32z m1211 -5 c-1 -123 -46\r
    -413 -64 -413 -6 0 -104 71 -217 158 -263 201 -263 201 -257 208 5 5 478 80\r
    521 83 13 1 17 -7 17 -36z m-3480 -3 c300 -41 330 -47 330 -59 0 -7 -102 -88\r
    -382 -305 -69 -53 -92 -66 -98 -56 -23 37 -70 399 -57 434 4 11 15 14 34 11\r
    15 -3 93 -14 173 -25z m1350 -48 c0 -4 -5 -13 -12 -20 -9 -9 -8 -12 5 -12 9 0\r
    17 -4 17 -9 0 -15 -269 -173 -284 -168 -17 7 -58 94 -54 115 2 11 47 28 148\r
    58 150 44 180 50 180 36z m734 -32 c81 -21 150 -41 152 -43 7 -7 -40 -129 -52\r
    -134 -6 -2 -74 33 -152 77 -128 74 -159 100 -116 100 12 0 12 4 4 20 -15 27\r
    -11 27 164 -20z m-1439 -16 c248 -37 271 -41 263 -49 -12 -13 -967 -269 -974\r
    -262 -8 8 431 346 451 347 11 0 128 -16 260 -36z m737 -39 c-3 -20 -1 -24 12\r
    -19 37 14 10 -25 -91 -131 -60 -62 -113 -113 -119 -114 -6 0 -16 -12 -22 -26\r
    -20 -44 -47 -28 -106 60 -33 50 -33 63 1 71 24 6 89 44 248 145 72 45 84 47\r
    77 14z m661 -69 c75 -43 137 -80 137 -82 0 -9 -82 -114 -89 -114 -9 0 -241\r
    234 -241 243 0 4 7 7 16 7 10 0 14 6 11 14 -7 18 3 28 17 18 6 -5 73 -44 149\r
    -86z m266 68 c2 -2 -9 -39 -25 -81 -29 -76 -44 -92 -73 -74 -11 7 -7 24 20 90\r
    29 71 36 80 53 75 12 -4 23 -8 25 -10z m1240 0 c2 -2 0 -33 -4 -69 l-7 -66\r
    -31 3 c-32 3 -32 3 -28 53 5 75 16 98 44 89 12 -3 24 -8 26 -10z m-3764 -26\r
    c2 -13 6 -45 7 -73 3 -49 3 -50 -27 -50 -29 0 -30 2 -37 60 -10 73 -6 85 26\r
    85 18 0 27 -6 31 -22z m2846 -58 c145 -38 361 -95 479 -126 118 -32 217 -59\r
    219 -61 12 -9 -30 -18 -282 -54 l-276 -40 -210 172 c-116 94 -211 173 -211\r
    175 0 8 20 3 281 -66z m-1648 -18 c15 -38 27 -71 27 -74 0 -3 -60 -41 -132\r
    -84 -159 -92 -369 -216 -533 -313 -65 -38 -121 -68 -124 -66 -2 3 -2 6 0 8 14\r
    11 265 223 269 227 3 3 79 67 169 140 90 74 189 156 220 182 31 26 61 47 66\r
    47 6 1 22 -30 38 -67z m972 -53 l120 -120 -35 -31 c-45 -39 -80 -62 -85 -57\r
    -2 3 -42 70 -90 149 -76 129 -83 145 -65 148 11 2 20 10 20 18 0 8 3 14 8 14\r
    4 0 61 -54 127 -121z m-504 81 c10 0 19 -2 19 -4 0 -5 -112 -209 -137 -249\r
    -27 -43 -32 -42 -98 16 l-40 36 115 116 c75 75 116 110 118 100 2 -8 12 -15\r
    23 -15z m49 -26 c0 -12 6 -15 25 -10 14 4 25 5 25 4 -1 -18 -82 -314 -87 -319\r
    -7 -7 -116 31 -130 44 -6 7 150 296 160 297 4 0 7 -7 7 -16z m354 -125 c42\r
    -71 76 -137 76 -145 0 -16 -73 -53 -106 -54 -16 0 -23 9 -31 43 -6 23 -25 94\r
    -42 157 -17 63 -31 116 -31 117 0 0 9 -1 20 -4 11 -3 20 0 20 6 0 31 25 -1 94\r
    -120z m-269 100 c4 -6 13 -8 21 -5 12 4 14 -23 14 -161 l0 -166 -59 6 c-33 3\r
    -64 8 -69 11 -11 7 67 326 79 326 4 0 11 -5 14 -11z m163 -149 c24 -88 41\r
    -164 38 -169 -3 -5 1 -11 9 -15 8 -3 15 -16 15 -30 0 -22 -6 -26 -47 -32 -27\r
    -4 -66 -8 -88 -8 -36 -1 -40 1 -40 24 0 20 6 26 30 29 29 4 30 4 5 10 l-25 7\r
    -3 167 c-2 156 3 190 24 156 5 -8 10 -6 16 5 5 9 12 16 16 16 4 0 27 -72 50\r
    -160z m1774 111 c7 -6 -15 -127 -24 -137 -7 -7 -58 14 -58 23 0 5 4 24 9 43 5\r
    19 12 48 15 63 6 23 10 27 29 21 12 -3 25 -9 29 -13z m-3940 -18 c11 -10 18\r
    -30 18 -51 0 -31 -9 -44 -66 -97 -52 -48 -65 -66 -62 -86 3 -27 20 -28 96 -8\r
    35 10 44 17 49 40 7 37 21 37 29 2 3 -16 12 -50 19 -78 8 -27 12 -51 9 -54 -2\r
    -3 -17 2 -32 11 -26 15 -34 15 -162 -18 -74 -20 -138 -38 -142 -42 -3 -4 -8\r
    -17 -10 -30 -7 -49 -24 -19 -51 91 -27 108 -28 116 -13 151 11 26 26 41 53 53\r
    36 15 40 14 77 -5 l38 -21 64 56 c52 47 62 62 58 80 -7 27 2 29 28 6z m237\r
    -51 c13 -55 13 -65 0 -73 -34 -21 -46 -10 -63 58 -18 71 -13 86 29 81 15 -2\r
    23 -17 34 -66z m2605 -47 c90 -52 233 -134 317 -183 285 -164 340 -197 332\r
    -199 -7 -3 -373 140 -835 325 -37 15 -68 31 -68 35 0 9 78 117 85 117 3 0 79\r
    -43 169 -95z m1518 59 c23 -16 53 -45 66 -64 34 -50 28 -149 -11 -208 -16 -24\r
    -24 -48 -20 -57 5 -15 -1 -16 -53 -10 -71 9 -88 20 -50 35 15 5 31 10 36 10\r
    20 0 79 63 90 95 14 44 -5 93 -51 126 -40 28 -142 38 -189 19 -76 -31 -101\r
    -115 -59 -194 11 -21 18 -40 15 -43 -24 -24 -76 71 -76 138 0 63 40 139 87\r
    167 31 19 50 22 105 20 56 -3 75 -9 110 -34z m-1832 -89 c19 -23 7 -40 -61\r
    -86 -59 -40 -63 -41 -76 -24 -7 11 -13 22 -13 26 0 8 120 99 131 99 3 0 12 -7\r
    19 -15z m1303 8 c7 -12 -46 -168 -90 -268 -62 -140 -76 -166 -88 -163 -16 4\r
    -424 331 -424 340 -1 11 19 15 304 57 292 44 292 44 298 34z m-3220 -49 c184\r
    -26 267 -41 265 -49 -4 -15 -404 -345 -419 -345 -29 0 -191 402 -173 431 3 6\r
    18 9 33 6 14 -3 147 -22 294 -43z m3293 25 c3 -5 -4 -39 -16 -74 -15 -46 -27\r
    -65 -39 -65 -35 0 -40 19 -21 80 10 32 20 62 24 68 7 11 43 5 52 -9z m-3635\r
    -26 c28 -74 34 -114 19 -123 -36 -23 -49 -11 -71 61 -18 59 -19 73 -8 80 26\r
    16 49 9 60 -18z m1031 -230 c-294 -304 -480 -488 -485 -483 -6 7 197 508 211\r
    522 12 12 470 197 491 197 7 1 -90 -106 -217 -236z m328 185 c33 -24 59 -46\r
    59 -50 1 -8 -419 -745 -443 -779 l-18 -24 7 25 c4 14 36 99 70 190 52 135 110\r
    292 246 658 5 12 11 22 15 22 3 0 32 -19 64 -42z m1313 -316 c197 -197 355\r
    -360 352 -363 -3 -3 -121 40 -263 96 -202 81 -260 108 -269 126 -7 13 -52 125\r
    -99 249 -47 124 -88 231 -91 238 -3 6 -1 12 3 12 5 0 170 -161 367 -358z\r
    m-1140 290 c80 -34 81 -35 72 -62 -8 -24 -16 -23 -113 21 -58 26 -62 30 -52\r
    49 14 25 13 25 93 -8z m727 -232 c285 -493 341 -592 337 -596 -3 -3 -56 57\r
    -118 133 -62 76 -196 239 -297 361 -101 123 -185 229 -187 235 -5 13 136 77\r
    146 68 4 -3 57 -94 119 -201z m1314 167 c18 -13 17 -16 -9 -75 -29 -64 -39\r
    -71 -68 -49 -16 11 -16 16 9 75 28 64 38 71 68 49z m-3509 -53 c14 -31 25 -60\r
    25 -64 0 -7 -51 -33 -56 -28 -7 8 -44 101 -44 112 0 10 27 30 48 35 1 1 13\r
    -24 27 -55z m1667 1 l46 -6 4 -502 c2 -276 2 -504 1 -506 -2 -2 -5 -2 -7 0 -9\r
    9 -146 947 -146 1000 0 25 3 28 28 24 15 -2 48 -7 74 -10z m-1012 -25 c0 -5\r
    -9 -29 -20 -52 -27 -59 -196 -468 -204 -495 -4 -13 -11 -23 -16 -23 -34 0\r
    -301 355 -280 373 9 8 495 205 508 206 6 1 12 -3 12 -9z m830 -137 c-17 -65\r
    -40 -149 -51 -188 -10 -38 -48 -180 -84 -315 -84 -320 -80 -305 -90 -305 -5 0\r
    -17 59 -27 130 -53 378 -56 409 -45 425 65 91 323 396 325 385 2 -7 -11 -67\r
    -28 -132z m442 90 c9 -32 58 -215 111 -408 106 -386 132 -493 123 -503 -4 -3\r
    -13 3 -20 14 -8 10 -82 106 -165 213 -112 144 -151 202 -151 222 0 15 16 134\r
    35 263 19 130 35 240 35 246 0 5 4 10 9 10 5 0 15 -26 23 -57z m936 37 c50\r
    -21 337 -131 410 -157 23 -8 42 -18 42 -23 0 -27 -202 -303 -258 -354 -21 -18\r
    -21 -18 -37 20 -86 201 -215 515 -215 524 0 14 4 13 58 -10z m-2793 -116 c35\r
    -62 36 -66 18 -80 -28 -22 -44 -13 -74 41 -39 70 -37 82 18 104 1 1 18 -29 38\r
    -65z m3370 52 c19 -14 19 -15 2 -53 -36 -75 -45 -85 -70 -72 -12 7 -24 13 -26\r
    15 -4 3 37 93 52 112 12 15 19 15 42 -2z m207 -75 c2 -20 27 -38 123 -93 66\r
    -37 126 -68 134 -68 8 0 23 7 33 17 33 30 30 6 -9 -62 -34 -61 -63 -86 -55\r
    -49 3 16 -85 76 -107 72 -12 -3 -91 -130 -91 -147 0 -4 23 -20 50 -35 49 -27\r
    52 -27 76 -11 14 9 28 15 30 12 7 -7 -66 -137 -76 -137 -5 0 -10 10 -12 22 -2\r
    18 -34 40 -133 97 l-129 74 -30 -17 c-16 -9 -31 -15 -33 -12 -5 5 64 133 77\r
    141 4 2 10 -8 13 -23 8 -35 124 -103 138 -81 18 28 79 137 79 142 0 10 -101\r
    67 -119 67 -10 0 -24 -7 -31 -15 -7 -8 -19 -15 -27 -15 -10 0 -3 20 23 68 21\r
    37 42 73 47 80 13 16 24 5 29 -27z m-283 -68 l21 -18 -37 -62 c-21 -35 -40\r
    -63 -44 -63 -4 0 -17 8 -29 18 l-22 18 39 62 c21 34 41 62 44 62 4 0 16 -8 28\r
    -17z m-3214 -48 c19 -31 35 -59 35 -63 0 -4 -12 -15 -25 -25 l-24 -17 -36 55\r
    c-19 30 -35 60 -35 65 0 7 38 40 47 40 1 0 18 -25 38 -55z m-268 30 c20 -14\r
    133 -193 133 -211 0 -3 -12 -3 -26 0 -21 6 -46 -4 -118 -45 -165 -95 -167 -97\r
    -160 -135 4 -20 2 -34 -3 -34 -6 0 -43 55 -83 122 l-73 122 29 23 c44 35 72\r
    29 38 -8 -13 -15 -14 -24 -5 -52 6 -18 20 -43 31 -55 l20 -21 46 26 c54 30 62\r
    45 40 78 -11 17 -26 25 -46 25 -44 0 -37 21 21 58 70 44 83 43 52 -4 -16 -24\r
    -15 -28 2 -60 10 -19 22 -34 28 -34 22 0 117 66 117 82 0 9 -17 35 -38 58 -30\r
    30 -47 40 -70 40 -21 0 -32 5 -32 14 0 26 65 33 97 11z m1110 -117 c-3 -7 -44\r
    -114 -91 -238 -112 -292 -108 -280 -112 -280 -25 0 -256 175 -323 243 l-44 46\r
    44 21 c97 45 505 219 518 219 7 1 11 -5 8 -11z m1753 -103 c146 -59 269 -110\r
    273 -114 9 -9 -91 -105 -179 -172 -96 -73 -176 -121 -185 -112 -12 12 -199\r
    484 -199 502 0 7 6 11 13 8 6 -3 131 -54 277 -112z m-2499 49 l43 -56 -23 -19\r
    c-13 -11 -26 -19 -30 -19 -9 0 -81 103 -81 115 0 8 31 34 41 35 4 0 26 -25 50\r
    -56z m3024 42 c22 -16 16 -35 -34 -95 -24 -30 -30 -32 -49 -22 -30 16 -28 31\r
    13 85 40 51 43 52 70 32z m-2078 -322 c18 -126 35 -262 39 -303 7 -67 6 -74\r
    -10 -68 -9 4 -42 14 -72 23 -53 15 -199 77 -297 125 -26 13 -46 29 -45 36 5\r
    22 332 423 342 420 6 -2 25 -107 43 -233z m1256 59 c80 -98 154 -189 166 -202\r
    12 -13 21 -30 21 -37 0 -24 -241 -137 -377 -177 -50 -15 -53 -15 -53 2 0 16\r
    64 488 75 559 3 17 10 32 14 32 5 0 74 -80 154 -177z m720 133 c24 -18 22 -25\r
    -28 -80 -44 -49 -45 -49 -65 -31 -28 25 -26 33 22 82 47 48 46 48 71 29z\r
    m-2822 -38 c44 -49 45 -55 22 -80 -16 -18 -18 -17 -65 29 -50 50 -56 61 -36\r
    81 21 21 39 13 79 -30z m1284 -60 c17 -79 75 -520 69 -529 -11 -19 -353 22\r
    -432 52 l-23 9 23 33 c12 17 28 39 35 47 33 42 252 331 278 367 34 49 43 52\r
    50 21z m285 -90 c233 -305 280 -372 273 -378 -27 -25 -434 -82 -446 -63 -3 4\r
    10 116 29 248 41 291 43 305 52 305 4 -1 45 -51 92 -112z m1145 72 c23 -25 17\r
    -38 -43 -88 -47 -40 -50 -41 -66 -24 -9 10 -16 23 -16 28 0 9 91 103 101 104\r
    3 0 14 -9 24 -20z m-2578 -54 c38 -34 40 -46 14 -70 -19 -17 -22 -16 -73 30\r
    -29 27 -55 50 -57 51 -3 2 6 14 19 28 26 28 17 32 97 -39z m2451 -58 c7 -7 12\r
    -19 12 -27 -1 -17 -87 -91 -106 -91 -6 0 -17 11 -24 25 -12 23 -12 27 9 41 12\r
    9 34 27 49 40 31 27 43 29 60 12z m-2342 -34 c48 -40 52 -49 28 -75 -15 -17\r
    -18 -16 -65 18 -53 38 -55 43 -37 73 17 27 23 26 74 -16z m-294 -14 c-2 -8\r
    -33 -93 -68 -188 -49 -131 -62 -177 -54 -187 8 -10 8 -15 0 -20 -12 -7 -123\r
    95 -114 105 3 3 15 5 27 5 18 0 30 20 73 120 28 66 50 121 49 123 -4 5 -187\r
    -70 -214 -87 -19 -12 -22 -21 -18 -48 3 -18 4 -33 1 -33 -9 0 -94 74 -94 82 0\r
    4 10 8 23 9 12 0 96 31 187 68 164 68 208 79 202 51z m423 -76 c30 -20 55 -40\r
    55 -44 0 -4 -8 -18 -18 -30 l-18 -23 -55 38 c-30 21 -56 39 -58 41 -4 4 27 54\r
    34 54 3 0 30 -16 60 -36z m2085 15 c14 -26 4 -39 -56 -74 -46 -27 -57 -26 -74\r
    5 -9 17 -3 24 42 55 61 41 73 43 88 14z m-140 -80 c17 -31 6 -46 -55 -76 -55\r
    -27 -57 -28 -71 -9 -22 31 -17 41 32 66 25 13 47 27 50 32 9 15 33 8 44 -13z\r
    m387 -1 c11 -13 34 -48 52 -80 26 -47 35 -55 53 -50 17 4 20 2 15 -12 -4 -10\r
    -10 -42 -13 -72 -4 -30 -10 -57 -15 -59 -4 -3 -16 8 -26 25 -12 20 -23 28 -33\r
    24 -8 -3 -23 -9 -32 -11 -26 -8 -23 21 5 40 l22 15 -32 58 c-34 63 -59 80 -65\r
    43 -2 -12 -9 -24 -15 -27 -9 -2 -13 10 -13 42 0 76 54 111 97 64z m-2186 -20\r
    c49 -27 58 -36 53 -53 -12 -38 -22 -38 -89 -4 -36 18 -65 34 -65 36 0 12 25\r
    53 33 53 5 0 36 -15 68 -32z m1649 -59 c18 -32 7 -44 -60 -69 -63 -23 -76 -21\r
    -82 15 -2 15 10 25 52 46 67 34 76 35 90 8z m-1501 -10 c50 -21 57 -31 45 -63\r
    -8 -21 -21 -20 -83 5 -50 21 -57 31 -45 63 8 21 21 20 83 -5z m1932 -169 c64\r
    -157 69 -165 93 -162 14 1 26 -1 26 -6 0 -15 -76 -71 -87 -64 -5 4 -25 46 -44\r
    94 -19 49 -36 88 -39 88 -3 0 -12 -15 -20 -33 -8 -17 -26 -37 -39 -44 -38 -18\r
    -66 2 -100 73 -31 66 -49 79 -58 44 -8 -28 -23 -25 -23 5 0 42 27 85 54 85 28\r
    0 49 -22 71 -75 28 -69 43 -87 64 -75 32 16 33 54 5 135 -21 62 -24 78 -13 91\r
    26 32 43 8 110 -156z m-2264 120 c35 -19 63 -41 63 -49 0 -7 -6 -11 -14 -8 -8\r
    3 -21 0 -29 -6 -20 -16 -147 -235 -147 -253 0 -8 7 -26 16 -39 23 -35 5 -32\r
    -71 13 -67 38 -79 52 -45 52 23 0 32 13 111 147 54 94 73 153 49 153 -5 0 -10\r
    7 -10 16 0 18 -3 19 77 -26z m1677 -2 c10 -40 7 -44 -47 -61 -72 -23 -84 -22\r
    -91 9 -4 15 -6 27 -4 29 4 3 121 43 129 44 4 1 9 -9 13 -21z m-1189 -6 c52\r
    -18 64 -36 43 -65 -12 -16 -16 -16 -76 4 -51 17 -62 25 -62 43 0 41 16 44 95\r
    18z m163 -42 c43 -10 52 -16 52 -33 0 -45 -11 -49 -83 -31 -52 13 -67 21 -67\r
    34 0 32 12 51 29 46 9 -2 40 -10 69 -16z m872 -5 c0 -14 0 -28 1 -32 0 -9 -86\r
    -33 -118 -33 -19 0 -23 6 -23 30 0 26 5 30 43 40 23 6 47 13 52 15 30 11 45 4\r
    45 -20z m-667 -35 c5 -4 7 -18 5 -31 -3 -23 -6 -24 -68 -21 -36 2 -68 6 -72\r
    10 -3 4 -4 20 -1 35 l6 29 61 -7 c33 -4 65 -11 69 -15z m510 -6 c5 -30 -9 -38\r
    -89 -49 -50 -6 -52 -6 -58 21 -10 40 8 50 100 53 37 1 42 -2 47 -25z m-335\r
    -31 l3 -33 -60 0 c-78 0 -91 6 -91 42 l0 29 73 -3 72 -3 3 -32z m172 8 c0 -24\r
    -5 -29 -31 -35 -47 -9 -117 -7 -124 4 -3 5 -3 21 1 35 6 24 9 25 80 25 l74 0\r
    0 -29z m727 -27 c12 -13 25 -43 28 -68 17 -109 -100 -222 -160 -156 -17 19\r
    -17 23 -2 54 13 27 45 59 96 93 2 1 -4 14 -13 28 -23 34 -60 33 -98 -5 -34\r
    -34 -38 -36 -38 -15 0 24 60 84 94 94 40 12 66 5 93 -25z m-1508 -191 c54\r
    -109 91 -172 95 -163 18 45 56 187 56 207 0 13 -10 29 -26 39 -14 9 -21 21\r
    -17 25 9 9 143 -29 143 -40 0 -3 -15 -13 -32 -21 -28 -13 -34 -26 -60 -110\r
    -41 -136 -45 -170 -19 -199 12 -13 19 -26 17 -29 -3 -2 -27 1 -55 8 l-50 12\r
    -77 159 c-43 87 -80 159 -83 159 -4 0 -19 -46 -35 -101 l-30 -102 28 -24 c16\r
    -13 26 -27 22 -30 -6 -6 -89 14 -120 30 -18 9 -17 10 10 22 27 11 32 23 73\r
    166 25 85 46 157 48 162 11 21 30 -8 112 -170z m772 21 c38 -39 48 -83 49\r
    -211 0 -101 0 -103 25 -109 47 -12 20 -29 -50 -32 -89 -4 -105 2 -74 27 23 18\r
    24 24 21 131 -4 158 -24 190 -116 190 -86 0 -115 -52 -116 -207 0 -70 3 -86\r
    20 -103 11 -11 27 -20 35 -20 8 0 15 -4 15 -10 0 -6 -28 -10 -65 -10 -36 0\r
    -65 3 -65 6 0 3 7 12 15 20 12 12 15 41 15 127 0 136 17 184 77 216 30 17 52\r
    21 111 18 65 -2 75 -5 103 -33z`}), u.jsx("path", {
                    d: `M3877 5053 c-12 -20 -37 -125 -32 -132 3 -5 24 -12 46 -16 49 -8 67\r
    5 75 56 5 28 1 41 -17 61 -25 28 -64 44 -72 31z`}), u.jsx("path", {
                        d: `M2279 4756 c-14 -30 11 -124 44 -161 20 -23 24 -25 41 -12 25 18 23\r
    68 -4 133 -30 69 -61 85 -81 40z`}), u.jsx("path", {
                            d: `M994 2160 c-46 -18 -70 -85 -39 -110 18 -15 124 7 132 27 7 19 -4 59\r
    -23 77 -17 18 -38 19 -70 6z`}), u.jsx("path", {
                                d: `M4111 634 c-25 -32 -27 -62 -5 -71 19 -7 42 14 44 42 6 61 -7 70 -39\r
    29z`})]
        })
    })
}), WS = () => { const [e, t] = S.useState([]); return S.useEffect(() => { const n = setInterval(() => { e.length < 12 && t(i => [...i, { left: `${Math.random() * 80}vw` }]) }, 3e3); return () => clearInterval(n) }, [e]), u.jsx("div", { className: "fireworks-container", children: e.map((n, i) => u.jsx(BS, { className: "firework", style: { left: n.left } }, i)) }) }; function VS() { return u.jsxs("div", { className: "landing-page", children: [u.jsx("div", { className: "heading", children: u.jsx("h1", { children: " Welcome to University of GreenWich Viet Nam" }) }), u.jsx("div", { className: "fireworks", children: u.jsx(WS, {}) })] }) } function US() { const [e, t] = S.useState([]), [n, i] = S.useState(null), [r, s] = S.useState(!1), [o, a] = S.useState(!0), [l, c] = S.useState(null), d = "http://localhost:3001/coordinators", f = "http://localhost:3001/coordinators"; S.useEffect(() => { (async () => { try { const x = await (await fetch(d)).json(); t(x), a(!1) } catch (v) { console.error("Error fetching users:", v), c(v), a(!1) } })() }, []); const h = async g => { try { const x = await (await fetch(`${f}/${g}`)).json(); i(x), p() } catch (v) { console.error("Error fetching user details:", v) } }, p = () => { s(!r) }; return o ? u.jsx("p", { children: "Loading..." }) : l ? u.jsxs("p", { children: ["Error: ", l.message] }) : u.jsxs("div", { children: [u.jsx("h2", { className: "header", children: "Directors" }), u.jsx("div", { className: "dashboard-content", children: e.map(g => u.jsxs(gr, { style: { width: "18%" }, children: [u.jsx("img", { alt: "Sample", src: g.avatarUrl, style: { width: "100%" } }), u.jsxs(mr, { className: "articles-container", children: [u.jsx(vr, { tag: "h2", children: g.name }), u.jsx(yr, { className: "mb-2 text-muted", tag: "h3", children: u.jsxs("p", { children: [" ID: ", g.coordinatorID, " "] }) }), u.jsx(L, { onClick: () => h(g.id), children: "Detail" })] })] }, g.id)) }), u.jsxs(wt, { isOpen: r, toggle: p, children: [u.jsx(at, { toggle: p, children: "User Detail" }), u.jsx(lt, { children: n && u.jsxs("div", { children: [u.jsxs("p", { children: [u.jsx("strong", { children: "ID:" }), " ", n.coordinatorID] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Name:" }), " ", n.name] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Email:" }), " ", n.email] }), u.jsx("p", { className: "director-class-managing", children: u.jsx("strong", { children: "Managing Classes" }) }), n && n.classManage && u.jsxs("div", { children: [u.jsx("strong", { children: "Class Name:" }), " ", n.classManage.map((g, v) => u.jsxs("span", { children: [g.className, v !== n.classManage.length - 1 && ", "] }, g.id)), u.jsx("br", {}), u.jsx("strong", { children: "Class Code:" }), " ", n.classManage.map((g, v) => u.jsxs("span", { children: [g.classCode, v !== n.classManage.length - 1 && ", "] }, g.id))] })] }) }), u.jsx(ct, { children: u.jsx(L, { color: "secondary", onClick: p, children: "Close" }) })] })] }) } function HS() { const [e, t] = S.useState([]), [n, i] = S.useState(null), [r, s] = S.useState(!1), [o, a] = S.useState(!0), [l, c] = S.useState(null), d = "http://localhost:3001/courses", f = "http://localhost:3001/courses"; S.useEffect(() => { (async () => { try { const x = await (await fetch(d)).json(); t(x), a(!1) } catch (v) { console.error("Error fetching courses:", v), c(v), a(!1) } })() }, []); const h = async g => { try { const x = await (await fetch(`${f}/${g}`)).json(); i(x), p() } catch (v) { console.error("Error fetching course details:", v) } }, p = () => { s(!r) }; return o ? u.jsx("p", { children: "Loading..." }) : l ? u.jsxs("p", { children: ["Error: ", l.message] }) : u.jsxs("div", { children: [u.jsx("h2", { className: "header", children: "Courses" }), u.jsx("div", { className: "dashboard-content", children: e.map(g => u.jsx(gr, { style: { width: "18%" }, children: u.jsxs(mr, { className: "articles-container", children: [u.jsx(vr, { tag: "h2", children: g.name }), u.jsx(yr, { className: "mb-2 text-muted", tag: "h3", children: u.jsxs("p", { children: [" Code: ", g.courseID, " "] }) }), u.jsx(L, { onClick: () => h(g.id), children: "Detail" })] }) }, g.id)) }), u.jsxs(wt, { isOpen: r, toggle: p, children: [u.jsx(at, { toggle: p, children: "Course Detail" }), u.jsx(lt, { children: n && u.jsxs("div", { children: [u.jsxs("p", { children: [u.jsx("strong", { children: "Code:" }), " ", n.courseID] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Name:" }), " ", n.name] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Create Date:" }), " ", n.createDate] }), u.jsxs("p", { children: [u.jsx("strong", { children: "Start date:" }), " ", n.startDate] }), u.jsxs("p", { children: [u.jsx("strong", { children: "End date:" }), " ", n.endDate] }), u.jsx("p", { className: "course-class-applying", children: u.jsx("strong", { children: "Applying with Classes" }) }), n && n.classApply && u.jsxs("div", { children: [u.jsx("strong", { children: "Class Name:" }), " ", n.classApply.map((g, v) => u.jsxs("span", { children: [g.className, v !== n.classApply.length - 1 && ", "] }, g.id)), u.jsx("br", {}), u.jsx("strong", { children: "Class Code:" }), " ", n.classApply.map((g, v) => u.jsxs("span", { children: [g.classCode, v !== n.classApply.length - 1 && ", "] }, g.id))] })] }) }), u.jsx(ct, { children: u.jsx(L, { color: "secondary", onClick: p, children: "Close" }) })] })] }) } function YS() { return u.jsxs("div", { children: ["Profile", u.jsx(Kd, {})] }) } function XS() { const [e, t] = S.useState([]), [n, i] = S.useState(!0), [r, s] = S.useState(null); return S.useEffect(() => { (async () => { try { const l = await (await fetch("http://localhost:3001/class")).json(); t(l), i(!1) } catch (a) { console.error("Error fetching classes:", a), s(a), i(!1) } })() }, []), n ? u.jsx("p", { children: "Loading..." }) : r ? u.jsxs("p", { children: ["Error: ", r.message] }) : u.jsxs("div", { children: [u.jsx("h2", { className: "header", children: "Classes" }), u.jsx("div", { className: "dashboard-content", children: e.map(o => u.jsx(gr, { style: { width: "18%" }, children: u.jsxs(mr, { className: "articles-container", children: [u.jsx(vr, { tag: "h2", children: o.className }), u.jsx(yr, { className: "mb-2 text-muted", tag: "h3", children: u.jsxs("p", { children: [" Code: ", o.classID, " "] }) }), u.jsx(Q, { to: `${o.id}`, className: "btn btn-primary", children: "Detail" })] }) }, o.id)) })] }) } function KS() { const { classId: e } = Bm(), t = `http://localhost:3001/class/${e}`, [n, i] = S.useState(null), [r, s] = S.useState(!0), [o, a] = S.useState(null), [l, c] = S.useState(!1), [d, f] = S.useState(!1), [h, p] = S.useState(!1), g = () => { c(!l) }, v = () => { f(!d) }, x = () => { p(!h) }, [y, m] = S.useState(""), [b, j] = S.useState(""), [w, k] = S.useState(""), [C, O] = S.useState(""), [D, T] = S.useState(""), [A, $] = S.useState(""), [se, Ee] = S.useState(""), [X, J] = S.useState(""), [q, M] = S.useState(""), [z, F] = S.useState(""); S.useEffect(() => { (async () => { try { const Kt = await (await fetch(t)).json(); i(Kt), s(!1) } catch (Z) { console.error("Error fetching class details:", Z), a(Z), s(!1) } })() }, [t]); const ie = async () => { try { const N = await fetch(t + "/classInfo", { method: "PUT", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ className: y, classID: b }) }); if (!N.ok) throw new Error("Failed to update class information"); const Z = await N.json(); i(Z), c(!l) } catch (N) { console.error("Error updating class information:", N) } }, re = async () => { try { const N = await fetch(t + "/coordinator", { method: "PUT", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ coordinatorName: w, coordinatorID: C }) }); if (!N.ok) throw new Error("Failed to edit coordinator"); const Z = await N.json(); i(Z), f(!d) } catch (N) { console.error("Error editing coordinator:", N) } }, pt = async () => { if (!D || !z || !q) { alert("Please enter all fields."); return } try { const N = await fetch(t + "/courses", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ courseName: D, startDate: z, endDate: q }) }); if (!N.ok) throw new Error("Failed to add course"); const Z = await N.json(); i(Z) } catch (N) { console.error("Error adding course:", N) } }, Ne = async () => { try { const N = await fetch(t + "/endDate", { method: "PUT", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ endDate: q }) }); if (!N.ok) throw new Error("Failed to set course due date"); const Z = await N.json(); i(Z), x() } catch (N) { console.error("Error setting course due date:", N) } }, [gt, ke] = S.useState(!1), [Yn, f2] = S.useState(null), [pf, h2] = S.useState(null), xr = () => ke(!gt), p2 = () => { Yn && (v2(Yn), ke(!1)), pf && (y2(pf), ke(!1)) }, g2 = async () => { if (!A) { alert("Please choose a file for upload"); return } try { const Z = new Date().toISOString().split("T")[0], Kt = n.documents || [], b2 = { documentUrl: A, uploadDate: Z }, _2 = [...Kt, b2], gf = await fetch(t + "/documents", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ documents: _2 }) }); if (!gf.ok) throw new Error("Failed to add document"); const w2 = await gf.json(); i(w2) } catch (N) { console.error("Error adding document:", N) } }, m2 = async () => { try { const N = await fetch(t + "/students", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ studentName: se, studentID: X }) }); if (!N.ok) throw new Error("Failed to add student"); const Z = await N.json(); i(Z) } catch (N) { console.error("Error adding student:", N) } }, y2 = async N => { try { const Z = await fetch(t + `/students/${N}`, { method: "DELETE" }); if (!Z.ok) throw new Error("Failed to delete student"); const Kt = await Z.json(); i(Kt) } catch (Z) { console.error("Error deleting student:", Z) } }, v2 = async N => { try { const Z = await fetch(t + `/courses/${N}`, { method: "DELETE" }); if (!Z.ok) throw new Error("Failed to delete course"); const Kt = await Z.json(); i(Kt) } catch (Z) { console.error("Error deleting course:", Z) } }, x2 = async N => { try { const Z = await fetch(t + `/documents/${N}`, { method: "DELETE" }); if (!Z.ok) throw new Error("Failed to delete document"); const Kt = await Z.json(); i(Kt) } catch (Z) { console.error("Error deleting document:", Z) } }; return r ? u.jsx("p", { children: "Loading..." }) : o ? u.jsxs("p", { children: ["Error: ", o.message] }) : u.jsxs("div", { children: [n && u.jsxs("div", { children: [u.jsxs("div", { className: "class-detail-header", children: [u.jsxs("h2", { children: [u.jsx("strong", { children: n.className }), u.jsxs("strong", { children: ["(", n.classID, ")"] })] }), !l && u.jsx(L, { style: { backgroundColor: "unset", border: "unset", paddingBottom: "0" }, onClick: g, children: u.jsx("box-icon", { name: "edit" }) })] }), l && u.jsxs(wt, { isOpen: l, children: [u.jsx(at, { style: { textAlign: "center" }, toggle: g, children: "Edit Class Information" }), u.jsxs(lt, { children: [u.jsx(Bt, { children: "Edit Class Name" }), u.jsx(V, { value: y, onChange: N => m(N.target.value), type: "text", placeholder: "Class Name", required: !0 }), u.jsx(Bt, { children: "Edit Class ID" }), u.jsx(V, { value: b, onChange: N => j(N.target.value), type: "text", placeholder: "Class ID", required: !0 })] }), u.jsxs(ct, { children: [u.jsx(L, { color: "primary", variant: "primary", onClick: ie, children: "Update" }), u.jsx(L, { variant: "secondary", onClick: g, children: "Cancel" })] })] }), u.jsxs("div", { className: "coordinator", children: [u.jsxs("h4", { children: [u.jsx("strong", { children: "Coordinator: " }), n.coordinatorName, " - ", u.jsx("strong", { children: "ID: " }), " ", n.coordinatorID, !d && u.jsx(L, { style: { backgroundColor: "unset", border: "unset", paddingBottom: "0" }, onClick: v, children: u.jsx("box-icon", { name: "edit" }) })] }), d && u.jsxs(wt, { isOpen: d, children: [u.jsx(at, { style: { textAlign: "center" }, toggle: v, children: "Edit Coordinator Information" }), u.jsxs(lt, { children: [u.jsx(Bt, { children: "Edit Coordinator Name" }), u.jsx(V, { value: w, onChange: N => k(N.target.value), type: "text", placeholder: "Coordinator Name" }), u.jsx(Bt, { children: "Edit Coordinator ID" }), u.jsx(V, { value: C, onChange: N => O(N.target.value), type: "text", placeholder: "Coordinator ID" })] }), u.jsxs(ct, { children: [u.jsx(L, { color: "primary", variant: "primary", onClick: re, children: "Update" }), u.jsx(L, { variant: "secondary", onClick: v, children: "Cancel" })] })] })] }), u.jsxs("div", { className: "student", children: [u.jsx("h3", { children: "Students" }), u.jsxs(tt, { striped: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { scope: "row", children: "Student ID" }), u.jsx("th", { children: "Student Name" }), u.jsx("th", { children: "Action" })] }) }), u.jsx("tbody", { children: n.students && n.students.map(N => u.jsxs("tr", { children: [u.jsx("td", { style: { width: "20%" }, children: N.studentID }), u.jsx("td", { children: N.studentName }), u.jsx("td", { style: { width: "10%" }, children: u.jsx(L, { color: "danger", onClick: () => { h2(N.id), xr() }, children: "Delete" }) })] }, N.id)) })] }), u.jsx(V, { type: "text", value: se, onChange: N => Ee(N.target.value), placeholder: "Enter student name" }), u.jsx(V, { type: "text", value: X, onChange: N => J(N.target.value), placeholder: "Enter student ID" }), u.jsx(L, { onClick: m2, children: "Add" })] }), u.jsxs("div", { className: "courses", children: [u.jsx("h3", { children: "Courses" }), u.jsxs(tt, { striped: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Name" }), u.jsx("th", { children: "Code" }), u.jsx("th", { children: "Release" }), u.jsx("th", { children: "Open" }), u.jsx("th", { children: "Close" }), u.jsx("th", { children: "Action" })] }) }), u.jsx("tbody", { children: n.courses && n.courses.map(N => u.jsxs("tr", { children: [u.jsx("td", { children: N.courseName }), u.jsx("td", { children: N.courseID }), u.jsx("td", { children: N.publicDate }), u.jsx("td", { children: N.startDate }), u.jsx("td", { children: N.endDate }), u.jsxs("td", { style: { width: "25%" }, children: [u.jsx(L, { style: { marginRight: "5px" }, color: "danger", onClick: () => { f2(N.id), xr() }, children: "Delete" }), u.jsx(L, { style: { marginLeft: "5px" }, color: "primary", onClick: () => x(N.id), children: "Set date" }), u.jsx(Q, { to: `course/${N.id}/submissions`, children: u.jsx(L, { style: { marginLeft: "5px" }, color: "success", children: "Articles" }) })] })] }, N.id)) })] }), u.jsxs(wt, { isOpen: gt, toggle: xr, children: [u.jsx(at, { toggle: xr, children: "Confirm Delete" }), u.jsx(lt, { children: "Are you sure you want to delete. Your data will be deleted!!" }), u.jsxs(ct, { children: [u.jsx(L, { color: "danger", onClick: p2, children: "Delete" }), " ", u.jsx(L, { color: "secondary", onClick: xr, children: "Cancel" })] })] }), u.jsx(V, { style: { width: "30%" }, type: "text", value: D, onChange: N => T(N.target.value), placeholder: "Enter new course name", required: !0 }), u.jsxs("div", { style: { display: "flex", gap: "10px" }, children: [u.jsxs("div", { children: [u.jsx(Bt, { children: u.jsx("strong", { children: "Start Date" }) }), u.jsx(V, { type: "date", value: z, onChange: N => F(N.target.value), required: !0 })] }), u.jsxs("div", { children: [u.jsx(Bt, { children: u.jsx("strong", { children: "End Date" }) }), u.jsx(V, { type: "date", value: q, onChange: N => M(N.target.value), required: !0 })] })] }), u.jsx(L, { onClick: pt, children: "Add" }), h && u.jsxs(wt, { isOpen: h, children: [u.jsx(at, { style: { textAlign: "center" }, toggle: x, children: "Edit Course Due Date" }), u.jsxs(lt, { children: [u.jsx(Bt, { children: "Choose new due date for course" }), u.jsx(V, { type: "date", onChange: N => M(N.target.value), value: q, required: !0 })] }), u.jsxs(ct, { children: [u.jsx(L, { color: "primary", variant: "primary", onClick: Ne, children: "Update" }), u.jsx(L, { variant: "secondary", onClick: x, children: "Cancel" })] })] })] }), u.jsx("h3", { children: "Documents" }), u.jsxs(tt, { striped: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Document" }), u.jsx("th", { children: "Upload date" }), u.jsx("th", { children: "Action" })] }) }), u.jsx("tbody", { children: n.documents && n.documents.map(N => u.jsxs("tr", { children: [u.jsx("td", { href: N.documentUrl, children: N.documentUrl }), u.jsx("td", { children: N.uploadDate }), u.jsx("td", { style: { width: "10%" }, children: u.jsx(L, { color: "danger", onClick: () => x2(N.id), children: "Delete" }) })] }, N.id)) })] }), u.jsx(V, { type: "file", value: A, onChange: N => $(N.target.value), placeholder: "Enter document URL", required: !0 }), u.jsx(L, { onClick: g2, children: "Add " })] }), u.jsx(pr, {})] }) } const GS = () => { const { classId: e, courseId: t } = Bm(), n = `http://localhost:3001/class/${e}`, [i, r] = S.useState(null); return S.useEffect(() => { (async () => { try { const o = await fetch(`${n}`); if (!o.ok) throw new Error("Failed to fetch course submissions"); const a = await o.json(); r(a) } catch (o) { console.error("Error fetching course submissions:", o) } })() }, [t, e]), u.jsx("div", { children: i && u.jsxs("div", { children: [u.jsxs("h2", { children: ["Submissions for Course: ", t] }), u.jsxs(tt, { striped: !0, children: [u.jsx("thead", { children: u.jsxs("tr", { children: [u.jsx("th", { children: "Submission Title" }), u.jsx("th", { children: "Student ID" }), u.jsx("th", { children: "Student Name" }), u.jsx("th", { children: "Grade" }), u.jsx("th", { children: "Comment" }), u.jsx("th", { children: "Graded" })] }) }), u.jsx("tbody", { children: i.courses.map(s => s.id === t && s.submissions.map(o => u.jsxs("tr", { children: [u.jsx("td", { children: o.submissionTitle }), u.jsx("td", { children: o.studentID }), u.jsx("td", { children: o.studentName }), u.jsx("td", { children: o.grade }), u.jsx("td", { children: o.comment }), u.jsx("td", { children: o.graded })] }, o.id))) })] })] }) }) }, Rr = e => { const t = JSON.parse(localStorage.getItem("user")); return t && t.role === e }, QS = () => u.jsx(Gx, { children: u.jsxs(Wx, { children: [u.jsxs(W, { path: "/", element: u.jsx(e_, {}), children: [u.jsx(W, { path: "/about", element: u.jsx(t_, {}) }), u.jsx(W, { path: "/contact", element: u.jsx(n_, {}) }), u.jsx(W, { path: "*", element: u.jsx(i_, {}) }), u.jsx(W, { path: "/login", element: u.jsx(Xd, {}) }), u.jsx(W, { path: "/register", element: u.jsx(l0, {}) }), u.jsx(W, { path: "/terms", element: u.jsx(a0, {}) })] }), u.jsxs(W, { path: "/user", element: Rr("student") ? u.jsx(s_, {}) : u.jsx(Pr, { to: "/login" }), children: [u.jsx(W, { path: "dashboard", element: u.jsx(u_, {}) }), u.jsx(W, { path: "submissions", element: u.jsx(d_, {}) }), u.jsx(W, { path: "create", element: u.jsx(g_, {}) }), u.jsx(W, { path: "messages", element: u.jsx(f_, {}) }), u.jsx(W, { path: "profile", element: u.jsx(h_, {}) })] }), u.jsxs(W, { path: "/coordinator", element: Rr("coordinator") ? u.jsx(a_, {}) : u.jsx(Pr, { to: "/login" }), children: [u.jsx(W, { path: "dashboard", element: u.jsx(p_, {}) }), u.jsx(W, { path: "articles", element: u.jsx(Gh, {}) }), u.jsx(W, { path: "create-user", element: u.jsx(m_, {}) }), u.jsx(W, { path: "messages", element: u.jsx(y_, {}) }), u.jsx(W, { path: "profile", element: u.jsx(v_, {}) }), u.jsx(W, { path: "settings", element: u.jsx(Gh, {}) }), u.jsx(W, { path: "classroom", element: u.jsx(RS, {}), children: u.jsx(W, { path: "submission", element: u.jsx(hf, {}) }) })] }), u.jsxs(W, { path: "/manager", element: Rr("manager") ? u.jsx(c_, {}) : u.jsx(Pr, { to: "/login" }), children: [u.jsx(W, { path: "", element: u.jsx(VS, {}) }), u.jsx(W, { path: "dashboard", element: u.jsx(ES, {}) }), u.jsx(W, { path: "director", element: u.jsx(US, {}) }), u.jsx(W, { path: "courses", element: u.jsx(HS, {}) }), u.jsx(W, { path: "classes", element: u.jsx(XS, {}) }), u.jsx(W, { path: "classes/:classId", element: u.jsx(KS, {}) }), u.jsx(W, { path: "classes/:classId/course/:courseId/submissions", element: u.jsx(GS, {}) }), u.jsx(W, { path: "profile", element: u.jsx(YS, {}) })] }), u.jsx(W, { path: "/admin", element: Rr("admin") ? u.jsx(LS, {}) : u.jsx(Pr, { to: "/login" }), children: u.jsx(W, { path: "dashboard", element: u.jsx(AS, {}) }) }), u.jsx(W, { path: "/guest", element: Rr("guest") ? u.jsx(FS, {}) : u.jsx(Pr, { to: "/login" }), children: u.jsx(W, { path: "dashboard", element: u.jsx($S, {}) }) })] }) }); Zl.createRoot(document.getElementById("root")).render(u.jsx(I.StrictMode, { children: u.jsx(QS, { children: u.jsx(qv, {}) }) }));
